#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/ini/lib/ini.js
var require_ini = __commonJS((exports, module) => {
  var { hasOwnProperty } = Object.prototype;
  var encode = (obj, opt = {}) => {
    if (typeof opt === "string") {
      opt = { section: opt };
    }
    opt.align = opt.align === true;
    opt.newline = opt.newline === true;
    opt.sort = opt.sort === true;
    opt.whitespace = opt.whitespace === true || opt.align === true;
    opt.platform = opt.platform || typeof process !== "undefined" && process.platform;
    opt.bracketedArray = opt.bracketedArray !== false;
    const eol = opt.platform === "win32" ? `\r
` : `
`;
    const separator = opt.whitespace ? " = " : "=";
    const children2 = [];
    const keys6 = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
    let padToChars = 0;
    if (opt.align) {
      padToChars = safe(keys6.filter((k) => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== "object").map((k) => Array.isArray(obj[k]) ? `${k}[]` : k).concat([""]).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)).length;
    }
    let out = "";
    const arraySuffix = opt.bracketedArray ? "[]" : "";
    for (const k of keys6) {
      const val = obj[k];
      if (val && Array.isArray(val)) {
        for (const item of val) {
          out += safe(`${k}${arraySuffix}`).padEnd(padToChars, " ") + separator + safe(item) + eol;
        }
      } else if (val && typeof val === "object") {
        children2.push(k);
      } else {
        out += safe(k).padEnd(padToChars, " ") + separator + safe(val) + eol;
      }
    }
    if (opt.section && out.length) {
      out = "[" + safe(opt.section) + "]" + (opt.newline ? eol + eol : eol) + out;
    }
    for (const k of children2) {
      const nk = splitSections(k, ".").join("\\.");
      const section = (opt.section ? opt.section + "." : "") + nk;
      const child = encode(obj[k], {
        ...opt,
        section
      });
      if (out.length && child.length) {
        out += eol;
      }
      out += child;
    }
    return out;
  };
  function splitSections(str, separator) {
    var lastMatchIndex = 0;
    var lastSeparatorIndex = 0;
    var nextIndex = 0;
    var sections = [];
    do {
      nextIndex = str.indexOf(separator, lastMatchIndex);
      if (nextIndex !== -1) {
        lastMatchIndex = nextIndex + separator.length;
        if (nextIndex > 0 && str[nextIndex - 1] === "\\") {
          continue;
        }
        sections.push(str.slice(lastSeparatorIndex, nextIndex));
        lastSeparatorIndex = nextIndex + separator.length;
      }
    } while (nextIndex !== -1);
    sections.push(str.slice(lastSeparatorIndex));
    return sections;
  }
  var decode3 = (str, opt = {}) => {
    opt.bracketedArray = opt.bracketedArray !== false;
    const out = Object.create(null);
    let p = out;
    let section = null;
    const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
    const lines = str.split(/[\r\n]+/g);
    const duplicates = {};
    for (const line of lines) {
      if (!line || line.match(/^\s*[;#]/) || line.match(/^\s*$/)) {
        continue;
      }
      const match18 = line.match(re);
      if (!match18) {
        continue;
      }
      if (match18[1] !== undefined) {
        section = unsafe(match18[1]);
        if (section === "__proto__") {
          p = Object.create(null);
          continue;
        }
        p = out[section] = out[section] || Object.create(null);
        continue;
      }
      const keyRaw = unsafe(match18[2]);
      let isArray2;
      if (opt.bracketedArray) {
        isArray2 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
      } else {
        duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;
        isArray2 = duplicates[keyRaw] > 1;
      }
      const key = isArray2 && keyRaw.endsWith("[]") ? keyRaw.slice(0, -2) : keyRaw;
      if (key === "__proto__") {
        continue;
      }
      const valueRaw = match18[3] ? unsafe(match18[4]) : true;
      const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
      if (isArray2) {
        if (!hasOwnProperty.call(p, key)) {
          p[key] = [];
        } else if (!Array.isArray(p[key])) {
          p[key] = [p[key]];
        }
      }
      if (Array.isArray(p[key])) {
        p[key].push(value);
      } else {
        p[key] = value;
      }
    }
    const remove9 = [];
    for (const k of Object.keys(out)) {
      if (!hasOwnProperty.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k])) {
        continue;
      }
      const parts2 = splitSections(k, ".");
      p = out;
      const l = parts2.pop();
      const nl = l.replace(/\\\./g, ".");
      for (const part of parts2) {
        if (part === "__proto__") {
          continue;
        }
        if (!hasOwnProperty.call(p, part) || typeof p[part] !== "object") {
          p[part] = Object.create(null);
        }
        p = p[part];
      }
      if (p === out && nl === l) {
        continue;
      }
      p[nl] = out[k];
      remove9.push(k);
    }
    for (const del of remove9) {
      delete out[del];
    }
    return out;
  };
  var isQuoted = (val) => {
    return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
  };
  var safe = (val) => {
    if (typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
      return JSON.stringify(val);
    }
    return val.split(";").join("\\;").split("#").join("\\#");
  };
  var unsafe = (val) => {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'") {
        val = val.slice(1, -1);
      }
      try {
        val = JSON.parse(val);
      } catch {}
    } else {
      let esc = false;
      let unesc = "";
      for (let i = 0, l = val.length;i < l; i++) {
        const c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1) {
            unesc += c;
          } else {
            unesc += "\\" + c;
          }
          esc = false;
        } else if (";#".indexOf(c) !== -1) {
          break;
        } else if (c === "\\") {
          esc = true;
        } else {
          unesc += c;
        }
      }
      if (esc) {
        unesc += "\\";
      }
      return unesc.trim();
    }
    return val;
  };
  module.exports = {
    parse: decode3,
    decode: decode3,
    stringify: encode,
    encode,
    safe,
    unsafe
  };
});

// node_modules/toml/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  module.exports = function() {
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
    }
    function SyntaxError2(message, expected, found, offset, line, column) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line;
      this.column = column;
      this.name = "SyntaxError";
    }
    peg$subclass(SyntaxError2, Error);
    function parse3(input) {
      var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
        return nodes;
      }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = undefined, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
        addNode(node("ObjectPath", name, line, column));
      }, peg$c12 = function(name) {
        addNode(node("ArrayPath", name, line, column));
      }, peg$c13 = function(parts2, name) {
        return parts2.concat(name);
      }, peg$c14 = function(name) {
        return [name];
      }, peg$c15 = function(name) {
        return name;
      }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
        addNode(node("Assign", value, line, column, key));
      }, peg$c21 = function(chars) {
        return chars.join("");
      }, peg$c22 = function(node2) {
        return node2.value;
      }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
        return node("String", chars.join(""), line, column);
      }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
        return char;
      }, peg$c34 = function(char) {
        return char;
      }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
        return "";
      }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left3, right3) {
        return node("Float", parseFloat(left3 + "e" + right3), line, column);
      }, peg$c43 = function(text2) {
        return node("Float", parseFloat(text2), line, column);
      }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
        return digits.join("");
      }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
        return "-" + digits.join("");
      }, peg$c50 = function(text2) {
        return node("Integer", parseInt(text2, 10), line, column);
      }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
        return node("Boolean", true, line, column);
      }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
        return node("Boolean", false, line, column);
      }, peg$c57 = function() {
        return node("Array", [], line, column);
      }, peg$c58 = function(value) {
        return node("Array", value ? [value] : [], line, column);
      }, peg$c59 = function(values3) {
        return node("Array", values3, line, column);
      }, peg$c60 = function(values3, value) {
        return node("Array", values3.concat(value), line, column);
      }, peg$c61 = function(value) {
        return value;
      }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values3) {
        return node("InlineTable", values3, line, column);
      }, peg$c69 = function(key, value) {
        return node("InlineTableValue", value, line, column, key);
      }, peg$c70 = function(digits) {
        return "." + digits;
      }, peg$c71 = function(date) {
        return date.join("");
      }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time3) {
        return time3.join("");
      }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date, time3) {
        return node("Date", new Date(date + "T" + time3 + "Z"), line, column);
      }, peg$c80 = function(date, time3) {
        return node("Date", new Date(date + "T" + time3), line, column);
      }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = `
`, peg$c84 = { type: "literal", value: `
`, description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
        return "";
      }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
        return d.join("");
      }, peg$c97 = "\\\"", peg$c98 = { type: "literal", value: "\\\"", description: '"\\\\\\""' }, peg$c99 = function() {
        return '"';
      }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
        return "\\";
      }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
        return "\b";
      }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
        return "\t";
      }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
        return `
`;
      }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
        return "\f";
      }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
        return "\r";
      }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
        return convertCodePoint(digits.join(""));
      }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$reportedPos, peg$currPos);
      }
      function offset() {
        return peg$reportedPos;
      }
      function line() {
        return peg$computePosDetails(peg$reportedPos).line;
      }
      function column() {
        return peg$computePosDetails(peg$reportedPos).column;
      }
      function expected(description) {
        throw peg$buildException(null, [{ type: "other", description }], peg$reportedPos);
      }
      function error3(message) {
        throw peg$buildException(message, null, peg$reportedPos);
      }
      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p, ch;
          for (p = startPos;p < endPos; p++) {
            ch = input.charAt(p);
            if (ch === `
`) {
              if (!details.seenCR) {
                details.line++;
              }
              details.column = 1;
              details.seenCR = false;
            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
              details.line++;
              details.column = 1;
              details.seenCR = true;
            } else {
              details.column++;
              details.seenCR = false;
            }
          }
        }
        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0;
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advance(peg$cachedPosDetails, peg$cachedPos, pos);
          peg$cachedPos = pos;
        }
        return peg$cachedPosDetails;
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildException(message, expected2, pos) {
        function cleanupExpected(expected3) {
          var i = 1;
          expected3.sort(function(a, b) {
            if (a.description < b.description) {
              return -1;
            } else if (a.description > b.description) {
              return 1;
            } else {
              return 0;
            }
          });
          while (i < expected3.length) {
            if (expected3[i - 1] === expected3[i]) {
              expected3.splice(i, 1);
            } else {
              i++;
            }
          }
        }
        function buildMessage(expected3, found2) {
          function stringEscape(s) {
            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
              return "\\x" + hex(ch);
            }).replace(/[\u0180-\u0FFF]/g, function(ch) {
              return "\\u0" + hex(ch);
            }).replace(/[\u1080-\uFFFF]/g, function(ch) {
              return "\\u" + hex(ch);
            });
          }
          var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
          for (i = 0;i < expected3.length; i++) {
            expectedDescs[i] = expected3[i].description;
          }
          expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
          foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
          return "Expected " + expectedDesc + " but " + foundDesc + " found.";
        }
        var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
        if (expected2 !== null) {
          cleanupExpected(expected2);
        }
        return new SyntaxError2(message !== null ? message : buildMessage(expected2, found), expected2, found, pos, posDetails.line, posDetails.column);
      }
      function peg$parsestart() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 0, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseline();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseline();
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c1();
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseline() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 1, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpression();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parsecomment();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parsecomment();
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseNL();
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseNL();
                  }
                } else {
                  s5 = peg$c2;
                }
                if (s5 === peg$FAILED) {
                  s5 = peg$parseEOF();
                }
                if (s5 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4, s5];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseNL();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseNL();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseEOF();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseexpression() {
        var s0;
        var key = peg$currPos * 49 + 2, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$parsecomment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsepath();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetablearray();
            if (s0 === peg$FAILED) {
              s0 = peg$parseassignment();
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 3, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c4);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseNL();
          if (s5 === peg$FAILED) {
            s5 = peg$parseEOF();
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c5;
          } else {
            peg$currPos = s4;
            s4 = peg$c2;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseNL();
            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c5;
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsepath() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 4, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetable_key();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s5 = peg$c9;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c11(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetablearray() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 49 + 5, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c7;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parsetable_key();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s6 = peg$c9;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s7 = peg$c9;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c12(s4);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetable_key() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 6, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedot_ended_table_key_part();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsedot_ended_table_key_part();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsetable_key_part();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsetable_key_part();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetable_key_part() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 7, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c15(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedot_ended_table_key_part() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 8, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsequoted_key();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseassignment() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 9, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsekey();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c18;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c19);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsevalue();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c20(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsequoted_key();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsevalue();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsekey() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 10, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseASCII_BASIC();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseASCII_BASIC();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c21(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsequoted_key() {
        var s0, s1;
        var key = peg$currPos * 49 + 11, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedouble_quoted_single_line_string();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c22(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsesingle_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsevalue() {
        var s0;
        var key = peg$currPos * 49 + 12, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedatetime();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefloat();
            if (s0 === peg$FAILED) {
              s0 = peg$parseinteger();
              if (s0 === peg$FAILED) {
                s0 = peg$parseboolean();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsearray();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseinline_table();
                  }
                }
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsestring() {
        var s0;
        var key = peg$currPos * 49 + 13, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$parsedouble_quoted_multiline_string();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedouble_quoted_single_line_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsesingle_quoted_multiline_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_single_line_string();
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedouble_quoted_multiline_string() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 14, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c23) {
          s1 = peg$c23;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsemultiline_string_char();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsemultiline_string_char();
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s4 = peg$c23;
                peg$currPos += 3;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedouble_quoted_single_line_string() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 15, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsestring_char();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsestring_char();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c27;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesingle_quoted_multiline_string() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 16, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c29) {
          s1 = peg$c29;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 === peg$FAILED) {
            s2 = peg$c25;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsemultiline_literal_char();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsemultiline_literal_char();
            }
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c29) {
                s4 = peg$c29;
                peg$currPos += 3;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c30);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesingle_quoted_single_line_string() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 17, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c31;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseliteral_char();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseliteral_char();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c31;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsestring_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 18, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$parseESCAPED();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c27;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseliteral_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 19, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 39) {
          s2 = peg$c31;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_string_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 20, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$parseESCAPED();
        if (s0 === peg$FAILED) {
          s0 = peg$parsemultiline_string_delim();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 3) === peg$c23) {
              s2 = peg$c23;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c34(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_string_delim() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 21, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseNL();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseNLS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseNLS();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c37();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsemultiline_literal_char() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 22, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 3) === peg$c29) {
          s2 = peg$c29;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c30);
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c5;
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsefloat() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 49 + 23, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsefloat_text();
        if (s1 === peg$FAILED) {
          s1 = peg$parseinteger_text();
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 101) {
            s2 = peg$c38;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c39);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 69) {
              s2 = peg$c40;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c41);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseinteger_text();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c42(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c43(s1);
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsefloat_text() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 24, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c25;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseDIGITS();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGITS();
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c46(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDIGITS();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGITS();
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c49(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinteger() {
        var s0, s1;
        var key = peg$currPos * 49 + 25, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseinteger_text();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c50(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinteger_text() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 26, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c44;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c25;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = peg$c5;
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = peg$c5;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseboolean() {
        var s0, s1;
        var key = peg$currPos * 49 + 27, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c51) {
          s1 = peg$c51;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c53();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c54) {
            s1 = peg$c54;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c55);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c56();
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 28, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsearray_sep();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsearray_sep();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c10);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c57();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsearray_value();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c58(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearray_value_list();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsearray_value_list();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c59(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsearray_value_list();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsearray_value_list();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsearray_value();
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s4 = peg$c9;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c60(s2, s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_value() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 29, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsearray_sep();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsearray_sep();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsearray_sep();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsearray_sep();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c61(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_value_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 49 + 30, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsearray_sep();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsearray_sep();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsevalue();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsearray_sep();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsearray_sep();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c62;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c63);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parsearray_sep();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parsearray_sep();
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsearray_sep() {
        var s0;
        var key = peg$currPos * 49 + 31, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$parseS();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parsecomment();
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinline_table() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 49 + 32, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c64;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseS();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseS();
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseinline_table_assignment();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseinline_table_assignment();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseS();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s5 = peg$c66;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c67);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c68(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseinline_table_assignment() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 33, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsekey();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s4 = peg$c18;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseS();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseS();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsevalue();
                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parseS();
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parseS();
                    }
                    if (s7 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s8 = peg$c62;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c63);
                        }
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = [];
                        s10 = peg$parseS();
                        while (s10 !== peg$FAILED) {
                          s9.push(s10);
                          s10 = peg$parseS();
                        }
                        if (s9 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c69(s2, s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c18;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c69(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsesecfragment() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 34, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c17);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseDIGITS();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c70(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedate() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        var key = peg$currPos * 49 + 35, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDIGIT_OR_UNDER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s6 = peg$c47;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c48);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseDIGIT_OR_UNDER();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 45) {
                        s9 = peg$c47;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c48);
                        }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseDIGIT_OR_UNDER();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseDIGIT_OR_UNDER();
                          if (s11 !== peg$FAILED) {
                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                            s1 = s2;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c71(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetime() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 36, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment();
                        if (s10 === peg$FAILED) {
                          s10 = peg$c25;
                        }
                        if (s10 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsetime_with_offset() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
        var key = peg$currPos * 49 + 37, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDIGIT_OR_UNDER();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c72;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDIGIT_OR_UNDER();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDIGIT_OR_UNDER();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c72;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c73);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseDIGIT_OR_UNDER();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseDIGIT_OR_UNDER();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsesecfragment();
                        if (s10 === peg$FAILED) {
                          s10 = peg$c25;
                        }
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 45) {
                            s11 = peg$c47;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c48);
                            }
                          }
                          if (s11 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 43) {
                              s11 = peg$c44;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c45);
                              }
                            }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseDIGIT_OR_UNDER();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parseDIGIT_OR_UNDER();
                              if (s13 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 58) {
                                  s14 = peg$c72;
                                  peg$currPos++;
                                } else {
                                  s14 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c73);
                                  }
                                }
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parseDIGIT_OR_UNDER();
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parseDIGIT_OR_UNDER();
                                    if (s16 !== peg$FAILED) {
                                      s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                      s1 = s2;
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parsedatetime() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 49 + 38, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedate();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 84) {
            s2 = peg$c75;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetime();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 90) {
                s4 = peg$c77;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c79(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s2 = peg$c75;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetime_with_offset();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c80(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseS() {
        var s0;
        var key = peg$currPos * 49 + 39, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        if (peg$c81.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c82);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseNL() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 40, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c83;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 13) {
            s1 = peg$c85;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s2 = peg$c83;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseNLS() {
        var s0;
        var key = peg$currPos * 49 + 41, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$parseNL();
        if (s0 === peg$FAILED) {
          s0 = peg$parseS();
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseEOF() {
        var s0, s1;
        var key = peg$currPos * 49 + 42, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = peg$c5;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseHEX() {
        var s0;
        var key = peg$currPos * 49 + 43, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        if (peg$c87.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseDIGIT_OR_UNDER() {
        var s0, s1;
        var key = peg$currPos * 49 + 44, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        if (peg$c89.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c90);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 95) {
            s1 = peg$c91;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c93();
          }
          s0 = s1;
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseASCII_BASIC() {
        var s0;
        var key = peg$currPos * 49 + 45, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        if (peg$c94.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c95);
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseDIGITS() {
        var s0, s1, s2;
        var key = peg$currPos * 49 + 46, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseDIGIT_OR_UNDER();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseDIGIT_OR_UNDER();
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c96(s1);
        }
        s0 = s1;
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseESCAPED() {
        var s0, s1;
        var key = peg$currPos * 49 + 47, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c97) {
          s1 = peg$c97;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c99();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c100) {
            s1 = peg$c100;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c101);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c102();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c103) {
              s1 = peg$c103;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c104);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c105();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c106) {
                s1 = peg$c106;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c107);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c108();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c109) {
                  s1 = peg$c109;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c110);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c111();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c112) {
                    s1 = peg$c112;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c113);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c114();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c115) {
                      s1 = peg$c115;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c116);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c117();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseESCAPED_UNICODE();
                    }
                  }
                }
              }
            }
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      function peg$parseESCAPED_UNICODE() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        var key = peg$currPos * 49 + 48, cached4 = peg$cache[key];
        if (cached4) {
          peg$currPos = cached4.nextPos;
          return cached4.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c118) {
          s1 = peg$c118;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c119);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseHEX();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseHEX();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseHEX();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseHEX();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseHEX();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseHEX();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseHEX();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseHEX();
                        if (s10 !== peg$FAILED) {
                          s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                          s2 = s3;
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c120(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s3 = [s3, s4, s5, s6];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }
        peg$cache[key] = { nextPos: peg$currPos, result: s0 };
        return s0;
      }
      var nodes = [];
      function genError(err, line2, col) {
        var ex = new Error(err);
        ex.line = line2;
        ex.column = col;
        throw ex;
      }
      function addNode(node2) {
        nodes.push(node2);
      }
      function node(type, value, line2, column2, key) {
        var obj = { type, value, line: line2(), column: column2() };
        if (key)
          obj.key = key;
        return obj;
      }
      function convertCodePoint(str, line2, col) {
        var num = parseInt("0x" + str);
        if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
          genError("Invalid Unicode escape code: " + str, line2, col);
        } else {
          return fromCodePoint(num);
        }
      }
      function fromCodePoint() {
        var MAX_SIZE = 16384;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length4 = arguments.length;
        if (!length4) {
          return "";
        }
        var result = "";
        while (++index < length4) {
          var codePoint = Number(arguments[index]);
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            highSurrogate = (codePoint >> 10) + 55296;
            lowSurrogate = codePoint % 1024 + 56320;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 == length4 || codeUnits.length > MAX_SIZE) {
            result += String.fromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({ type: "end", description: "end of input" });
        }
        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
      }
    }
    return {
      SyntaxError: SyntaxError2,
      parse: parse3
    };
  }();
});

// node_modules/toml/lib/compiler.js
var require_compiler = __commonJS((exports, module) => {
  function compile(nodes) {
    var assignedPaths = [];
    var valueAssignments = [];
    var currentPath = "";
    var data = Object.create(null);
    var context9 = data;
    var arrayMode = false;
    return reduce15(nodes);
    function reduce15(nodes2) {
      var node;
      for (var i = 0;i < nodes2.length; i++) {
        node = nodes2[i];
        switch (node.type) {
          case "Assign":
            assign(node);
            break;
          case "ObjectPath":
            setPath(node);
            break;
          case "ArrayPath":
            addTableArray(node);
            break;
        }
      }
      return data;
    }
    function genError(err, line, col) {
      var ex = new Error(err);
      ex.line = line;
      ex.column = col;
      throw ex;
    }
    function assign(node) {
      var key = node.key;
      var value = node.value;
      var line = node.line;
      var column = node.column;
      var fullPath;
      if (currentPath) {
        fullPath = currentPath + "." + key;
      } else {
        fullPath = key;
      }
      if (typeof context9[key] !== "undefined") {
        genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
      }
      context9[key] = reduceValueNode(value);
      if (!pathAssigned(fullPath)) {
        assignedPaths.push(fullPath);
        valueAssignments.push(fullPath);
      }
    }
    function pathAssigned(path) {
      return assignedPaths.indexOf(path) !== -1;
    }
    function reduceValueNode(node) {
      if (node.type === "Array") {
        return reduceArrayWithTypeChecking(node.value);
      } else if (node.type === "InlineTable") {
        return reduceInlineTableNode(node.value);
      } else {
        return node.value;
      }
    }
    function reduceInlineTableNode(values3) {
      var obj = Object.create(null);
      for (var i = 0;i < values3.length; i++) {
        var val = values3[i];
        if (val.value.type === "InlineTable") {
          obj[val.key] = reduceInlineTableNode(val.value.value);
        } else if (val.type === "InlineTableValue") {
          obj[val.key] = reduceValueNode(val.value);
        }
      }
      return obj;
    }
    function setPath(node) {
      var path = node.value;
      var quotedPath = path.map(quoteDottedString).join(".");
      var line = node.line;
      var column = node.column;
      if (pathAssigned(quotedPath)) {
        genError("Cannot redefine existing key '" + path + "'.", line, column);
      }
      assignedPaths.push(quotedPath);
      context9 = deepRef(data, path, Object.create(null), line, column);
      currentPath = path;
    }
    function addTableArray(node) {
      var path = node.value;
      var quotedPath = path.map(quoteDottedString).join(".");
      var line = node.line;
      var column = node.column;
      if (!pathAssigned(quotedPath)) {
        assignedPaths.push(quotedPath);
      }
      assignedPaths = assignedPaths.filter(function(p) {
        return p.indexOf(quotedPath) !== 0;
      });
      assignedPaths.push(quotedPath);
      context9 = deepRef(data, path, [], line, column);
      currentPath = quotedPath;
      if (context9 instanceof Array) {
        var newObj = Object.create(null);
        context9.push(newObj);
        context9 = newObj;
      } else {
        genError("Cannot redefine existing key '" + path + "'.", line, column);
      }
    }
    function deepRef(start3, keys6, value, line, column) {
      var traversed = [];
      var traversedPath = "";
      var path = keys6.join(".");
      var ctx = start3;
      for (var i = 0;i < keys6.length; i++) {
        var key = keys6[i];
        traversed.push(key);
        traversedPath = traversed.join(".");
        if (typeof ctx[key] === "undefined") {
          if (i === keys6.length - 1) {
            ctx[key] = value;
          } else {
            ctx[key] = Object.create(null);
          }
        } else if (i !== keys6.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
          genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
        }
        ctx = ctx[key];
        if (ctx instanceof Array && ctx.length && i < keys6.length - 1) {
          ctx = ctx[ctx.length - 1];
        }
      }
      return ctx;
    }
    function reduceArrayWithTypeChecking(array4) {
      var firstType = null;
      for (var i = 0;i < array4.length; i++) {
        var node = array4[i];
        if (firstType === null) {
          firstType = node.type;
        } else {
          if (node.type !== firstType) {
            genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
          }
        }
      }
      return array4.map(reduceValueNode);
    }
    function quoteDottedString(str) {
      if (str.indexOf(".") > -1) {
        return '"' + str + '"';
      } else {
        return str;
      }
    }
  }
  module.exports = {
    compile
  };
});

// node_modules/toml/index.js
var require_toml = __commonJS((exports, module) => {
  var parser = require_parser();
  var compiler = require_compiler();
  module.exports = {
    parse: function(input) {
      var nodes = parser.parse(input.toString());
      return compiler.compile(nodes);
    }
  };
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity4 = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity4.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity4.isNode(ctrl) || identity4.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity4.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity4.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = visit_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity4.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity4.isNode(ctrl) || identity4.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity4.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity4.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if (identity4.isMap(node))
      return visitor.Map?.(key, node, path);
    if (identity4.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if (identity4.isPair(node))
      return visitor.Pair?.(key, node, path);
    if (identity4.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if (identity4.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return;
  }
  function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity4.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity4.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity4.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity4.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity4 = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy4 = new Directives(this.yaml, this.tags);
      copy4.docStart = this.docStart;
      return copy4;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError5) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts2 = line.trim().split(/[ \t]+/);
      const name = parts2.shift();
      switch (name) {
        case "%TAG": {
          if (parts2.length !== 2) {
            onError5(0, "%TAG directive should contain exactly two parts");
            if (parts2.length < 2)
              return false;
          }
          const [handle, prefix] = parts2;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts2.length !== 1) {
            onError5(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts2;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid2 = /^\d+\.\d+$/.test(version);
            onError5(6, `Unsupported YAML version ${version}`, isValid2);
            return false;
          }
        }
        default:
          onError5(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError5) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError5(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError5(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError5("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError5(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error3) {
          onError5(String(error3));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError5(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag2) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag2.startsWith(prefix))
          return handle + escapeTagName(tag2.substring(prefix.length));
      }
      return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity4.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node) => {
          if (identity4.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity4 = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude3) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude3.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity4.isScalar(ref.node) || identity4.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error3 = new Error("Failed to resolve repeated object (this should not happen)");
            error3.source = source;
            throw error3;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity4 = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity4.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity4 = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity4.NODE_TYPE, { value: type });
    }
    clone() {
      const copy4 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy4.range = this.range.slice();
      return copy4;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity4.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count: count5, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count5);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity4 = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity4.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit.visit(doc, {
          Node: (_key, node) => {
            if (identity4.isAlias(node) || identity4.hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = undefined;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (!data || data.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc, node, anchors2) {
    if (identity4.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity4.isCollection(node)) {
      let count5 = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count5)
          count5 = c;
      }
      return count5;
    } else if (identity4.isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors2);
      const vc = getAliasCount(doc, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity4 = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity4.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity4 = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match18 = tags.filter((t) => t.tag === tagName);
      const tagObj = match18.find((t) => !t.format) ?? match18[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity4.isDocument(value))
      value = value.contents;
    if (identity4.isNode(value))
      return value;
    if (identity4.isPair(value)) {
      const map25 = ctx.schema[identity4.MAP].createNode?.(ctx.schema, null, ctx);
      map25.items.push(value);
      return map25;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity4.MAP] : (Symbol.iterator in Object(value)) ? schema[identity4.SEQ] : schema[identity4.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity4 = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy4 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy4.schema = schema;
      copy4.items = copy4.items.map((it) => identity4.isNode(it) || identity4.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy4.range = this.range.slice();
      return copy4;
    }
    addIn(path, value) {
      if (isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (identity4.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity4.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity4.isScalar(node) ? node.value : node;
      else
        return identity4.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity4.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity4.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity4.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity4.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end6 = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end6 = lineWidth - indentAtStart;
    }
    let split4 = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i, indent.length);
      if (i !== -1)
        end6 = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i, indent.length);
        end6 = i + indent.length + endStep;
        split4 = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next4 = text[i + 1];
          if (next4 && next4 !== " " && next4 !== `
` && next4 !== "\t")
            split4 = i;
        }
        if (i >= end6) {
          if (split4) {
            folds.push(split4);
            end6 = split4 + endStep;
            split4 = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end6 = j + endStep;
            split4 = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold2 = folds[i2];
      const end7 = folds[i2 + 1] || text.length;
      if (fold2 === 0)
        res = `
${indent}${text.slice(0, end7)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold2])
          res += `${text[fold2]}\\`;
        res += `
${indent}${text.slice(fold2 + 1, end7)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i, indent) {
    let end6 = i;
    let start3 = i + 1;
    let ch = text[start3];
    while (ch === " " || ch === "\t") {
      if (i < start3 + indent) {
        ch = text[++i];
      } else {
        do {
          ch = text[++i];
        } while (ch && ch !== `
`);
        end6 = i;
        start3 = i + 1;
        ch = text[start3];
      }
    }
    return end6;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start3 = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start3 > limit)
          return true;
        start3 = i + 1;
        if (strLen - start3 <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start3 = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start3, i) + "\\ ";
        i += 1;
        start3 = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start3, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start3 = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start3, i) + `

`;
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start3 = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start3 ? str + json.slice(start3) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end6 = value.substring(endStart);
    const endNlPos = end6.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end6 || endNlPos !== end6.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end6) {
      value = value.slice(0, -end6.length);
      if (end6[end6.length - 1] === `
`)
        end6 = end6.slice(0, -1);
      end6 = end6.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start3 = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start3) {
      value = value.substring(start3.length);
      start3 = start3.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start3}${foldedValue}${end6}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start3}${value}${end6}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag2) => tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && tag2.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity4 = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match18 = tags.filter((t) => t.tag === item.tag);
      if (match18.length > 0)
        return match18.find((t) => t.format === item.format) ?? match18[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity4.isScalar(item)) {
      obj = item.value;
      let match18 = tags.filter((t) => t.identify?.(obj));
      if (match18.length > 1) {
        const testMatch = match18.filter((t) => t.test);
        if (testMatch.length > 0)
          match18 = testMatch;
      }
      tagObj = match18.find((t) => t.format === item.format) ?? match18.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity4.isScalar(node) || identity4.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag2 = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag2)
      props.push(doc.directives.tagString(tag2));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (identity4.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity4.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity4.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity4.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity4.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity4 = require_identity();
  var Scalar = require_Scalar();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity4.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity4.isCollection(key) || !identity4.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity4.isCollection(key) || (identity4.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity4.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity4.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity4.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
`)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity4.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("process");
  function debug3(logLevel, ...messages) {
    if (logLevel === "debug")
      console.log(...messages);
  }
  function warn3(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug3;
  exports.warn = warn3;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity4 = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge11 = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge11.identify(key) || identity4.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge11.identify(key.value)) && ctx?.doc.schema.tags.some((tag2) => tag2.tag === merge11.tag && tag2.default);
  function addMergeToJSMap(ctx, map25, value) {
    value = ctx && identity4.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity4.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map25, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map25, it);
    else
      mergeValue(ctx, map25, value);
  }
  function mergeValue(ctx, map25, value) {
    const source = ctx && identity4.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity4.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map25 instanceof Map) {
        if (!map25.has(key))
          map25.set(key, value2);
      } else if (map25 instanceof Set) {
        map25.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map25, key)) {
        Object.defineProperty(map25, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map25;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge11;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log5 = require_log();
  var merge11 = require_merge();
  var stringify = require_stringify();
  var identity4 = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map25, { key, value }) {
    if (identity4.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map25, value);
    else if (merge11.isMergeKey(ctx, key))
      merge11.addMergeToJSMap(ctx, map25, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map25 instanceof Map) {
        map25.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map25 instanceof Set) {
        map25.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map25)
          Object.defineProperty(map25, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map25[stringKey] = jsValue;
      }
    }
    return map25;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity4.isNode(key) && ctx?.doc) {
      const strCtx = stringify.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log5.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity4 = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity4.NODE_TYPE, { value: identity4.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity4.isNode(key))
        key = key.clone(schema);
      if (identity4.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity4 = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify2(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity4.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity4.isPair(item)) {
        const ik = identity4.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity4.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity4.isPair(item)) {
        const ik = identity4.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity4.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start: start3, end: end6 } = flowChars;
    if (lines.length === 0) {
      return start3 + end6;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum3, line) => sum3 + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start3;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        return `${str}
${indent}${end6}`;
      } else {
        return `${start3}${fcPadding}${lines.join(" ")}${fcPadding}${end6}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity4 = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity4.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity4.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity4.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity4.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map25 = new this(schema);
      const add6 = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map25.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add6(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add6(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map25.items.sort(schema.sortMapEntries);
      }
      return map25;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity4.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity4.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity4.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type3) {
      const map25 = Type3 ? new Type3 : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map25);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map25, item);
      return map25;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity4.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity4 = require_identity();
  var YAMLMap = require_YAMLMap();
  var map25 = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map26, onError5) {
      if (!identity4.isMap(map26))
        onError5("Expected a mapping for this tag");
      return map26;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map25;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity4 = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity4.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity4.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity4.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq2 = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq2);
      let i = 0;
      for (const item of this.items)
        seq2.push(toJS.toJS(item, String(i++), ctx));
      return seq2;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq2 = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq2.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq2;
    }
  }
  function asItemIndex(key) {
    let idx = identity4.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity4 = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq2 = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq3, onError5) {
      if (!identity4.isSeq(seq3))
        onError5("Expected a sequence for this tag");
      return seq3;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq2;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string4 = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string4;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format: format4, minFractionDigits, tag: tag2, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format4 && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map25 = require_map();
  var _null = require_null();
  var seq2 = require_seq();
  var string4 = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map25.map,
    seq2.seq,
    string4.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map25 = require_map();
  var seq2 = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError5) {
      onError5(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map25.map, seq2.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError5) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer4 = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer4[i] = str.charCodeAt(i);
        return buffer4;
      } else {
        onError5("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity4 = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq2, onError5) {
    if (identity4.isSeq(seq2)) {
      for (let i = 0;i < seq2.items.length; ++i) {
        let item = seq2.items[i];
        if (identity4.isPair(item))
          continue;
        else if (identity4.isMap(item)) {
          if (item.items.length > 1)
            onError5("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq2.items[i] = identity4.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError5("Expected a sequence for this tag");
    return seq2;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys6 = Object.keys(it);
          if (keys6.length === 1) {
            key = keys6[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys6.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity4 = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map25 = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map25);
      for (const pair of this.items) {
        let key, value;
        if (identity4.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map25.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map25.set(key, value);
      }
      return map25;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq2, onError5) {
      const pairs$1 = pairs.resolvePairs(seq2, onError5);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity4.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError5(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign2 = str[0];
    if (sign2 === "-" || sign2 === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign2 === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign2 === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity4 = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity4.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity4.isPair(pair) ? identity4.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set10 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set10.items.push(Pair.createPair(value, null, ctx));
        }
      return set10;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set9 = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map25, onError5) {
      if (identity4.isMap(map25)) {
        if (map25.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map25);
        else
          onError5("Set items must all have null values");
      } else
        onError5("Expected a mapping for this tag");
      return map25;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set9;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign2 = str[0];
    const parts2 = sign2 === "-" || sign2 === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts2.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign2 === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign2 = "";
    if (value < 0) {
      sign2 = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts2 = [value % _60];
    if (value < 60) {
      parts2.unshift(0);
    } else {
      value = (value - parts2[0]) / _60;
      parts2.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts2[0]) / _60;
        parts2.unshift(value);
      }
    }
    return sign2 + parts2.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match18 = str.match(timestamp.test);
      if (!match18)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match18.map(Number);
      const millisec = match18[7] ? Number((match18[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match18[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 60000 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map25 = require_map();
  var _null = require_null();
  var seq2 = require_seq();
  var string4 = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var merge11 = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set9 = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map25.map,
    seq2.seq,
    string4.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge11.merge,
    omap.omap,
    pairs.pairs,
    set9.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map25 = require_map();
  var _null = require_null();
  var seq2 = require_seq();
  var string4 = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge11 = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set9 = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map25.map, seq2.seq, string4.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map25.map,
    merge: merge11.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq2.seq,
    set: set9.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge11.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set9.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge11.merge) ? schemaTags.concat(merge11.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys6 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys6} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag2 of customTags)
        tags = tags.concat(tag2);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge11.merge);
    return tags.reduce((tags2, tag2) => {
      const tagObj = typeof tag2 === "string" ? tagsByName[tag2] : tag2;
      if (!tagObj) {
        const tagName = JSON.stringify(tag2);
        const keys6 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys6}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity4 = require_identity();
  var map25 = require_map();
  var seq2 = require_seq();
  var string4 = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge: merge11, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge11);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity4.MAP, { value: map25.map });
      Object.defineProperty(this, identity4.SCALAR, { value: string4.string });
      Object.defineProperty(this, identity4.SEQ, { value: seq2.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy4 = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy4.tags = this.tags.slice();
      return copy4;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity4 = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir3 = doc.directives.toString(doc);
      if (dir3) {
        lines.push(dir3);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity4.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity4 = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity4.NODE_TYPE, { value: identity4.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version });
      this.setSchema(version, options);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    clone() {
      const copy4 = Object.create(Document.prototype, {
        [identity4.NODE_TYPE]: { value: identity4.DOC }
      });
      copy4.commentBefore = this.commentBefore;
      copy4.comment = this.comment;
      copy4.errors = this.errors.slice();
      copy4.warnings = this.warnings.slice();
      copy4.options = Object.assign({}, this.options);
      if (this.directives)
        copy4.directives = this.directives.clone();
      copy4.schema = this.schema.clone();
      copy4.contents = identity4.isNode(this.contents) ? this.contents.clone(copy4.schema) : this.contents;
      if (this.range)
        copy4.range = this.range.slice();
      return copy4;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag2, ctx);
      if (flow && identity4.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity4.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity4.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity4.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity4.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity4.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path, value) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value);
      }
    }
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new directives.Directives({ version });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count: count5, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count5);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  function assertCollection(contents) {
    if (identity4.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError = (src, lc) => (error3) => {
    if (error3.pos[0] === -1)
      return;
    error3.linePos = error3.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error3.linePos[0];
    error3.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "…" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "…";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `…
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count5 = 1;
      const end6 = error3.linePos[1];
      if (end6 && end6.line === line && end6.col > col) {
        count5 = Math.max(1, Math.min(end6.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count5);
      error3.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next: next4, offset, onError: onError5, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag2 = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start3 = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError5(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError5(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next4?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError5(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag2)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError5(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError5(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start3 ?? (start3 = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag2)
            onError5(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag2 = token;
          start3 ?? (start3 = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag2)
            onError5(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError5(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError5(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError5(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last5 = tokens[tokens.length - 1];
    const end6 = last5 ? last5.offset + last5.source.length : offset;
    if (reqSpace && next4 && next4.type !== "space" && next4.type !== "newline" && next4.type !== "comma" && (next4.type !== "scalar" || next4.source !== "")) {
      onError5(next4.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next4?.type === "block-map" || next4?.type === "block-seq"))
      onError5(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag: tag2,
      newlineAfterProp,
      end: end6,
      start: start3 ?? end6
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent, fc, onError5) {
    if (fc?.type === "flow-collection") {
      const end6 = fc.end[0];
      if (end6.indent === indent && (end6.source === "]" || end6.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError5(end6, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity4 = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual2 = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity4.isScalar(a) && identity4.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual2(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError5, tag2) {
    const NodeClass = tag2?.nodeClass ?? YAMLMap.YAMLMap;
    const map25 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start: start3, key, sep, value } = collItem;
      const keyProps = resolveProps.resolveProps(start3, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError: onError5,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError5(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError5(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map25.comment)
              map25.comment += `
` + keyProps.comment;
            else
              map25.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError5(key ?? start3[start3.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError5(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError5) : composeEmptyNode(ctx, keyStart, start3, null, keyProps, onError5);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError5);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map25.items, keyNode))
        onError5(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError: onError5,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError5(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError5(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError5) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError5);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError5);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map25.items.push(pair);
      } else {
        if (implicitKey)
          onError5(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map25.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError5(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map25.range = [bm.offset, offset, commentEnd ?? offset];
    return map25;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError5, tag2) {
    const NodeClass = tag2?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq2 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start: start3, value } of bs.items) {
      const props = resolveProps.resolveProps(start3, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError: onError5,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value && value.type === "block-seq")
            onError5(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError5(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq2.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError5) : composeEmptyNode(ctx, props.end, start3, null, props, onError5);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError5);
      offset = node.range[2];
      seq2.items.push(node);
    }
    seq2.range = [bs.offset, offset, commentEnd ?? offset];
    return seq2;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end6, offset, reqSpace, onError5) {
    let comment = "";
    if (end6) {
      let hasSpace = false;
      let sep = "";
      for (const token of end6) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError5(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError5(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity4 = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError5, tag2) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag2?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start: start3, key, sep, value } = collItem;
      const props = resolveProps.resolveProps(start3, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError: onError5,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError5(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError5(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError5(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError5(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError5(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start3) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity4.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError5) : composeEmptyNode(ctx, props.end, sep, null, props, onError5);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError5(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError5) : composeEmptyNode(ctx, keyStart, start3, null, props, onError5);
        if (isBlock(key))
          onError5(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError: onError5,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError5(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError5(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source && value.source[0] === ":")
            onError5(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError5(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError5) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError5) : null;
        if (valueNode) {
          if (isBlock(value))
            onError5(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map25 = coll;
          if (utilMapIncludes.mapIncludes(ctx, map25.items, keyNode))
            onError5(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map25.items.push(pair);
        } else {
          const map25 = new YAMLMap.YAMLMap(ctx.schema);
          map25.flow = true;
          map25.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map25.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map25);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError5(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end6 = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError5);
      if (end6.comment) {
        if (coll.comment)
          coll.comment += `
` + end6.comment;
        else
          coll.comment = end6.comment;
      }
      coll.range = [fc.offset, cePos, end6.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity4 = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError5, tagName, tag2) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError5, tag2) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError5, tag2) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError5, tag2);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError5) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError5(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError5(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError5, tagName);
    }
    let tag2 = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag2) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag2 = kt;
      } else {
        if (kt) {
          onError5(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError5(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError5, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError5, tagName, tag2);
    const res = tag2.resolve?.(coll, (msg) => onError5(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity4.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag2?.format)
      node.format = tag2.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError5) {
    const start3 = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError5);
    if (!header)
      return { value: "", type: null, comment: "", range: [start3, start3, start3] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines4(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end7 = start3 + header.length;
      if (scalar.source)
        end7 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start3, end7, end7] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError5(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError5(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError5(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = `
`;
        else if (!prevMoreIndented && sep === `
`)
          sep = `

`;
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === `
`)
          value += `
`;
        else
          sep = `
`;
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end6 = start3 + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start3, end6, end6] };
  }
  function parseBlockScalarHeader({ offset, props }, strict2, onError5) {
    if (props[0].type !== "block-scalar-header") {
      onError5(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error3 = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error3 === -1)
          error3 = offset + i;
      }
    }
    if (error3 !== -1)
      onError5(error3, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length4 = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length4 += token.source.length;
          break;
        case "comment":
          if (strict2 && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError5(token, "MISSING_CHAR", message);
          }
          length4 += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError5(token, "UNEXPECTED_TOKEN", token.message);
          length4 += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError5(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length4 += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length: length4 };
  }
  function splitLines4(source) {
    const split4 = source.split(/\n( *)/);
    const first2 = split4[0];
    const m = first2.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
    const lines = [line0];
    for (let i = 1;i < split4.length; i += 2)
      lines.push([split4[i], split4[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict2, onError5) {
    const { offset, type, source, end: end6 } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError5(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError5(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end6, valueEnd, strict2, onError5);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError5) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError5(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError5) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError5(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first2, line;
    try {
      first2 = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy");
      line = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
    } catch {
      first2 = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match18 = first2.exec(source);
    if (!match18)
      return source;
    let res = match18[1];
    let sep = " ";
    let pos = first2.lastIndex;
    line.lastIndex = pos;
    while (match18 = line.exec(source)) {
      if (match18[1] === "") {
        if (sep === `
`)
          res += sep;
        else
          sep = `
`;
      } else {
        res += sep + match18[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last5 = /[ \t]*(.*)/sy;
    last5.lastIndex = pos;
    match18 = last5.exec(source);
    return res + sep + (match18?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError5) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold: fold2, offset } = foldNewline(source, i);
        res += fold2;
        i = offset;
      } else if (ch === "\\") {
        let next4 = source[++i];
        const cc = escapeCodes[next4];
        if (cc)
          res += cc;
        else if (next4 === `
`) {
          next4 = source[i + 1];
          while (next4 === " " || next4 === "\t")
            next4 = source[++i + 1];
        } else if (next4 === "\r" && source[i + 1] === `
`) {
          next4 = source[++i + 1];
          while (next4 === " " || next4 === "\t")
            next4 = source[++i + 1];
        } else if (next4 === "x" || next4 === "u" || next4 === "U") {
          const length4 = { x: 2, u: 4, U: 8 }[next4];
          res += parseCharCode(source, i + 1, length4, onError5);
          i += length4;
        } else {
          const raw = source.substr(i - 1, 2);
          onError5(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next4 = source[i + 1];
        while (next4 === " " || next4 === "\t")
          next4 = source[++i + 1];
        if (next4 !== `
` && !(next4 === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError5(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold2 = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold2 += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold2)
      fold2 = " ";
    return { fold: fold2, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "",
    _: " ",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length4, onError5) {
    const cc = source.substr(offset, length4);
    const ok = cc.length === length4 && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length4 + 2);
      onError5(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity4 = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError5) {
    const { value, type, comment, range: range5 } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError5) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError5);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError5(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag2;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag2 = ctx.schema[identity4.SCALAR];
    } else if (tagName)
      tag2 = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError5);
    else if (token.type === "scalar")
      tag2 = findScalarTagByTest(ctx, value, token, onError5);
    else
      tag2 = ctx.schema[identity4.SCALAR];
    let scalar;
    try {
      const res = tag2.resolve(value, (msg) => onError5(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity4.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error3) {
      const msg = error3 instanceof Error ? error3.message : String(error3);
      onError5(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range5;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag2.format)
      scalar.format = tag2.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError5) {
    if (tagName === "!")
      return schema[identity4.SCALAR];
    const matchWithTest = [];
    for (const tag2 of schema.tags) {
      if (!tag2.collection && tag2.tag === tagName) {
        if (tag2.default && tag2.test)
          matchWithTest.push(tag2);
        else
          return tag2;
      }
    }
    for (const tag2 of matchWithTest)
      if (tag2.test?.test(value))
        return tag2;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError5(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity4.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError5) {
    const tag2 = schema.tags.find((tag3) => (tag3.default === true || atKey && tag3.default === "key") && tag3.test?.test(value)) || schema[identity4.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag3) => tag3.default && tag3.test?.test(value)) ?? schema[identity4.SCALAR];
      if (tag2.tag !== compat.tag) {
        const ts = directives.tagString(tag2.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError5(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag2;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before2, pos) {
    if (before2) {
      pos ?? (pos = before2.length);
      for (let i = pos - 1;i >= 0; --i) {
        let st = before2[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before2[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before2[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity4 = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError5) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag: tag2 } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError5);
        if (anchor || tag2)
          onError5(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag2, onError5);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError5);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError5(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError5);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError5(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity4.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError5(tag2 ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before2, pos, { spaceBefore, comment, anchor, tag: tag2, end: end6 }, onError5) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before2, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag2, onError5);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError5(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end6;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end: end6 }, onError5) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError5(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError5(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end6, valueEnd, options.strict, onError5);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options, directives, { offset, start: start3, value, end: end6 }, onError5) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start3, {
      indicator: "doc-start",
      next: value ?? end6?.[0],
      offset,
      onError: onError5,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError5(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError5) : composeNode.composeEmptyNode(ctx, props.end, start3, null, props, onError5);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end6, contentEnd, false, onError5);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("process");
  var directives = require_directives();
  var Document = require_Document();
  var errors = require_errors();
  var identity4 = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity4.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity4.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error3 = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error3);
          else
            this.doc.errors.push(error3);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end6 = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end6.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end6.comment}` : end6.comment;
          }
          this.doc.range[2] = end6.offset;
          break;
        }
        default:
          this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors = require_errors();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict2 = true, onError5) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError5)
          onError5(offset, code, message);
        else
          throw new errors.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict2, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict: strict2 } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context9) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context9;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end6 = context9.end ?? [
      { type: "newline", offset: -1, indent, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head6 = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head6 }
        ];
        if (!addEndtoBlockProps(props, end6))
          props.push({ type: "newline", offset: -1, indent, source: `
` });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end: end6 };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end: end6 };
      default:
        return { type: "scalar", offset, indent, source, end: end6 };
    }
  }
  function setScalarValue(token, value, context9 = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context9;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head6 = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head6;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head6 }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end6) {
    if (end6)
      for (const st of end6)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end6 = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end6)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end: end6 });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end6 = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end: end6 });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start: start3, key, sep, value }) {
    let res = "";
    for (const st of start3)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty15(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r	`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next4 = this.next ?? "stream";
      while (next4 && (incomplete || this.hasChars(1)))
        next4 = yield* this.parseNext(next4);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next4 = this.buffer[indent + offset + 1];
          if (next4 === `
` || !next4 && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty15(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end6 = this.lineEndPos;
      if (typeof end6 !== "number" || end6 !== -1 && end6 < this.pos) {
        end6 = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end6;
      }
      if (end6 === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end6 - 1] === "\r")
        end6 -= 1;
      return this.buffer.substring(this.pos, end6);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next4) {
      switch (next4) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty15(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty15(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty15(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty15(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next4 = this.charAt(1);
          if (this.flowKey || isEmpty15(next4) || next4 === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end6 = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end6 !== -1 && this.buffer[end6 + 1] === "'")
          end6 = this.buffer.indexOf("'", end6 + 2);
      } else {
        while (end6 !== -1) {
          let n = 0;
          while (this.buffer[end6 - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end6 = this.buffer.indexOf('"', end6 + 1);
        }
      }
      const qb = this.buffer.substring(0, end6);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end6 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end6 === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end6 = this.buffer.length;
      }
      yield* this.pushToIndex(end6 + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty15(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case `
`:
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next4 = this.buffer[i2 + 1];
              if (!next4 && !this.atEnd)
                return this.setNext("block-scalar");
              if (next4 === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end6 = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next4 = this.buffer[i + 1];
          if (isEmpty15(next4) || inFlow && flowIndicatorChars.has(next4))
            break;
          end6 = i;
        } else if (isEmpty15(ch)) {
          let next4 = this.buffer[i + 1];
          if (ch === "\r") {
            if (next4 === `
`) {
              i += 1;
              ch = `
`;
              next4 = this.buffer[i + 1];
            } else
              end6 = i;
          }
          if (next4 === "#" || inFlow && flowIndicatorChars.has(next4))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end6 = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end6 + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty15(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty15(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start3 = this.lineStarts[low - 1];
        return { line: low, col: offset - start3 + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser2 = __commonJS((exports) => {
  var node_process = __require("process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {}
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error3) {
      const token = error3 ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last5 = token.items[token.items.length - 1];
          if (last5 && !last5.sep && !last5.value && last5.start.length > 0 && findNonEmptyIndex(last5.start) === -1 && (token.indent === 0 || last5.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last5.start;
            else
              top.items.push({ start: last5.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start3 = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map25 = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start: start3, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map25;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map25) {
      const it = map25.items[map25.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end6 = "end" in it.value ? it.value.end : undefined;
            const last5 = Array.isArray(end6) ? end6[end6.length - 1] : undefined;
            if (last5?.type === "comment")
              end6?.push(this.sourceToken);
            else
              map25.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map25.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map25.indent)) {
              const prev = map25.items[map25.items.length - 2];
              const end6 = prev?.value?.end;
              if (Array.isArray(end6)) {
                Array.prototype.push.apply(end6, it.start);
                end6.push(this.sourceToken);
                map25.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map25.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map25.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start3 = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map25.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start3 = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start3.push(this.sourceToken);
              map25.items.push({ start: start3 });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start3.push(this.sourceToken);
              map25.items.push({ start: start3, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start4 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start4, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map25.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start3, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start4 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start4, key, sep }]
                });
              } else if (start3.length > 0) {
                it.sep = it.sep.concat(start3, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map25.items.push({ start: start3, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map25.items.push({ start: start3, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map25);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map25.items.push({ start: start3 });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq2) {
      const it = seq2.items[seq2.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end6 = "end" in it.value ? it.value.end : undefined;
            const last5 = Array.isArray(end6) ? end6[end6.length - 1] : undefined;
            if (last5?.type === "comment")
              end6?.push(this.sourceToken);
            else
              seq2.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq2.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq2.indent)) {
              const prev = seq2.items[seq2.items.length - 2];
              const end6 = prev?.value?.end;
              if (Array.isArray(end6)) {
                Array.prototype.push.apply(end6, it.start);
                end6.push(this.sourceToken);
                seq2.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq2.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq2.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq2.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq2.indent) {
        const bv = this.startBlockValue(seq2);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top && top.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start3 = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map25 = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start: start3, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map25;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start3 = getFirstKeyStartProps(prev);
          start3.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: start3, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start3 = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: start3, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start3, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start3.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors = require_errors();
  var log5 = require_log();
  var identity4 = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser2();
  function parseOptions(options) {
    const prettyErrors2 = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors2 && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors: prettyErrors2 };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors: prettyErrors2 } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors2 && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors: prettyErrors2 } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors2 && lineCounter2) {
      doc.errors.forEach(errors.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
    }
    return doc;
  }
  function parse3(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log5.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity4.isDocument(value) && !_replacer)
      return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
  }
  exports.parse = parse3;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify;
});

// node_modules/node-gyp-build-optional-packages/node_modules/detect-libc/lib/process.js
var require_process = __commonJS((exports, module) => {
  var isLinux = () => process.platform === "linux";
  var report = null;
  var getReport = () => {
    if (!report) {
      if (isLinux() && process.report) {
        const orig = process.report.excludeNetwork;
        process.report.excludeNetwork = true;
        report = process.report.getReport();
        process.report.excludeNetwork = orig;
      } else {
        report = {};
      }
    }
    return report;
  };
  module.exports = { isLinux, getReport };
});

// node_modules/node-gyp-build-optional-packages/node_modules/detect-libc/lib/filesystem.js
var require_filesystem = __commonJS((exports, module) => {
  var fs = __require("fs");
  var LDD_PATH = "/usr/bin/ldd";
  var readFileSync = (path4) => fs.readFileSync(path4, "utf-8");
  var readFile = (path4) => new Promise((resolve3, reject) => {
    fs.readFile(path4, "utf-8", (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve3(data);
      }
    });
  });
  module.exports = {
    LDD_PATH,
    readFileSync,
    readFile
  };
});

// node_modules/node-gyp-build-optional-packages/node_modules/detect-libc/lib/detect-libc.js
var require_detect_libc = __commonJS((exports, module) => {
  var childProcess = __require("child_process");
  var { isLinux, getReport } = require_process();
  var { LDD_PATH, readFile, readFileSync } = require_filesystem();
  var cachedFamilyFilesystem;
  var cachedVersionFilesystem;
  var command = "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";
  var commandOut = "";
  var safeCommand = () => {
    if (!commandOut) {
      return new Promise((resolve3) => {
        childProcess.exec(command, (err, out) => {
          commandOut = err ? " " : out;
          resolve3(commandOut);
        });
      });
    }
    return commandOut;
  };
  var safeCommandSync = () => {
    if (!commandOut) {
      try {
        commandOut = childProcess.execSync(command, { encoding: "utf8" });
      } catch (_err) {
        commandOut = " ";
      }
    }
    return commandOut;
  };
  var GLIBC = "glibc";
  var RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
  var MUSL = "musl";
  var isFileMusl = (f) => f.includes("libc.musl-") || f.includes("ld-musl-");
  var familyFromReport = () => {
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
      return GLIBC;
    }
    if (Array.isArray(report.sharedObjects)) {
      if (report.sharedObjects.some(isFileMusl)) {
        return MUSL;
      }
    }
    return null;
  };
  var familyFromCommand = (out) => {
    const [getconf, ldd1] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
      return GLIBC;
    }
    if (ldd1 && ldd1.includes(MUSL)) {
      return MUSL;
    }
    return null;
  };
  var getFamilyFromLddContent = (content) => {
    if (content.includes("musl")) {
      return MUSL;
    }
    if (content.includes("GNU C Library")) {
      return GLIBC;
    }
    return null;
  };
  var familyFromFilesystem = async () => {
    if (cachedFamilyFilesystem !== undefined) {
      return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
      const lddContent = await readFile(LDD_PATH);
      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
  };
  var familyFromFilesystemSync = () => {
    if (cachedFamilyFilesystem !== undefined) {
      return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
      const lddContent = readFileSync(LDD_PATH);
      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
  };
  var family = async () => {
    let family2 = null;
    if (isLinux()) {
      family2 = await familyFromFilesystem();
      if (!family2) {
        family2 = familyFromReport();
      }
      if (!family2) {
        const out = await safeCommand();
        family2 = familyFromCommand(out);
      }
    }
    return family2;
  };
  var familySync = () => {
    let family2 = null;
    if (isLinux()) {
      family2 = familyFromFilesystemSync();
      if (!family2) {
        family2 = familyFromReport();
      }
      if (!family2) {
        const out = safeCommandSync();
        family2 = familyFromCommand(out);
      }
    }
    return family2;
  };
  var isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;
  var isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;
  var versionFromFilesystem = async () => {
    if (cachedVersionFilesystem !== undefined) {
      return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
      const lddContent = await readFile(LDD_PATH);
      const versionMatch = lddContent.match(RE_GLIBC_VERSION);
      if (versionMatch) {
        cachedVersionFilesystem = versionMatch[1];
      }
    } catch (e) {}
    return cachedVersionFilesystem;
  };
  var versionFromFilesystemSync = () => {
    if (cachedVersionFilesystem !== undefined) {
      return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
      const lddContent = readFileSync(LDD_PATH);
      const versionMatch = lddContent.match(RE_GLIBC_VERSION);
      if (versionMatch) {
        cachedVersionFilesystem = versionMatch[1];
      }
    } catch (e) {}
    return cachedVersionFilesystem;
  };
  var versionFromReport = () => {
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
      return report.header.glibcVersionRuntime;
    }
    return null;
  };
  var versionSuffix = (s) => s.trim().split(/\s+/)[1];
  var versionFromCommand = (out) => {
    const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
      return versionSuffix(getconf);
    }
    if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
      return versionSuffix(ldd2);
    }
    return null;
  };
  var version = async () => {
    let version2 = null;
    if (isLinux()) {
      version2 = await versionFromFilesystem();
      if (!version2) {
        version2 = versionFromReport();
      }
      if (!version2) {
        const out = await safeCommand();
        version2 = versionFromCommand(out);
      }
    }
    return version2;
  };
  var versionSync = () => {
    let version2 = null;
    if (isLinux()) {
      version2 = versionFromFilesystemSync();
      if (!version2) {
        version2 = versionFromReport();
      }
      if (!version2) {
        const out = safeCommandSync();
        version2 = versionFromCommand(out);
      }
    }
    return version2;
  };
  module.exports = {
    GLIBC,
    MUSL,
    family,
    familySync,
    isNonGlibcLinux,
    isNonGlibcLinuxSync,
    version,
    versionSync
  };
});

// node_modules/node-gyp-build-optional-packages/node-gyp-build.js
var require_node_gyp_build = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path4 = __require("path");
  var url2 = __require("url");
  var os = __require("os");
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var versions = process.versions;
  var abi = versions.modules;
  if (versions.deno || process.isBun) {
    abi = "unsupported";
  }
  var runtime6 = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os.arch();
  var platform = process.env.npm_config_platform || os.platform();
  var libc = process.env.LIBC || (isMusl(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (versions.uv || "").split(".")[0];
  module.exports = load;
  function load(dir3) {
    return runtimeRequire(load.resolve(dir3));
  }
  load.resolve = load.path = function(dir3) {
    dir3 = path4.resolve(dir3 || ".");
    var packageName = "";
    var packageNameError;
    try {
      packageName = runtimeRequire(path4.join(dir3, "package.json")).name;
      var varName = packageName.toUpperCase().replace(/-/g, "_");
      if (process.env[varName + "_PREBUILD"])
        dir3 = process.env[varName + "_PREBUILD"];
    } catch (err) {
      packageNameError = err;
    }
    if (!prebuildsOnly) {
      var release = getFirst(path4.join(dir3, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug3 = getFirst(path4.join(dir3, "build/Debug"), matchBuild);
      if (debug3)
        return debug3;
    }
    var prebuild = resolve3(dir3);
    if (prebuild)
      return prebuild;
    var nearby = resolve3(path4.dirname(process.execPath));
    if (nearby)
      return nearby;
    var platformPackage = (packageName[0] == "@" ? "" : "@" + packageName + "/") + packageName + "-" + platform + "-" + arch;
    var packageResolutionError;
    try {
      var prebuildPackage = path4.dirname(__require("module").createRequire(url2.pathToFileURL(path4.join(dir3, "package.json"))).resolve(platformPackage));
      return resolveFile(prebuildPackage);
    } catch (error5) {
      packageResolutionError = error5;
    }
    var target2 = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime6,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
    ].filter(Boolean).join(" ");
    let errMessage = "No native build was found for " + target2 + `
    attempted loading from: ` + dir3 + " and package:" + " " + platformPackage + `
`;
    if (packageNameError) {
      errMessage += "Error finding package.json: " + packageNameError.message + `
`;
    }
    if (packageResolutionError) {
      errMessage += "Error resolving package: " + packageResolutionError.message + `
`;
    }
    throw new Error(errMessage);
    function resolve3(dir4) {
      var tuples = readdirSync(path4.join(dir4, "prebuilds")).map(parseTuple);
      var tuple6 = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple6)
        return;
      return resolveFile(path4.join(dir4, "prebuilds", tuple6.name));
    }
    function resolveFile(prebuilds) {
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime6, abi));
      var winner = candidates.sort(compareTags(runtime6))[0];
      if (winner)
        return path4.join(prebuilds, winner.file);
    }
  };
  function readdirSync(dir3) {
    try {
      return fs.readdirSync(dir3);
    } catch (err) {
      return [];
    }
  }
  function getFirst(dir3, filter12) {
    var files = readdirSync(dir3).filter(filter12);
    return files[0] && path4.join(dir3, files[0]);
  }
  function matchBuild(name) {
    return /\.node$/.test(name);
  }
  function parseTuple(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform2, architectures };
  }
  function matchTuple(platform2, arch2) {
    return function(tuple6) {
      if (tuple6 == null)
        return false;
      if (tuple6.platform !== platform2)
        return false;
      return tuple6.architectures.includes(arch2);
    };
  }
  function compareTuples(a, b) {
    return a.architectures.length - b.architectures.length;
  }
  function parseTags(file8) {
    var arr = file8.split(".");
    var extension = arr.pop();
    var tags2 = { file: file8, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i = 0;i < arr.length; i++) {
      var tag7 = arr[i];
      if (tag7 === "node" || tag7 === "electron" || tag7 === "node-webkit") {
        tags2.runtime = tag7;
      } else if (tag7 === "napi") {
        tags2.napi = true;
      } else if (tag7.slice(0, 3) === "abi") {
        tags2.abi = tag7.slice(3);
      } else if (tag7.slice(0, 2) === "uv") {
        tags2.uv = tag7.slice(2);
      } else if (tag7.slice(0, 4) === "armv") {
        tags2.armv = tag7.slice(4);
      } else if (tag7 === "glibc" || tag7 === "musl") {
        tags2.libc = tag7;
      } else {
        continue;
      }
      tags2.specificity++;
    }
    return tags2;
  }
  function matchTags(runtime7, abi2) {
    return function(tags2) {
      if (tags2 == null)
        return false;
      if (tags2.runtime !== runtime7 && !runtimeAgnostic(tags2))
        return false;
      if (tags2.abi !== abi2 && !tags2.napi)
        return false;
      if (tags2.uv && tags2.uv !== uv)
        return false;
      if (tags2.armv && tags2.armv !== armv)
        return false;
      if (tags2.libc && tags2.libc !== libc)
        return false;
      return true;
    };
  }
  function runtimeAgnostic(tags2) {
    return tags2.runtime === "node" && tags2.napi;
  }
  function compareTags(runtime7) {
    return function(a, b) {
      if (a.runtime !== b.runtime) {
        return a.runtime === runtime7 ? -1 : 1;
      } else if (a.abi !== b.abi) {
        return a.abi ? -1 : 1;
      } else if (a.specificity !== b.specificity) {
        return a.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  }
  function isNwjs() {
    return !!(process.versions && process.versions.nw);
  }
  function isElectron() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  }
  function isMusl(platform2) {
    if (platform2 !== "linux")
      return false;
    const { familySync, MUSL } = require_detect_libc();
    return familySync() === MUSL;
  }
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
});

// node_modules/node-gyp-build-optional-packages/index.js
var require_node_gyp_build_optional_packages = __commonJS((exports, module) => {
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
  if (typeof runtimeRequire.addon === "function") {
    module.exports = runtimeRequire.addon.bind(runtimeRequire);
  } else {
    module.exports = require_node_gyp_build();
  }
});

// node_modules/msgpackr-extract/index.js
var require_msgpackr_extract = __commonJS((exports, module) => {
  var __dirname = "/Users/rg/Projects/weerun/node_modules/msgpackr-extract";
  module.exports = require_node_gyp_build_optional_packages()(__dirname);
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  var hasBlob = typeof Blob !== "undefined";
  if (hasBlob)
    BINARY_TYPES.push("blob");
  module.exports = {
    BINARY_TYPES,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {}
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  function concat8(list4, totalLength) {
    if (list4.length === 0)
      return EMPTY_BUFFER;
    if (list4.length === 1)
      return list4[0];
    const target2 = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list4.length; i++) {
      const buf = list4[i];
      target2.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target2.buffer, target2.byteOffset, offset);
    }
    return target2;
  }
  function _mask(source, mask, output, offset, length4) {
    for (let i = 0;i < length4; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer4, mask) {
    for (let i = 0;i < buffer4.length; i++) {
      buffer4[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat: concat8,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error("Cannot require module "+"bufferutil");})();
      module.exports.mask = function(source, mask, output, offset, length4) {
        if (length4 < 48)
          _mask(source, mask, output, offset, length4);
        else
          bufferUtil.mask(source, mask, output, offset, length4);
      };
      module.exports.unmask = function(buffer4, mask) {
        if (buffer4.length < 32)
          _unmask(buffer4, mask);
        else
          bufferUtil.unmask(buffer4, mask);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options6, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options6 || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params2 = {};
      if (this._options.serverNoContextTakeover) {
        params2.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params2.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params2.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params2.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params2.client_max_window_bits = true;
      }
      return params2;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params2) => {
        if (opts.serverNoContextTakeover === false && params2.server_no_context_takeover || params2.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params2.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params2.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params2 = response[0];
      if (this._options.clientNoContextTakeover === false && params2.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params2.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params2.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params2.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params2;
    }
    normalizeParams(configurations) {
      configurations.forEach((params2) => {
        Object.keys(params2).forEach((key) => {
          let value8 = params2[key];
          if (value8.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value8 = value8[0];
          if (key === "client_max_window_bits") {
            if (value8 !== true) {
              const num = +value8;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value8}`);
              }
              value8 = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value8}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value8;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value8}`);
            }
            value8 = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value8 !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value8}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params2[key] = value8;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done11) => {
        this._decompress(data, fin, (err, result) => {
          done11();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done11) => {
        this._compress(data, fin, (err, result) => {
          done11();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk4) {
    this[kBuffers].push(chunk4);
    this[kTotalLength] += chunk4.length;
  }
  function inflateOnData(chunk4) {
    this[kTotalLength] += chunk4.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk4);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var { isUtf8 } = __require("buffer");
  var { hasBlob } = require_constants();
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code3) {
    return code3 >= 1000 && code3 <= 1014 && code3 !== 1004 && code3 !== 1005 && code3 !== 1006 || code3 >= 3000 && code3 <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value8) {
    return hasBlob && typeof value8 === "object" && typeof value8.arrayBuffer === "function" && typeof value8.type === "string" && typeof value8.stream === "function" && (value8[Symbol.toStringTag] === "Blob" || value8[Symbol.toStringTag] === "File");
  }
  module.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error("Cannot require module "+"utf-8-validate");})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat: concat8, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options6 = {}) {
      super();
      this._allowSynchronousEvents = options6.allowSynchronousEvents !== undefined ? options6.allowSynchronousEvents : true;
      this._binaryType = options6.binaryType || BINARY_TYPES[0];
      this._extensions = options6.extensions || {};
      this._isServer = !!options6.isServer;
      this._maxPayload = options6.maxPayload | 0;
      this._skipUTF8Validation = !!options6.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk4, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk4.length;
      this._buffers.push(chunk4);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error5 = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error5);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error5 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error5);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error5 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error5);
          return;
        }
        if (!this._fragmented) {
          const error5 = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error5);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error5 = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error5);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error5 = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error5);
          return;
        }
        if (compressed) {
          const error5 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error5);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error5 = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error5);
          return;
        }
      } else {
        const error5 = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error5);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error5 = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error5);
          return;
        }
      } else if (this._masked) {
        const error5 = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error5);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error5 = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error5);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error5 = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error5);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error5 = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error5);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat8(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat8(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data = new Blob(fragments);
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat8(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error5 = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error5);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code3 = data.readUInt16BE(0);
          if (!isValidStatusCode(code3)) {
            const error5 = this.createError(RangeError, `invalid status code ${code3}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error5);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error5 = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error5);
            return;
          }
          this._loop = false;
          this.emit("conclude", code3, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
  var { isBlob, isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;
  var DEFAULT = 0;
  var DEFLATING = 1;
  var GET_BLOB_DATA = 2;

  class Sender {
    constructor(socket, extensions2, generateMask) {
      this._extensions = extensions2 || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = undefined;
    }
    static frame(data, options6) {
      let mask;
      let merge14 = false;
      let offset = 2;
      let skipMasking = false;
      if (options6.mask) {
        mask = options6.maskBuffer || maskBuffer;
        if (options6.generateMask) {
          options6.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options6.mask || skipMasking) && options6[kByteLength] !== undefined) {
          dataLength = options6[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge14 = options6.mask && options6.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target2 = Buffer.allocUnsafe(merge14 ? dataLength + offset : offset);
      target2[0] = options6.fin ? options6.opcode | 128 : options6.opcode;
      if (options6.rsv1)
        target2[0] |= 64;
      target2[1] = payloadLength;
      if (payloadLength === 126) {
        target2.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target2[2] = target2[3] = 0;
        target2.writeUIntBE(dataLength, 4, 6);
      }
      if (!options6.mask)
        return [target2, data];
      target2[1] |= 128;
      target2[offset - 4] = mask[0];
      target2[offset - 3] = mask[1];
      target2[offset - 2] = mask[2];
      target2[offset - 1] = mask[3];
      if (skipMasking)
        return [target2, data];
      if (merge14) {
        applyMask(data, mask, target2, offset, dataLength);
        return [target2];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target2, data];
    }
    close(code3, data, mask, cb) {
      let buf;
      if (code3 === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code3 !== "number" || !isValidStatusCode(code3)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code3, 0);
      } else {
        const length4 = Buffer.byteLength(data);
        if (length4 > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length4);
        buf.writeUInt16BE(code3, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options6 = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options6, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options6), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options6 = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options6, cb]);
        } else {
          this.getBlobData(data, false, options6, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options6, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options6), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options6 = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options6, cb]);
        } else {
          this.getBlobData(data, false, options6, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options6, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options6), cb);
      }
    }
    send(data, options6, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options6.binary ? 2 : 1;
      let rsv1 = options6.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options6.fin)
        this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options6.fin,
        generateMask: this._generateMask,
        mask: options6.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
        } else {
          this.getBlobData(data, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    }
    getBlobData(blob, compress, options6, cb) {
      this._bufferedBytes += options6[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while the blob was being read");
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }
        this._bufferedBytes -= options6[kByteLength];
        const data = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options6), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options6, cb);
        }
      }).catch((err) => {
        process.nextTick(onError5, this, err, cb);
      });
    }
    dispatch(data, compress, options6, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options6), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options6[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data, options6.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          callCallbacks(this, err, cb);
          return;
        }
        this._bufferedBytes -= options6[kByteLength];
        this._state = DEFAULT;
        options6.readOnly = false;
        this.sendFrame(Sender.frame(buf, options6), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params2 = this._queue.shift();
        this._bufferedBytes -= params2[3][kByteLength];
        Reflect.apply(params2[0], this, params2.slice(1));
      }
    }
    enqueue(params2) {
      this._bufferedBytes += params2[3][kByteLength];
      this._queue.push(params2);
    }
    sendFrame(list4, cb) {
      if (list4.length === 2) {
        this._socket.cork();
        this._socket.write(list4[0]);
        this._socket.write(list4[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list4[0], cb);
      }
    }
  }
  module.exports = Sender;
  function callCallbacks(sender, err, cb) {
    if (typeof cb === "function")
      cb(err);
    for (let i = 0;i < sender._queue.length; i++) {
      const params2 = sender._queue[i];
      const callback = params2[params2.length - 1];
      if (typeof callback === "function")
        callback(err);
    }
  }
  function onError5(sender, err, cb) {
    callCallbacks(sender, err, cb);
    sender.onerror(err);
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type2) {
      this[kTarget] = null;
      this[kType] = type2;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type2, options6 = {}) {
      super(type2);
      this[kCode] = options6.code === undefined ? 0 : options6.code;
      this[kReason] = options6.reason === undefined ? "" : options6.reason;
      this[kWasClean] = options6.wasClean === undefined ? false : options6.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type2, options6 = {}) {
      super(type2);
      this[kError] = options6.error === undefined ? null : options6.error;
      this[kMessage] = options6.message === undefined ? "" : options6.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type2, options6 = {}) {
      super(type2);
      this[kData] = options6.data === undefined ? null : options6.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type2, handler, options6 = {}) {
      for (const listener of this.listeners(type2)) {
        if (!options6[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type2 === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type2 === "close") {
        wrapper = function onClose(code3, message) {
          const event = new CloseEvent("close", {
            code: code3,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type2 === "error") {
        wrapper = function onError(error5) {
          const event = new ErrorEvent("error", {
            error: error5,
            message: error5.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type2 === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options6[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options6.once) {
        this.once(type2, wrapper);
      } else {
        this.on(type2, wrapper);
      }
    },
    removeEventListener(type2, handler) {
      for (const listener of this.listeners(type2)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type2, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse10(header) {
    const offers = Object.create(null);
    let params2 = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start5 = -1;
    let code3 = -1;
    let end6 = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code3 = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end6 === -1 && tokenChars[code3] === 1) {
          if (start5 === -1)
            start5 = i;
        } else if (i !== 0 && (code3 === 32 || code3 === 9)) {
          if (end6 === -1 && start5 !== -1)
            end6 = i;
        } else if (code3 === 59 || code3 === 44) {
          if (start5 === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end6 === -1)
            end6 = i;
          const name = header.slice(start5, end6);
          if (code3 === 44) {
            push(offers, name, params2);
            params2 = Object.create(null);
          } else {
            extensionName = name;
          }
          start5 = end6 = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end6 === -1 && tokenChars[code3] === 1) {
          if (start5 === -1)
            start5 = i;
        } else if (code3 === 32 || code3 === 9) {
          if (end6 === -1 && start5 !== -1)
            end6 = i;
        } else if (code3 === 59 || code3 === 44) {
          if (start5 === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end6 === -1)
            end6 = i;
          push(params2, header.slice(start5, end6), true);
          if (code3 === 44) {
            push(offers, extensionName, params2);
            params2 = Object.create(null);
            extensionName = undefined;
          }
          start5 = end6 = -1;
        } else if (code3 === 61 && start5 !== -1 && end6 === -1) {
          paramName = header.slice(start5, i);
          start5 = end6 = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code3] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start5 === -1)
            start5 = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code3] === 1) {
            if (start5 === -1)
              start5 = i;
          } else if (code3 === 34 && start5 !== -1) {
            inQuotes = false;
            end6 = i;
          } else if (code3 === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code3 === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end6 === -1 && tokenChars[code3] === 1) {
          if (start5 === -1)
            start5 = i;
        } else if (start5 !== -1 && (code3 === 32 || code3 === 9)) {
          if (end6 === -1)
            end6 = i;
        } else if (code3 === 59 || code3 === 44) {
          if (start5 === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end6 === -1)
            end6 = i;
          let value8 = header.slice(start5, end6);
          if (mustUnescape) {
            value8 = value8.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params2, paramName, value8);
          if (code3 === 44) {
            push(offers, extensionName, params2);
            params2 = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start5 = end6 = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start5 === -1 || inQuotes || code3 === 32 || code3 === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end6 === -1)
      end6 = i;
    const token = header.slice(start5, end6);
    if (extensionName === undefined) {
      push(offers, token, params2);
    } else {
      if (paramName === undefined) {
        push(params2, token, true);
      } else if (mustUnescape) {
        push(params2, paramName, token.replace(/\\/g, ""));
      } else {
        push(params2, paramName, token);
      }
      push(offers, extensionName, params2);
    }
    return offers;
  }
  function format8(extensions2) {
    return Object.keys(extensions2).map((extension) => {
      let configurations = extensions2[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params2) => {
        return [extension].concat(Object.keys(params2).map((k) => {
          let values4 = params2[k];
          if (!Array.isArray(values4))
            values4 = [values4];
          return values4.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format: format8, parse: parse10 };
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes: randomBytes2, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var { isBlob } = require_validation();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format: format8, parse: parse10 } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address, protocols, options6) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options6 = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options6);
      } else {
        this._autoPong = options6.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type2) {
      if (!BINARY_TYPES.includes(type2))
        return;
      this._binaryType = type2;
      if (this._receiver)
        this._receiver._binaryType = type2;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head10, options6) {
      const receiver = new Receiver({
        allowSynchronousEvents: options6.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options6.maxPayload,
        skipUTF8Validation: options6.skipUTF8Validation
      });
      const sender = new Sender(socket, this._extensions, options6.generateMask);
      this._receiver = receiver;
      this._sender = sender;
      this._socket = socket;
      receiver[kWebSocket] = this;
      sender[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      sender.onerror = senderOnError;
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head10.length > 0)
        socket.unshift(head10);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code3, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code3, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options6, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options6 === "function") {
        cb = options6;
        options6 = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options6
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
  function initAsClient(websocket, address, protocols, options6) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options6,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", ` + '"http:", "https:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes2(16).toString("base64");
    const request2 = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format8({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts2 = opts.path.split(":");
      opts.socketPath = parts2[0];
      opts.path = parts2[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options6 && options6.headers;
        options6 = { ...options6, headers: {} };
        if (headers) {
          for (const [key2, value8] of Object.entries(headers)) {
            options6.headers[key2.toLowerCase()] = value8;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options6.headers.authorization) {
        options6.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request2(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request2(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location2 = res.headers.location;
      const statusCode = res.statusCode;
      if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location2, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location2}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options6);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head10) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      const upgrade2 = res.headers.upgrade;
      if (upgrade2 === undefined || upgrade2.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions2;
        try {
          extensions2 = parse10(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions2);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions2[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head10, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket._errorEmitted = true;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options6) {
    options6.path = options6.socketPath;
    return net.connect(options6);
  }
  function tlsConnect(options6) {
    options6.path = undefined;
    if (!options6.servername && options6.servername !== "") {
      options6.servername = net.isIP(options6.host) ? "" : options6.host;
    }
    return tls.connect(options6);
  }
  function abortHandshake(websocket, stream9, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream9.setHeader) {
      stream9[kAborted] = true;
      stream9.abort();
      if (stream9.socket && !stream9.socket.destroyed) {
        stream9.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream9.destroy(err);
      stream9.once("error", websocket.emit.bind(websocket, "error"));
      stream9.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length4 = isBlob(data) ? data.size : toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length4;
      else
        websocket._bufferedAmount += length4;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code3, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code3;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume2, websocket._socket);
    if (code3 === 1005)
      websocket.close();
    else
      websocket.close(code3, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume2, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume2(stream9) {
    stream9.resume();
  }
  function senderOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket.readyState === WebSocket.CLOSED)
      return;
    if (websocket.readyState === WebSocket.OPEN) {
      websocket._readyState = WebSocket.CLOSING;
      setCloseTimer(websocket);
    }
    this._socket.end();
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function setCloseTimer(websocket) {
    websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk4;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk4 = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk4);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk4) {
    if (!this[kWebSocket]._receiver.write(chunk4)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var WebSocket = require_websocket();
  var { Duplex } = __require("stream");
  function emitClose(stream9) {
    stream9.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options6) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options6,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk4, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk4, encoding, callback);
        });
        return;
      }
      ws.send(chunk4, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function parse10(header) {
    const protocols = new Set;
    let start5 = -1;
    let end6 = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code3 = header.charCodeAt(i);
      if (end6 === -1 && tokenChars[code3] === 1) {
        if (start5 === -1)
          start5 = i;
      } else if (i !== 0 && (code3 === 32 || code3 === 9)) {
        if (end6 === -1 && start5 !== -1)
          end6 = i;
      } else if (code3 === 44) {
        if (start5 === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end6 === -1)
          end6 = i;
        const protocol2 = header.slice(start5, end6);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start5 = end6 = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start5 === -1 || end6 !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start5, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse: parse10 };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket();
  var { GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options6, callback) {
      super();
      options6 = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options6
      };
      if (options6.port == null && !options6.server && !options6.noServer || options6.port != null && (options6.server || options6.noServer) || options6.server && options6.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options6.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options6.port, options6.host, options6.backlog, callback);
      } else if (options6.server) {
        this._server = options6.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head10) => {
            this.handleUpgrade(req, socket, head10, emitConnection);
          }
        });
      }
      if (options6.perMessageDeflate === true)
        options6.perMessageDeflate = {};
      if (options6.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options6;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head10, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade2 = req.headers.upgrade;
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade2 === undefined || upgrade2.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 8 && version !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions2 = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info3 = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info3, (verified, code3, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code3 || 401, message, headers);
            }
            this.completeUpgrade(extensions2, key, protocols, req, socket, head10, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info3))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions2, key, protocols, req, socket, head10, cb);
    }
    completeUpgrade(extensions2, key, protocols, req, socket, head10, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions2[PerMessageDeflate.extensionName]) {
        const params2 = extensions2[PerMessageDeflate.extensionName].params;
        const value8 = extension.format({
          [PerMessageDeflate.extensionName]: [params2]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value8}`);
        ws._extensions = extensions2;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head10, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map40) {
    for (const event of Object.keys(map40))
      server.on(event, map40[event]);
    return function removeListeners() {
      for (const event of Object.keys(map40)) {
        server.removeListener(event, map40[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code3, message, headers) {
    message = message || http.STATUS_CODES[code3];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code3} ${http.STATUS_CODES[code3]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code3, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code3, message);
    }
  }
});

// node_modules/@effect/cli/dist/esm/Args.js
var exports_Args = {};
__export(exports_Args, {
  wizard: () => wizard3,
  withSchema: () => withSchema2,
  withFallbackConfig: () => withFallbackConfig2,
  withDescription: () => withDescription4,
  withDefault: () => withDefault4,
  validate: () => validate7,
  text: () => text8,
  secret: () => secret4,
  repeated: () => repeated4,
  redacted: () => redacted4,
  path: () => path3,
  optional: () => optional3,
  none: () => none12,
  mapTryCatch: () => mapTryCatch2,
  mapEffect: () => mapEffect7,
  map: () => map33,
  isArgs: () => isArgs2,
  integer: () => integer6,
  getUsage: () => getUsage2,
  getMinSize: () => getMinSize2,
  getMaxSize: () => getMaxSize2,
  getIdentifier: () => getIdentifier2,
  getHelp: () => getHelp4,
  float: () => float4,
  fileText: () => fileText2,
  fileSchema: () => fileSchema2,
  fileParse: () => fileParse2,
  fileContent: () => fileContent2,
  file: () => file3,
  directory: () => directory2,
  date: () => date5,
  choice: () => choice4,
  boolean: () => boolean7,
  between: () => between6,
  atMost: () => atMost2,
  atLeast: () => atLeast2,
  all: () => all10,
  ArgsTypeId: () => ArgsTypeId2
});

// node_modules/effect/dist/esm/Array.js
var exports_Array = {};
__export(exports_Array, {
  zipWith: () => zipWith,
  zip: () => zip,
  window: () => window2,
  unzip: () => unzip,
  unsafeGet: () => unsafeGet,
  unprepend: () => unprepend,
  unionWith: () => unionWith,
  union: () => union,
  unfold: () => unfold,
  unappend: () => unappend,
  takeWhile: () => takeWhile,
  takeRight: () => takeRight,
  take: () => take,
  tailNonEmpty: () => tailNonEmpty,
  tail: () => tail,
  splitWhere: () => splitWhere,
  splitNonEmptyAt: () => splitNonEmptyAt,
  splitAt: () => splitAt,
  split: () => split,
  span: () => span,
  sortWith: () => sortWith,
  sortBy: () => sortBy,
  sort: () => sort,
  some: () => some3,
  setNonEmptyLast: () => setNonEmptyLast,
  setNonEmptyHead: () => setNonEmptyHead,
  separate: () => separate,
  scanRight: () => scanRight,
  scan: () => scan,
  rotate: () => rotate,
  reverse: () => reverse,
  replicate: () => replicate,
  replaceOption: () => replaceOption,
  replace: () => replace,
  removeOption: () => removeOption,
  remove: () => remove,
  reduceRight: () => reduceRight,
  reduce: () => reduce,
  range: () => range,
  prependAll: () => prependAll,
  prepend: () => prepend,
  partitionMap: () => partitionMap,
  partition: () => partition,
  pad: () => pad,
  of: () => of,
  modifyOption: () => modifyOption,
  modifyNonEmptyLast: () => modifyNonEmptyLast,
  modifyNonEmptyHead: () => modifyNonEmptyHead,
  modify: () => modify,
  min: () => min2,
  max: () => max2,
  matchRight: () => matchRight,
  matchLeft: () => matchLeft,
  match: () => match3,
  mapAccum: () => mapAccum,
  map: () => map5,
  makeBy: () => makeBy,
  make: () => make4,
  liftPredicate: () => liftPredicate,
  liftOption: () => liftOption,
  liftNullable: () => liftNullable,
  liftEither: () => liftEither,
  let: () => let_2,
  length: () => length,
  lastNonEmpty: () => lastNonEmpty,
  last: () => last,
  join: () => join,
  isNonEmptyReadonlyArray: () => isNonEmptyReadonlyArray,
  isNonEmptyArray: () => isNonEmptyArray2,
  isEmptyReadonlyArray: () => isEmptyReadonlyArray,
  isEmptyArray: () => isEmptyArray,
  isArray: () => isArray,
  intersperse: () => intersperse,
  intersectionWith: () => intersectionWith,
  intersection: () => intersection,
  insertAt: () => insertAt,
  initNonEmpty: () => initNonEmpty,
  init: () => init,
  headNonEmpty: () => headNonEmpty,
  head: () => head,
  groupWith: () => groupWith,
  groupBy: () => groupBy,
  group: () => group,
  getSomes: () => getSomes,
  getRights: () => getRights,
  getOrder: () => getOrder,
  getLefts: () => getLefts,
  getEquivalence: () => getEquivalence3,
  get: () => get,
  fromRecord: () => fromRecord,
  fromOption: () => fromOption3,
  fromNullable: () => fromNullable2,
  fromIterable: () => fromIterable,
  forEach: () => forEach,
  flatten: () => flatten,
  flatMapNullable: () => flatMapNullable2,
  flatMap: () => flatMap2,
  findLastIndex: () => findLastIndex,
  findLast: () => findLast,
  findFirstIndex: () => findFirstIndex,
  findFirst: () => findFirst2,
  filterMapWhile: () => filterMapWhile,
  filterMap: () => filterMap2,
  filter: () => filter2,
  extend: () => extend,
  every: () => every,
  ensure: () => ensure,
  empty: () => empty3,
  dropWhile: () => dropWhile,
  dropRight: () => dropRight,
  drop: () => drop,
  differenceWith: () => differenceWith,
  difference: () => difference,
  dedupeWith: () => dedupeWith,
  dedupeAdjacentWith: () => dedupeAdjacentWith,
  dedupeAdjacent: () => dedupeAdjacent,
  dedupe: () => dedupe,
  countBy: () => countBy,
  copy: () => copy,
  containsWith: () => containsWith2,
  contains: () => contains2,
  chunksOf: () => chunksOf,
  chop: () => chop,
  cartesianWith: () => cartesianWith,
  cartesian: () => cartesian,
  bindTo: () => bindTo2,
  bind: () => bind2,
  appendAll: () => appendAll,
  append: () => append,
  allocate: () => allocate,
  Do: () => Do
});

// node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self2) => body(self2, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self2) {
          return body(self2, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self2) {
          return body(self2, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self2) {
          return body(self2, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self2) {
          return body(self2, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function(self2) {
          return body(self2, ...args);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value) => () => value;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constUndefined = /* @__PURE__ */ constant(undefined);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1;i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var string = /* @__PURE__ */ strict();
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self2, f) => make((x, y) => self2(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number, (date) => date.getTime());
var array = (item) => make((self2, that) => {
  if (self2.length !== that.length) {
    return false;
  }
  for (let i = 0;i < self2.length; i++) {
    const isEq = item(self2[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map) => dual(3, (self2, name, f) => map(self2, (a) => ({
  ...a,
  [name]: f(a)
})));
var bindTo = (map) => dual(2, (self2, name) => map(self2, (a) => ({
  [name]: a
})));
var bind = (map, flatMap) => dual(3, (self2, name, f) => flatMap(self2, (a) => map(f(a), (b) => ({
  ...a,
  [name]: b
}))));

// node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.16.7";
var getCurrentVersion = () => moduleVersion;

// node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue/globalStoreId/${/* @__PURE__ */ getCurrentVersion()}`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= new Map;
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === undefined;
var isNever = (_) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self2, property) => isObject(self2) && (property in self2));
var isTagged = /* @__PURE__ */ dual(2, (self2, tag) => hasProperty(self2, "_tag") && self2["_tag"] === tag);
var isNullable = (input) => input === null || input === undefined;
var isNotNullable = (input) => input !== null && input !== undefined;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);
var or = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) || that(a));

// node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// node_modules/effect/dist/esm/Utils.js
class SingleShotGen {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;

class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");

class YieldWrap {
  #value;
  constructor(value) {
    this.#value = value;
  }
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
function yieldWrapGet(self2) {
  if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
    return self2[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: undefined
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {}
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {}.constructor;
var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

// node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap);
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self2) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self2) {
    case "number":
      return number2(self2);
    case "bigint":
      return string2(self2.toString(10));
    case "boolean":
      return string2(String(self2));
    case "symbol":
      return string2(String(self2));
    case "string":
      return string2(self2);
    case "undefined":
      return string2("undefined");
    case "function":
    case "object": {
      if (self2 === null) {
        return string2("null");
      } else if (self2 instanceof Date) {
        return hash(self2.toISOString());
      } else if (self2 instanceof URL) {
        return hash(self2.href);
      } else if (isHash(self2)) {
        return self2[symbol]();
      } else {
        return random(self2);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self2) => {
  if (!randomHashCache.has(self2)) {
    randomHashCache.set(self2, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self2);
};
var combine = (b) => (self2) => self2 * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string2 = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys) => {
  let h = 12289;
  for (let i = 0;i < keys.length; i++) {
    h ^= pipe(string2(keys[i]), combine(hash(o[keys[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0;i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self3 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self3, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self2 = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self2, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self2) => compareBoth(self2, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self2, that) {
  if (self2 === that) {
    return true;
  }
  const selfType = typeof self2;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self2 !== null && that !== null) {
      if (isEqual(self2) && isEqual(that)) {
        if (hash(self2) === hash(that) && self2[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
        }
      } else if (self2 instanceof Date && that instanceof Date) {
        return self2.toISOString() === that.toISOString();
      } else if (self2 instanceof URL && that instanceof URL) {
        return self2.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self2) && Array.isArray(that)) {
        return self2.length === that.length && self2.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
        const keysSelf = Object.keys(self2);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!((key in that) && compareBoth(self2[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = undefined;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && (symbolRedactable in u);
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: undefined
}));
var withRedactableContext = (context, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self2, args) => {
  switch (args.length) {
    case 0:
      return self2;
    case 1:
      return args[0](self2);
    case 2:
      return args[1](args[0](self2));
    case 3:
      return args[2](args[1](args[0](self2)));
    case 4:
      return args[3](args[2](args[1](args[0](self2))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self2)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self2))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2)))))))));
    default: {
      let ret = self2;
      for (let i = 0, len = args.length;i < len; i++) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};

// node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  _A: (_) => _,
  _In: (_) => _,
  _L: (_) => _,
  _E: (_) => _,
  _R: (_) => _
};
var channelVariance = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutElem: (_) => _,
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!((key in that) && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base2() {}
  Base2.prototype = CommitPrototype;
  return Base2;
}();

// node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left2) => {
  const a = Object.create(LeftProto);
  a.left = left2;
  return a;
};
var right = (right2) => {
  const a = Object.create(RightProto);
  a.right = right2;
  return a;
};
var fromOption = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? left(onNone()) : right(self2.value));

// node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var mapBoth = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? left2(onLeft(self2.left)) : right2(onRight(self2.right)));
var mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(f(self2.left)) : right2(self2.right));
var map = /* @__PURE__ */ dual(2, (self2, f) => isRight2(self2) ? right2(f(self2.right)) : left2(self2.left));
var match = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
  if (isRight2(self2)) {
    return self2.right;
  }
  throw onLeft(self2.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

// node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self2) => self2.length > 0;

// node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self2, that) => self2 === that ? 0 : compare(self2, that);
var string3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var number3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var boolean = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var combineMany = /* @__PURE__ */ dual(2, (self2, collection) => make2((a1, a2) => {
  let out = self2(a1, a2);
  if (out !== 0) {
    return out;
  }
  for (const O of collection) {
    out = O(a1, a2);
    if (out !== 0) {
      return out;
    }
  }
  return out;
}));
var empty = () => make2(() => 0);
var combineAll = (collection) => combineMany(empty(), collection);
var mapInput2 = /* @__PURE__ */ dual(2, (self2, f) => make2((b1, b2) => self2(f(b1), f(b2))));
var array3 = (O) => make2((self2, that) => {
  const aLen = self2.length;
  const bLen = that.length;
  const len = Math.min(aLen, bLen);
  for (let i = 0;i < len; i++) {
    const o = O(self2[i], that[i]);
    if (o !== 0) {
      return o;
    }
  }
  return number3(aLen, bLen);
});
var lessThan = (O) => dual(2, (self2, that) => O(self2, that) === -1);
var greaterThan = (O) => dual(2, (self2, that) => O(self2, that) === 1);
var min = (O) => dual(2, (self2, that) => self2 === that || O(self2, that) < 1 ? self2 : that);
var max = (O) => dual(2, (self2, that) => self2 === that || O(self2, that) > -1 ? self2 : that);
var clamp = (O) => dual(2, (self2, options) => min(O)(options.maximum, max(O)(options.minimum, self2)));
var between = (O) => dual(2, (self2, options) => !lessThan(O)(self2, options.minimum) && !greaterThan(O)(self2, options.maximum));

// node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self2, {
  onNone,
  onSome
}) => isNone2(self2) ? onNone() : onSome(self2.value));
var getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
var orElse = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
var orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some2(onNone()) : self2);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self2, onNone) => {
  if (isSome2(self2)) {
    return self2.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : some2(f(self2.value)));
var flatMap = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : f(self2.value));
var flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : fromNullable(f(self2.value)));
var toArray = (self2) => isNone2(self2) ? [] : [self2.value];
var filterMap = flatMap;
var filter = /* @__PURE__ */ dual(2, (self2, predicate) => filterMap(self2, (b) => predicate(b) ? some(b) : none));
var getEquivalence = (isEquivalent) => make((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value));
var containsWith = (isEquivalent) => dual(2, (self2, a) => isNone2(self2) ? false : isEquivalent(self2.value, a));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self2, refinement) => isNone2(self2) ? false : refinement(self2.value));
var mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
};

// node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;

// node_modules/effect/dist/esm/Iterable.js
var unsafeHead = (self2) => {
  const iterator = self2[Symbol.iterator]();
  const result = iterator.next();
  if (result.done)
    throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var findFirst = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  for (const a of self2) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: undefined
    };
  }
};
var empty2 = () => constEmpty;
var map3 = /* @__PURE__ */ dual(2, (self2, f) => ({
  [Symbol.iterator]() {
    const iterator = self2[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: undefined
          };
        }
        return {
          done: false,
          value: f(result.value, i++)
        };
      }
    };
  }
}));

// node_modules/effect/dist/esm/Record.js
var collect = /* @__PURE__ */ dual(2, (self2, f) => {
  const out = [];
  for (const key of keys(self2)) {
    out.push(f(key, self2[key]));
  }
  return out;
});
var toEntries = /* @__PURE__ */ collect((key, value) => [key, value]);
var has = /* @__PURE__ */ dual(2, (self2, key) => Object.prototype.hasOwnProperty.call(self2, key));
var map4 = /* @__PURE__ */ dual(2, (self2, f) => {
  const out = {
    ...self2
  };
  for (const key of keys(self2)) {
    out[key] = f(self2[key], key);
  }
  return out;
});
var keys = (self2) => Object.keys(self2);
var set = /* @__PURE__ */ dual(3, (self2, key, value) => {
  return {
    ...self2,
    [key]: value
  };
});
var isSubrecordBy = (equivalence2) => dual(2, (self2, that) => {
  for (const key of keys(self2)) {
    if (!has(that, key) || !equivalence2(self2[key], that[key])) {
      return false;
    }
  }
  return true;
});
var getEquivalence2 = (equivalence2) => {
  const is = isSubrecordBy(equivalence2);
  return (self2, that) => is(self2, that) && is(that, self2);
};

// node_modules/effect/dist/esm/Array.js
var make4 = (...elements) => elements;
var allocate = (n) => new Array(n);
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max2 = Math.max(1, Math.floor(n));
  const out = new Array(max2);
  for (let i = 0;i < max2; i++) {
    out[i] = f(i);
  }
  return out;
});
var range = (start, end) => start <= end ? makeBy(end - start + 1, (i) => start + i) : [start];
var replicate = /* @__PURE__ */ dual(2, (a, n) => makeBy(n, () => a));
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self2) => Array.isArray(self2) ? self2 : [self2];
var fromRecord = toEntries;
var fromOption3 = toArray;
var match3 = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(self2) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty(self2), tailNonEmpty(self2)) : onEmpty());
var matchRight = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(initNonEmpty(self2), lastNonEmpty(self2)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self2, head) => [head, ...self2]);
var prependAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable(that).concat(fromIterable(self2)));
var append = /* @__PURE__ */ dual(2, (self2, last) => [...self2, last]);
var appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable(self2).concat(fromIterable(that)));
var scan = /* @__PURE__ */ dual(3, (self2, b, f) => {
  const out = [b];
  let i = 0;
  for (const a of self2) {
    out[i + 1] = f(out[i], a);
    i++;
  }
  return out;
});
var scanRight = /* @__PURE__ */ dual(3, (self2, b, f) => {
  const input = fromIterable(self2);
  const out = new Array(input.length + 1);
  out[input.length] = b;
  for (let i = input.length - 1;i >= 0; i--) {
    out[i] = f(out[i + 1], input[i]);
  }
  return out;
});
var isArray = Array.isArray;
var isEmptyArray = (self2) => self2.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var length = (self2) => self2.length;
var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
var clamp2 = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
var get = /* @__PURE__ */ dual(2, (self2, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self2) ? none2() : some2(self2[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self2, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self2)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self2[i];
});
var unprepend = (self2) => [headNonEmpty(self2), tailNonEmpty(self2)];
var unappend = (self2) => [initNonEmpty(self2), lastNonEmpty(self2)];
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = (self2) => isNonEmptyReadonlyArray(self2) ? some2(lastNonEmpty(self2)) : none2();
var lastNonEmpty = (self2) => self2[self2.length - 1];
var tail = (self2) => {
  const input = fromIterable(self2);
  return isNonEmptyReadonlyArray(input) ? some2(tailNonEmpty(input)) : none2();
};
var tailNonEmpty = (self2) => self2.slice(1);
var init = (self2) => {
  const input = fromIterable(self2);
  return isNonEmptyReadonlyArray(input) ? some2(initNonEmpty(input)) : none2();
};
var initNonEmpty = (self2) => self2.slice(0, -1);
var take = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  return input.slice(0, clamp2(n, input));
});
var takeRight = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  const i = clamp2(n, input);
  return i === 0 ? [] : input.slice(-i);
});
var takeWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  const out = [];
  for (const a of self2) {
    if (!predicate(a, i)) {
      break;
    }
    out.push(a);
    i++;
  }
  return out;
});
var spanIndex = (self2, predicate) => {
  let i = 0;
  for (const a of self2) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
var drop = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  return input.slice(clamp2(n, input), input.length);
});
var dropRight = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  return input.slice(0, input.length - clamp2(n, input));
});
var dropWhile = /* @__PURE__ */ dual(2, (self2, predicate) => fromIterable(self2).slice(spanIndex(self2, predicate)));
var findFirstIndex = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  for (const a of self2) {
    if (predicate(a, i)) {
      return some2(i);
    }
    i++;
  }
  return none2();
});
var findLastIndex = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const input = fromIterable(self2);
  for (let i = input.length - 1;i >= 0; i--) {
    if (predicate(input[i], i)) {
      return some2(i);
    }
  }
  return none2();
});
var findFirst2 = findFirst;
var findLast = /* @__PURE__ */ dual(2, (self2, f) => {
  const input = fromIterable(self2);
  for (let i = input.length - 1;i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var countBy = /* @__PURE__ */ dual(2, (self2, f) => {
  let count = 0;
  const as = fromIterable(self2);
  for (let i = 0;i < as.length; i++) {
    const a = as[i];
    if (f(a, i)) {
      count++;
    }
  }
  return count;
});
var insertAt = /* @__PURE__ */ dual(3, (self2, i, b) => {
  const out = Array.from(self2);
  if (i < 0 || i > out.length) {
    return none2();
  }
  out.splice(i, 0, b);
  return some2(out);
});
var replace = /* @__PURE__ */ dual(3, (self2, i, b) => modify(self2, i, () => b));
var replaceOption = /* @__PURE__ */ dual(3, (self2, i, b) => modifyOption(self2, i, () => b));
var modify = /* @__PURE__ */ dual(3, (self2, i, f) => {
  const out = Array.from(self2);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  const b = f(out[i]);
  out[i] = b;
  return out;
});
var modifyOption = /* @__PURE__ */ dual(3, (self2, i, f) => {
  const arr = fromIterable(self2);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self2) ? self2.slice() : arr;
  const b = f(arr[i]);
  out[i] = b;
  return some2(out);
});
var remove = /* @__PURE__ */ dual(2, (self2, i) => {
  const out = Array.from(self2);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
var removeOption = /* @__PURE__ */ dual(2, (self2, i) => {
  const arr = fromIterable(self2);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self2) ? self2.slice() : arr;
  out.splice(i, 1);
  return some2(out);
});
var reverse = (self2) => Array.from(self2).reverse();
var sort = /* @__PURE__ */ dual(2, (self2, O) => {
  const out = Array.from(self2);
  out.sort(O);
  return out;
});
var sortWith = /* @__PURE__ */ dual(3, (self2, f, order) => Array.from(self2).map((a) => [a, f(a)]).sort(([, a], [, b]) => order(a, b)).map(([_]) => _));
var sortBy = (...orders) => {
  const sortByAll = sort(combineAll(orders));
  return (self2) => {
    const input = fromIterable(self2);
    if (isNonEmptyReadonlyArray(input)) {
      return sortByAll(input);
    }
    return [];
  };
};
var zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const as = fromIterable(self2);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as), headNonEmpty(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i = 1;i < len; i++) {
      out[i] = f(as[i], bs[i]);
    }
    return out;
  }
  return [];
});
var unzip = (self2) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1;i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
};
var intersperse = /* @__PURE__ */ dual(2, (self2, middle) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const tail2 = tailNonEmpty(input);
    for (let i = 0;i < tail2.length; i++) {
      if (i < tail2.length) {
        out.push(middle);
      }
      out.push(tail2[i]);
    }
    return out;
  }
  return [];
});
var modifyNonEmptyHead = /* @__PURE__ */ dual(2, (self2, f) => [f(headNonEmpty(self2)), ...tailNonEmpty(self2)]);
var setNonEmptyHead = /* @__PURE__ */ dual(2, (self2, b) => modifyNonEmptyHead(self2, () => b));
var modifyNonEmptyLast = /* @__PURE__ */ dual(2, (self2, f) => append(initNonEmpty(self2), f(lastNonEmpty(self2))));
var setNonEmptyLast = /* @__PURE__ */ dual(2, (self2, b) => modifyNonEmptyLast(self2, () => b));
var rotate = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const len = input.length;
    const m = Math.round(n) % len;
    if (isOutOfBounds(Math.abs(m), input) || m === 0) {
      return copy(input);
    }
    if (m < 0) {
      const [f, s] = splitNonEmptyAt(input, -m);
      return appendAll(s, f);
    } else {
      return rotate(self2, m - len);
    }
  }
  return [];
});
var containsWith2 = (isEquivalent) => dual(2, (self2, a) => {
  for (const i of self2) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var contains2 = /* @__PURE__ */ containsWith2(_equivalence2);
var chop = /* @__PURE__ */ dual(2, (self2, f) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const [b, rest] = f(input);
    const out = [b];
    let next = rest;
    while (isNonEmptyArray(next)) {
      const [b2, rest2] = f(next);
      out.push(b2);
      next = rest2;
    }
    return out;
  }
  return [];
});
var splitAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = Array.from(self2);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n), headNonEmpty(self2)), self2.slice(_n)];
});
var split = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  return chunksOf(input, Math.ceil(input.length / Math.floor(n)));
});
var splitWhere = /* @__PURE__ */ dual(2, (self2, predicate) => span(self2, (a, i) => !predicate(a, i)));
var copy = (self2) => self2.slice();
var pad = /* @__PURE__ */ dual(3, (self2, n, fill) => {
  if (self2.length >= n) {
    return take(self2, n);
  }
  return appendAll(self2, makeBy(n - self2.length, () => fill));
});
var chunksOf = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
});
var window2 = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  if (n > 0 && isNonEmptyReadonlyArray(input)) {
    return Array.from({
      length: input.length - (n - 1)
    }, (_, index) => input.slice(index, index + n));
  }
  return [];
});
var groupWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => chop(self2, (as) => {
  const h = headNonEmpty(as);
  const out = [h];
  let i = 1;
  for (;i < as.length; i++) {
    const a = as[i];
    if (isEquivalent(a, h)) {
      out.push(a);
    } else {
      break;
    }
  }
  return [out, as.slice(i)];
}));
var group = /* @__PURE__ */ groupWith(/* @__PURE__ */ equivalence());
var groupBy = /* @__PURE__ */ dual(2, (self2, f) => {
  const out = {};
  for (const a of self2) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
var unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
  const a = fromIterable(self2);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe = dedupeWith(isEquivalent);
      return dedupe(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
var intersectionWith = (isEquivalent) => {
  const has2 = containsWith2(isEquivalent);
  return dual(2, (self2, that) => fromIterable(self2).filter((a) => has2(that, a)));
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
var differenceWith = (isEquivalent) => {
  const has2 = containsWith2(isEquivalent);
  return dual(2, (self2, that) => fromIterable(self2).filter((a) => !has2(that, a)));
};
var difference = /* @__PURE__ */ differenceWith(_equivalence2);
var empty3 = () => [];
var of = (a) => [a];
var map5 = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (isEmptyReadonlyArray(self2)) {
    return [];
  }
  const out = [];
  for (let i = 0;i < self2.length; i++) {
    const inner = f(self2[i], i);
    for (let j = 0;j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const as = fromIterable(self2);
  const out = [];
  for (let i = 0;i < as.length; i++) {
    const o = f(as[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  const out = [];
  for (const a of self2) {
    const b = f(a, i);
    if (isSome2(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap = /* @__PURE__ */ dual(2, (self2, f) => {
  const left3 = [];
  const right3 = [];
  const as = fromIterable(self2);
  for (let i = 0;i < as.length; i++) {
    const e = f(as[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var getLefts = (self2) => {
  const out = [];
  for (const a of self2) {
    if (isLeft2(a)) {
      out.push(a.left);
    }
  }
  return out;
};
var getRights = (self2) => {
  const out = [];
  for (const a of self2) {
    if (isRight2(a)) {
      out.push(a.right);
    }
  }
  return out;
};
var filter2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const as = fromIterable(self2);
  const out = [];
  for (let i = 0;i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
});
var partition = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const left3 = [];
  const right3 = [];
  const as = fromIterable(self2);
  for (let i = 0;i < as.length; i++) {
    if (predicate(as[i], i)) {
      right3.push(as[i]);
    } else {
      left3.push(as[i]);
    }
  }
  return [left3, right3];
});
var separate = /* @__PURE__ */ partitionMap(identity);
var reduce = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable(self2).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable(self2).reduceRight((b2, a, i) => f(b2, a, i), b));
var liftPredicate = (predicate) => (b) => predicate(b) ? [b] : [];
var liftOption = (f) => (...a) => fromOption3(f(...a));
var fromNullable2 = (a) => a == null ? empty3() : [a];
var liftNullable = (f) => (...a) => fromNullable2(f(...a));
var flatMapNullable2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap2(self2, (a) => fromNullable2(f(a))));
var liftEither = (f) => (...a) => {
  const e = f(...a);
  return isLeft2(e) ? [] : [e.right];
};
var every = /* @__PURE__ */ dual(2, (self2, refinement) => self2.every(refinement));
var some3 = /* @__PURE__ */ dual(2, (self2, predicate) => self2.some(predicate));
var extend = /* @__PURE__ */ dual(2, (self2, f) => self2.map((_, i, as) => f(as.slice(i))));
var min2 = /* @__PURE__ */ dual(2, (self2, O) => self2.reduce(min(O)));
var max2 = /* @__PURE__ */ dual(2, (self2, O) => self2.reduce(max(O)));
var unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
};
var getOrder = array3;
var getEquivalence3 = array;
var forEach = /* @__PURE__ */ dual(2, (self2, f) => fromIterable(self2).forEach((a, i) => f(a, i)));
var dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self2) => dedupeWith(self2, equivalence());
var dedupeAdjacentWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const out = [];
  let lastA = none2();
  for (const a of self2) {
    if (isNone2(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = some2(a);
    }
  }
  return out;
});
var dedupeAdjacent = /* @__PURE__ */ dedupeAdjacentWith(/* @__PURE__ */ equivalence());
var join = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable(self2).join(sep));
var mapAccum = /* @__PURE__ */ dual(3, (self2, s, f) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self2) {
    const r = f(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});
var cartesianWith = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap2(self2, (a) => map5(that, (b) => f(a, b))));
var cartesian = /* @__PURE__ */ dual(2, (self2, that) => cartesianWith(self2, that, (a, b) => [a, b]));
var Do = /* @__PURE__ */ of({});
var bind2 = /* @__PURE__ */ bind(map5, flatMap2);
var bindTo2 = /* @__PURE__ */ bindTo(map5);
var let_2 = /* @__PURE__ */ let_(map5);

// node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self2, that) => {
  const error = Object.create(proto);
  error._op = OP_AND;
  error.left = self2;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var Or = (self2, that) => {
  const error = Object.create(proto);
  error._op = OP_OR;
  error.left = self2;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var isConfigError = (u) => hasProperty(u, ConfigErrorTypeId);
var prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
  switch (self2._op) {
    case OP_AND: {
      return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self2.path], self2.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self2.path], self2.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self2.path], self2.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_, left3, right3) => left3 && right3,
  orCase: (_, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext = /* @__PURE__ */ dual(3, (self2, context, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const error = input.pop();
    switch (error._op) {
      case OP_AND: {
        input.push(error.right);
        input.push(error.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error.right);
        input.push(error.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context, error.path, error.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context, error.path, error.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context, error.path, error.message, error.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context, error.path, error.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either = output.pop();
    switch (either._op) {
      case "Left": {
        switch (either.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.andCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.orCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self2) => reduceWithContext(self2, undefined, IsMissingDataOnlyReducer);

// node_modules/effect/dist/esm/ConfigError.js
var isConfigError2 = isConfigError;
var isMissingDataOnly2 = isMissingDataOnly;

// node_modules/effect/dist/esm/Console.js
var exports_Console = {};
__export(exports_Console, {
  withTime: () => withTime2,
  withGroup: () => withGroup2,
  withConsole: () => withConsole2,
  warn: () => warn2,
  trace: () => trace2,
  timeLog: () => timeLog2,
  time: () => time2,
  table: () => table2,
  setConsole: () => setConsole2,
  log: () => log3,
  info: () => info2,
  group: () => group3,
  error: () => error2,
  dirxml: () => dirxml2,
  dir: () => dir2,
  debug: () => debug2,
  countReset: () => countReset2,
  count: () => count2,
  consoleWith: () => consoleWith2,
  clear: () => clear3,
  assert: () => assert2,
  TypeId: () => TypeId14,
  Console: () => Console
});

// node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self2) {
    return self2;
  },
  context(self2) {
    return make5(this, self2);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
var Tag = (id) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function ReferenceClass() {}
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId3]: {
    _Services: (_) => _
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
};
var serviceNotFoundError = (tag) => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split(`
`);
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split(`
`);
    lines.splice(1, 3);
    error.stack = lines.join(`
`);
  }
  return error;
};
var isContext = (u) => hasProperty(u, TypeId3);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map);
var empty4 = () => _empty;
var make5 = (tag, service) => makeContext(new Map([[tag.key, service]]));
var add = /* @__PURE__ */ dual(3, (self2, tag, service) => {
  const map6 = new Map(self2.unsafeMap);
  map6.set(tag.key, service);
  return makeContext(map6);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => new Map);
var getDefaultValue = (tag) => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
};
var unsafeGetReference = (self2, tag) => {
  return self2.unsafeMap.has(tag.key) ? self2.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
var unsafeGet2 = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId in tag)
      return getDefaultValue(tag);
    throw serviceNotFoundError(tag);
  }
  return self2.unsafeMap.get(tag.key);
});
var get2 = unsafeGet2;
var getOption = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    return isReference(tag) ? some(getDefaultValue(tag)) : none;
  }
  return some(self2.unsafeMap.get(tag.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const map6 = new Map(self2.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map6.set(tag, s);
  }
  return makeContext(map6);
});
var omit = (...tags) => (self2) => {
  const newEnv = new Map(self2.unsafeMap);
  for (const tag of tags) {
    newEnv.delete(tag.key);
  }
  return makeContext(newEnv);
};

// node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var isContext2 = isContext;
var isTag2 = isTag;
var empty5 = empty4;
var make6 = make5;
var add2 = add;
var get3 = get2;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var omit2 = omit;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/effect/dist/esm/Chunk.js
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos;i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence4 = (isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value, i) => isEquivalent(value, unsafeGet4(that, i))));
var _equivalence3 = /* @__PURE__ */ getEquivalence4(equals);
var ChunkProto = {
  [TypeId4]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk.length = 0;
      chunk.depth = 0;
      chunk.left = chunk;
      chunk.right = chunk;
      break;
    }
    case "IConcat": {
      chunk.length = backing.left.length + backing.right.length;
      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk.left = backing.left;
      chunk.right = backing.right;
      break;
    }
    case "IArray": {
      chunk.length = backing.array.length;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk.length = 1;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk.length = backing.length;
      chunk.depth = backing.chunk.depth + 1;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
  }
  return chunk;
};
var isChunk = (u) => hasProperty(u, TypeId4);
var _empty2 = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty6 = () => _empty2;
var make7 = (...as) => unsafeFromNonEmptyArray(as);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable(self2));
var copyToArray = (self2, array4, initial) => {
  switch (self2.backing._tag) {
    case "IArray": {
      copy2(self2.backing.array, 0, array4, initial, self2.length);
      break;
    }
    case "IConcat": {
      copyToArray(self2.left, array4, initial);
      copyToArray(self2.right, array4, initial + self2.left.length);
      break;
    }
    case "ISingleton": {
      array4[initial] = self2.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self2.length) {
        array4[j] = unsafeGet4(self2, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray_ = (self2) => toReadonlyArray(self2).slice();
var toArray2 = toArray_;
var toReadonlyArray_ = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self2.backing.array;
    }
    default: {
      const arr = new Array(self2.length);
      copyToArray(self2, arr, 0);
      self2.backing = {
        _tag: "IArray",
        array: arr
      };
      self2.left = _empty2;
      self2.right = _empty2;
      self2.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self2;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self2.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self2.backing.right),
        right: reverse2(self2.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self2)));
  }
};
var reverse2 = reverseChunk;
var get4 = /* @__PURE__ */ dual(2, (self2, index) => index < 0 || index >= self2.length ? none2() : some2(unsafeGet4(self2, index)));
var unsafeFromArray = (self2) => self2.length === 0 ? empty6() : self2.length === 1 ? of2(self2[0]) : makeChunk({
  _tag: "IArray",
  array: self2
});
var unsafeFromNonEmptyArray = (self2) => unsafeFromArray(self2);
var unsafeGet4 = /* @__PURE__ */ dual(2, (self2, index) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.a;
    }
    case "IArray": {
      if (index >= self2.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.array[index];
    }
    case "IConcat": {
      return index < self2.left.length ? unsafeGet4(self2.left, index) : unsafeGet4(self2.right, index - self2.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self2.backing.chunk, index + self2.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self2, a) => appendAll2(self2, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
var take2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self2.length) {
    return self2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          length: n,
          offset: self2.backing.offset
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: take2(self2.right, n - self2.left.length)
          });
        }
        return take2(self2.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return self2;
  } else if (n >= self2.length) {
    return _empty2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          offset: self2.backing.offset + n,
          length: self2.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return drop2(self2.right, n - self2.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self2.left, n),
          right: self2.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: n,
          length: self2.length - n
        });
      }
    }
  }
});
var dropWhile2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const arr = toReadonlyArray(self2);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop2(self2, i);
});
var appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self2;
  }
  const diff = that.depth - self2.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self2,
      right: that
    });
  } else if (diff < -1) {
    if (self2.left.depth >= self2.right.depth) {
      const nr = appendAll2(self2.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self2.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self2.right.right, that);
      if (nrr.depth === self2.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self2.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: self2.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self2, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self2, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap3 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMap2(self2, f)));
var filter3 = /* @__PURE__ */ dual(2, (self2, predicate) => unsafeFromArray(filter2(self2, predicate)));
var filterMapWhile2 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMapWhile(self2, f)));
var flatMap3 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (self2.backing._tag === "ISingleton") {
    return f(self2.backing.a, 0);
  }
  let out = _empty2;
  let i = 0;
  for (const k of self2) {
    out = appendAll2(out, f(k, i++));
  }
  return out;
});
var flatten2 = /* @__PURE__ */ flatMap3(identity);
var isEmpty = (self2) => self2.length === 0;
var isNonEmpty = (self2) => self2.length > 0;
var head2 = /* @__PURE__ */ get4(0);
var unsafeHead2 = (self2) => unsafeGet4(self2, 0);
var headNonEmpty2 = unsafeHead2;
var last2 = (self2) => get4(self2, self2.length - 1);
var unsafeLast = (self2) => unsafeGet4(self2, self2.length - 1);
var map6 = /* @__PURE__ */ dual(2, (self2, f) => self2.backing._tag === "ISingleton" ? of2(f(self2.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self2), map5((a, i) => f(a, i)))));
var mapAccum2 = /* @__PURE__ */ dual(3, (self2, s, f) => {
  const [s1, as] = mapAccum(self2, s, f);
  return [s1, unsafeFromArray(as)];
});
var splitAt2 = /* @__PURE__ */ dual(2, (self2, n) => [take2(self2, n), drop2(self2, n)]);
var splitWhere2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self2)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self2, i);
});
var tailNonEmpty2 = (self2) => drop2(self2, 1);
var takeRight2 = /* @__PURE__ */ dual(2, (self2, n) => drop2(self2, self2.length - n));
var takeWhile2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self2)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => unsafeFromArray(zipWith(self2, that, f)));
var makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable2(makeBy(n, f)));
var range2 = (start, end) => start <= end ? makeBy2(end - start + 1, (i) => start + i) : of2(start);
var findFirst3 = findFirst2;
var reduce2 = reduce;
var reduceRight2 = reduceRight;

// node_modules/effect/dist/esm/Duration.js
var exports_Duration = {};
__export(exports_Duration, {
  zero: () => zero,
  weeks: () => weeks,
  unsafeToNanos: () => unsafeToNanos,
  unsafeFormatIso: () => unsafeFormatIso,
  unsafeDivide: () => unsafeDivide,
  toWeeks: () => toWeeks,
  toSeconds: () => toSeconds,
  toNanos: () => toNanos,
  toMinutes: () => toMinutes,
  toMillis: () => toMillis,
  toHrTime: () => toHrTime,
  toHours: () => toHours,
  toDays: () => toDays,
  times: () => times,
  sum: () => sum,
  subtract: () => subtract,
  seconds: () => seconds,
  parts: () => parts,
  nanos: () => nanos,
  minutes: () => minutes,
  min: () => min3,
  millis: () => millis,
  micros: () => micros,
  max: () => max3,
  matchWith: () => matchWith,
  match: () => match4,
  lessThanOrEqualTo: () => lessThanOrEqualTo,
  lessThan: () => lessThan2,
  isZero: () => isZero,
  isFinite: () => isFinite2,
  isDuration: () => isDuration,
  infinity: () => infinity,
  hours: () => hours,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo,
  greaterThan: () => greaterThan2,
  fromIso: () => fromIso,
  formatIso: () => formatIso,
  format: () => format2,
  equals: () => equals2,
  divide: () => divide,
  decodeUnknown: () => decodeUnknown,
  decode: () => decode,
  days: () => days,
  clamp: () => clamp3,
  between: () => between2,
  Order: () => Order,
  Equivalence: () => Equivalence
});
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1000);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match4 = DURATION_REGEX.exec(input);
    if (match4) {
      const [_, valueStr, unit] = match4;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var decodeUnknown = /* @__PURE__ */ liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId5]: TypeId5,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make8 = (input) => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
};
var isDuration = (u) => hasProperty(u, TypeId5);
var isFinite2 = (self2) => self2.value._tag !== "Infinity";
var isZero = (self2) => {
  switch (self2.value._tag) {
    case "Millis": {
      return self2.value.millis === 0;
    }
    case "Nanos": {
      return self2.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero = /* @__PURE__ */ make8(0);
var infinity = /* @__PURE__ */ make8(Infinity);
var nanos = (nanos2) => make8(nanos2);
var micros = (micros2) => make8(micros2 * bigint1e3);
var millis = (millis2) => make8(millis2);
var seconds = (seconds2) => make8(seconds2 * 1000);
var minutes = (minutes2) => make8(minutes2 * 60000);
var hours = (hours2) => make8(hours2 * 3600000);
var days = (days2) => make8(days2 * 86400000);
var weeks = (weeks2) => make8(weeks2 * 604800000);
var toMillis = (self2) => match4(self2, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var toSeconds = (self2) => match4(self2, {
  onMillis: (millis2) => millis2 / 1000,
  onNanos: (nanos2) => Number(nanos2) / 1e9
});
var toMinutes = (self2) => match4(self2, {
  onMillis: (millis2) => millis2 / 60000,
  onNanos: (nanos2) => Number(nanos2) / 60000000000
});
var toHours = (self2) => match4(self2, {
  onMillis: (millis2) => millis2 / 3600000,
  onNanos: (nanos2) => Number(nanos2) / 3600000000000
});
var toDays = (self2) => match4(self2, {
  onMillis: (millis2) => millis2 / 86400000,
  onNanos: (nanos2) => Number(nanos2) / 86400000000000
});
var toWeeks = (self2) => match4(self2, {
  onMillis: (millis2) => millis2 / 604800000,
  onNanos: (nanos2) => Number(nanos2) / 604800000000000
});
var toNanos = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some2(_self.value.nanos);
    case "Millis":
      return some2(BigInt(Math.round(_self.value.millis * 1e6)));
  }
};
var unsafeToNanos = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1e6)];
  }
};
var match4 = /* @__PURE__ */ dual(2, (self2, options) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self2, that, options) => {
  const _self = decode(self2);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Order = /* @__PURE__ */ make2((self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0,
  onNanos: (self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0
}));
var between2 = /* @__PURE__ */ between(/* @__PURE__ */ mapInput2(Order, decode));
var Equivalence = (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 === that2,
  onNanos: (self3, that2) => self3 === that2
});
var _min = /* @__PURE__ */ min(Order);
var min3 = /* @__PURE__ */ dual(2, (self2, that) => _min(decode(self2), decode(that)));
var _max = /* @__PURE__ */ max(Order);
var max3 = /* @__PURE__ */ dual(2, (self2, that) => _max(decode(self2), decode(that)));
var _clamp = /* @__PURE__ */ clamp(Order);
var clamp3 = /* @__PURE__ */ dual(2, (self2, options) => _clamp(decode(self2), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
var divide = /* @__PURE__ */ dual(2, (self2, by) => match4(self2, {
  onMillis: (millis2) => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return none2();
    }
    return some2(make8(millis2 / by));
  },
  onNanos: (nanos2) => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return none2();
    }
    try {
      return some2(make8(nanos2 / BigInt(by)));
    } catch {
      return none2();
    }
  }
}));
var unsafeDivide = /* @__PURE__ */ dual(2, (self2, by) => match4(self2, {
  onMillis: (millis2) => make8(millis2 / by),
  onNanos: (nanos2) => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make8(nanos2 / BigInt(by));
  }
}));
var times = /* @__PURE__ */ dual(2, (self2, times2) => match4(self2, {
  onMillis: (millis2) => make8(millis2 * times2),
  onNanos: (nanos2) => make8(nanos2 * BigInt(times2))
}));
var subtract = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => make8(self3 - that2),
  onNanos: (self3, that2) => make8(self3 - that2)
}));
var sum = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => make8(self3 + that2),
  onNanos: (self3, that2) => make8(self3 + that2)
}));
var lessThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 < that2,
  onNanos: (self3, that2) => self3 < that2
}));
var lessThanOrEqualTo = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 <= that2,
  onNanos: (self3, that2) => self3 <= that2
}));
var greaterThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 > that2,
  onNanos: (self3, that2) => self3 > that2
}));
var greaterThanOrEqualTo = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 >= that2,
  onNanos: (self3, that2) => self3 >= that2
}));
var equals2 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(decode(self2), decode(that)));
var parts = (self2) => {
  const duration = decode(self2);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min4 = sec / bigint60;
  const hr = min4 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min4 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format2 = (self2) => {
  const duration = decode(self2);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration)) {
    return "0";
  }
  const fragments = parts(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};
var unsafeFormatIso = (self2) => {
  const duration = decode(self2);
  if (!isFinite2(duration)) {
    throw new RangeError("Cannot format infinite duration");
  }
  const fragments = [];
  const {
    days: days2,
    hours: hours2,
    millis: millis2,
    minutes: minutes2,
    nanos: nanos2,
    seconds: seconds2
  } = parts(duration);
  let rest = days2;
  if (rest >= 365) {
    const years = Math.floor(rest / 365);
    rest %= 365;
    fragments.push(`${years}Y`);
  }
  if (rest >= 30) {
    const months = Math.floor(rest / 30);
    rest %= 30;
    fragments.push(`${months}M`);
  }
  if (rest >= 7) {
    const weeks2 = Math.floor(rest / 7);
    rest %= 7;
    fragments.push(`${weeks2}W`);
  }
  if (rest > 0) {
    fragments.push(`${rest}D`);
  }
  if (hours2 !== 0 || minutes2 !== 0 || seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
    fragments.push("T");
    if (hours2 !== 0) {
      fragments.push(`${hours2}H`);
    }
    if (minutes2 !== 0) {
      fragments.push(`${minutes2}M`);
    }
    if (seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
      const total = BigInt(seconds2) * bigint1e9 + BigInt(millis2) * bigint1e6 + BigInt(nanos2);
      const str = (Number(total) / 1e9).toFixed(9).replace(/\.?0+$/, "");
      fragments.push(`${str}S`);
    }
  }
  return `P${fragments.join("") || "T0S"}`;
};
var formatIso = (self2) => {
  const duration = decode(self2);
  return isFinite2(duration) ? some2(unsafeFormatIso(duration)) : none2();
};
var fromIso = (iso) => {
  const result = DURATION_ISO_REGEX.exec(iso);
  if (result == null) {
    return none2();
  }
  const [years, months, weeks2, days2, hours2, mins, secs] = result.slice(1, 8).map((_) => _ ? Number(_) : 0);
  const value = years * 365 * 24 * 60 * 60 + months * 30 * 24 * 60 * 60 + weeks2 * 7 * 24 * 60 * 60 + days2 * 24 * 60 * 60 + hours2 * 60 * 60 + mins * 60 + secs;
  return some2(seconds(value));
};
var DURATION_ISO_REGEX = /^P(?!$)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?!$)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

// node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift, h) {
  return h >>> shift & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/effect/dist/esm/internal/stack.js
var make9 = (value, previous) => ({
  value,
  previous
});

// node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate, at, v, arr) {
  let out = arr;
  if (!mutate) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0;i < len; ++i)
      out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at)
      out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen)
    out[g++] = arr[i++];
  if (mutate) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate, at, v, arr) {
  const len = arr.length;
  if (mutate) {
    let i2 = len;
    while (i2 >= at)
      arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at)
    out[g++] = arr[i++];
  out[at] = v;
  while (i < len)
    out[++g] = arr[i++];
  return out;
}

// node_modules/effect/dist/esm/internal/hashMap/node.js
class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size) {
    const v = f(none2());
    if (isNone2(v))
      return new EmptyNode;
    ++size.value;
    return new LeafNode(edit, hash2, key, v);
  }
}
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}

class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value)
        return this;
      else if (isNone2(v2)) {
        --size.value;
        return new EmptyNode;
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
}

class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
      if (list === this.children)
        return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate, edit, hash2, list, f, key, size) {
    const len = list.length;
    for (let i = 0;i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value)
          return list;
        if (isNone2(newValue2)) {
          --size.value;
          return arraySpliceOut(mutate, i, list);
        }
        return arrayUpdate(mutate, i, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue))
      return list;
    ++size.value;
    return arrayUpdate(mutate, len, new LeafNode(edit, hash2, key, newValue), list);
  }
}

class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists2 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists2) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size);
      if (!_newChild)
        return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash2, key, size);
    if (current === child)
      return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new EmptyNode;
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}

class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size, children) {
    this.edit = edit;
    this.size = size;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new EmptyNode).modify(edit, shift + SIZE, f, hash2, key, size);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length;i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0;bit; ++i) {
    if (bit & 1)
      arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = undefined;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make9(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size) => {
  const map7 = Object.create(HashMapProto);
  map7._editable = editable;
  map7._edit = edit;
  map7._root = root;
  map7._size = size;
  return map7;
};

class HashMapIterator {
  map;
  f;
  v;
  constructor(map7, f) {
    this.map = map7;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, undefined);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: undefined
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode, 0);
var empty7 = () => _empty3;
var make10 = (...entries) => fromIterable3(entries);
var fromIterable3 = (entries) => {
  const map7 = beginMutation(empty7());
  for (const entry of entries) {
    set2(map7, entry[0], entry[1]);
  }
  return endMutation(map7);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self2) => self2 && isEmptyNode(self2._root);
var get5 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self2, key, hash2) => {
  let node = self2._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length;i < len; ++i) {
            const child = children[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift, hash2)];
        if (node) {
          shift += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has2 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
var set2 = /* @__PURE__ */ dual(3, (self2, key, value) => modifyAt(self2, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
  if (self2._editable) {
    self2._root = newRoot;
    self2._size = newSize;
    return self2;
  }
  return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
});
var keys2 = (self2) => new HashMapIterator(self2, (key) => key);
var size = (self2) => self2._size;
var beginMutation = (self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size);
var endMutation = (self2) => {
  self2._editable = false;
  return self2;
};
var mutate = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation(self2);
  f(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash2, f) => {
  const size2 = {
    value: self2._size
  };
  const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash2, key, size2);
  return pipe(self2, setTree(newRoot, size2.value));
});
var union2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const result = beginMutation(self2);
  forEach2(that, (v, k) => set2(result, k, v));
  return endMutation(result);
});
var remove2 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
var map7 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty7(), (map8, value, key) => set2(map8, key, f(value, key))));
var forEach2 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, undefined, (_, value, key) => f(value, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self2, zero2, f) => {
  const root = self2._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero2, root.value.value, root.key) : zero2;
  }
  if (root._tag === "EmptyNode") {
    return zero2;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length;i < len; ) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero2 = f(zero2, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero2;
});

// node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set3 = Object.create(HashSetProto);
  set3._keyMap = keyMap;
  return set3;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty7());
var empty8 = () => _empty4;
var fromIterable4 = (elements) => {
  const set3 = beginMutation2(empty8());
  for (const value of elements) {
    add3(set3, value);
  }
  return endMutation2(set3);
};
var make11 = (...elements) => {
  const set3 = beginMutation2(empty8());
  for (const value of elements) {
    add3(set3, value);
  }
  return endMutation2(set3);
};
var has3 = /* @__PURE__ */ dual(2, (self2, value) => has2(self2._keyMap, value));
var size2 = (self2) => size(self2._keyMap);
var beginMutation2 = (self2) => makeImpl2(beginMutation(self2._keyMap));
var endMutation2 = (self2) => {
  self2._keyMap._editable = false;
  return self2;
};
var mutate2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation2(self2);
  f(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (set2(value, true)(self2._keyMap), self2) : makeImpl2(set2(value, true)(self2._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (remove2(value)(self2._keyMap), self2) : makeImpl2(remove2(value)(self2._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set3) => {
  for (const value of that) {
    remove3(set3, value);
  }
}));
var union3 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty8(), (set3) => {
  forEach3(self2, (value) => add3(set3, value));
  for (const value of that) {
    add3(set3, value);
  }
}));
var forEach3 = /* @__PURE__ */ dual(2, (self2, f) => forEach2(self2._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self2, zero2, f) => reduce3(self2._keyMap, zero2, (z, _, a) => f(z, a)));

// node_modules/effect/dist/esm/HashSet.js
var empty9 = empty8;
var fromIterable5 = fromIterable4;
var make12 = make11;
var has4 = has3;
var size3 = size2;
var add4 = add3;
var remove4 = remove3;
var difference3 = difference2;
var union4 = union3;
var forEach4 = forEach3;
var reduce5 = reduce4;

// node_modules/effect/dist/esm/MutableRef.js
var exports_MutableRef = {};
__export(exports_MutableRef, {
  updateAndGet: () => updateAndGet,
  update: () => update,
  toggle: () => toggle2,
  setAndGet: () => setAndGet,
  set: () => set3,
  make: () => make13,
  incrementAndGet: () => incrementAndGet,
  increment: () => increment,
  getAndUpdate: () => getAndUpdate,
  getAndSet: () => getAndSet,
  getAndIncrement: () => getAndIncrement,
  getAndDecrement: () => getAndDecrement,
  get: () => get6,
  decrementAndGet: () => decrementAndGet,
  decrement: () => decrement,
  compareAndSet: () => compareAndSet
});
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId6]: TypeId6,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make13 = (value) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
  if (equals(oldValue, self2.current)) {
    self2.current = newValue;
    return true;
  }
  return false;
});
var decrement = (self2) => update(self2, (n) => n - 1);
var decrementAndGet = (self2) => updateAndGet(self2, (n) => n - 1);
var get6 = (self2) => self2.current;
var getAndDecrement = (self2) => getAndUpdate(self2, (n) => n - 1);
var getAndIncrement = (self2) => getAndUpdate(self2, (n) => n + 1);
var getAndSet = /* @__PURE__ */ dual(2, (self2, value) => {
  const ret = self2.current;
  self2.current = value;
  return ret;
});
var getAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => getAndSet(self2, f(get6(self2))));
var increment = (self2) => update(self2, (n) => n + 1);
var incrementAndGet = (self2) => updateAndGet(self2, (n) => n + 1);
var set3 = /* @__PURE__ */ dual(2, (self2, value) => {
  self2.current = value;
  return self2;
});
var setAndGet = /* @__PURE__ */ dual(2, (self2, value) => {
  self2.current = value;
  return self2.current;
});
var update = /* @__PURE__ */ dual(2, (self2, f) => set3(self2, f(get6(self2))));
var updateAndGet = /* @__PURE__ */ dual(2, (self2, f) => setAndGet(self2, f(get6(self2))));
var toggle2 = (self2) => update(self2, (_) => !_);

// node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string2(`${FiberIdSymbolKey}-${OP_NONE}`);

class None {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Runtime {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string2(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Composite {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string2(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var none3 = /* @__PURE__ */ new None;
var runtime = (id, startTimeMillis) => {
  return new Runtime(id, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self2) => hasProperty(self2, FiberIdTypeId);
var combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self2;
  }
  return new Composite(self2, that);
});
var combineAll2 = (fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
};
var ids = (self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty9();
    }
    case OP_RUNTIME: {
      return make12(self2.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self2.left), union4(ids(self2.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make13(0));
var make14 = (id, startTimeSeconds) => {
  return new Runtime(id, startTimeSeconds);
};
var threadName = (self2) => {
  const identifiers = Array.from(ids(self2)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var toSet = (self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty9();
    }
    case OP_RUNTIME: {
      return make12(self2);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self2.left), union4(toSet(self2.right)));
    }
  }
};
var unsafeMake = () => {
  const id = get6(_fiberCounter);
  pipe(_fiberCounter, set3(id + 1));
  return new Runtime(id, Date.now());
};

// node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var combine3 = combine2;
var combineAll3 = combineAll2;
var ids2 = ids;
var make15 = make14;
var threadName2 = threadName;
var toSet2 = toSet;
var unsafeMake2 = unsafeMake;

// node_modules/effect/dist/esm/HashMap.js
var empty10 = empty7;
var make16 = make10;
var fromIterable6 = fromIterable3;
var isEmpty3 = isEmpty2;
var get7 = get5;
var has5 = has2;
var set4 = set2;
var keys3 = keys2;
var size4 = size;
var mutate3 = mutate;
var modifyAt2 = modifyAt;
var union5 = union2;
var map9 = map7;
var forEach5 = forEach2;
var reduce6 = reduce3;

// node_modules/effect/dist/esm/List.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray3 = (self2) => fromIterable(self2);
var getEquivalence5 = (isEquivalent) => mapInput(getEquivalence3(isEquivalent), toArray3);
var _equivalence4 = /* @__PURE__ */ getEquivalence5(equals);
var ConsProto = {
  [TypeId7]: TypeId7,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done = false;
    let self2 = this;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (self2._tag === "Nil") {
          done = true;
          return this.return();
        }
        const value = self2.head;
        self2 = self2.tail;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head3, tail2) => {
  const cons = Object.create(ConsProto);
  cons.head = head3;
  cons.tail = tail2;
  return cons;
};
var NilHash = /* @__PURE__ */ string2("Nil");
var NilProto = {
  [TypeId7]: TypeId7,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: undefined
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId7);
var isNil = (self2) => self2._tag === "Nil";
var isCons = (self2) => self2._tag === "Cons";
var nil = () => _Nil;
var cons = (head3, tail2) => makeCons(head3, tail2);
var empty11 = nil;
var of3 = (value) => makeCons(value, _Nil);
var appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll2(that, self2));
var prepend3 = /* @__PURE__ */ dual(2, (self2, element) => cons(element, self2));
var prependAll2 = /* @__PURE__ */ dual(2, (self2, prefix) => {
  if (isNil(self2)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self2;
  } else {
    const result = makeCons(prefix.head, self2);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self2);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce7 = /* @__PURE__ */ dual(3, (self2, zero2, f) => {
  let acc = zero2;
  let these = self2;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self2) => {
  let result = empty11();
  let these = self2;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};

// node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ function() {
  function Structural2(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
}();
var struct = (as) => Object.assign(Object.create(StructuralPrototype), as);

// node_modules/effect/dist/esm/internal/differ/chunkPatch.js
var ChunkPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferChunkPatch");
function variance(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};

// node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty12 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AddService"
});
var makeAddService = (key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update2) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update2;
  return o;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = empty12();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch = combine4(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = combine4(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = combine4(makeRemoveService(tag))(patch);
  }
  return patch;
};
var combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
var patch = /* @__PURE__ */ dual(2, (self2, context) => {
  if (self2._tag === "Empty") {
    return context;
  }
  let wasServiceUpdated = false;
  let patches = of2(self2);
  const updatedContext = new Map(context.unsafeMap);
  while (isNonEmpty(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail2 = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AddService": {
        updatedContext.set(head3.key, head3.service);
        patches = tail2;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail2, head3.second), head3.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head3.key);
        patches = tail2;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head3.key, head3.update(updatedContext.get(head3.key)));
        wasServiceUpdated = true;
        patches = tail2;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map10 = new Map;
  for (const [tag] of context.unsafeMap) {
    if (updatedContext.has(tag)) {
      map10.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s] of updatedContext) {
    map10.set(tag, s);
  }
  return makeContext(map10);
});

// node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
var HashMapPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashMapPatch");
function variance3(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};

// node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance4(a) {
  return a;
}
var PatchProto4 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance4,
    _Key: variance4,
    _Patch: variance4
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty13 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen2 = (first, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first;
  o.second = second;
  return o;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Add"
});
var makeAdd = (value) => {
  const o = Object.create(AddProto);
  o.value = value;
  return o;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Remove"
});
var makeRemove = (value) => {
  const o = Object.create(RemoveProto);
  o.value = value;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch2] = reduce5([oldValue, empty13()], ([set5, patch3], value) => {
    if (has4(value)(set5)) {
      return [remove4(value)(set5), patch3];
    }
    return [set5, combine5(makeAdd(value))(patch3)];
  })(newValue);
  return reduce5(patch2, (patch3, value) => combine5(makeRemove(value))(patch3))(removed);
};
var combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
var patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let set5 = oldValue;
  let patches = of2(self2);
  while (isNonEmpty(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail2 = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AndThen": {
        patches = prepend2(head3.first)(prepend2(head3.second)(tail2));
        break;
      }
      case "Add": {
        set5 = add4(head3.value)(set5);
        patches = tail2;
        break;
      }
      case "Remove": {
        set5 = remove4(head3.value)(set5);
        patches = tail2;
      }
    }
  }
  return set5;
});

// node_modules/effect/dist/esm/internal/differ/orPatch.js
var OrPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferOrPatch");
function variance5(a) {
  return a;
}
var PatchProto5 = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance5,
    _Key: variance5,
    _Patch: variance5
  }
};

// node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance6(a) {
  return a;
}
var PatchProto6 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance6,
    _Patch: variance6
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty14 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen3 = (first, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first;
  o.second = second;
  return o;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend = (values3) => {
  const o = Object.create(AppendProto);
  o.values = values3;
  return o;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate = (index, patch3) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch3;
  return o;
};
var diff3 = (options) => {
  let i = 0;
  let patch3 = empty14();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch3 = combine6(patch3, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch3 = combine6(patch3, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch3 = combine6(patch3, makeAppend(drop(i)(options.newValue)));
  }
  return patch3;
};
var combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
var patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray = oldValue.slice();
  let patches = of(self2);
  while (isNonEmptyArray2(patches)) {
    const head3 = headNonEmpty(patches);
    const tail2 = tailNonEmpty(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AndThen": {
        tail2.unshift(head3.first, head3.second);
        patches = tail2;
        break;
      }
      case "Append": {
        for (const value of head3.values) {
          readonlyArray.push(value);
        }
        patches = tail2;
        break;
      }
      case "Slice": {
        readonlyArray = readonlyArray.slice(head3.from, head3.until);
        patches = tail2;
        break;
      }
      case "Update": {
        readonlyArray[head3.index] = differ.patch(head3.patch, readonlyArray[head3.index]);
        patches = tail2;
        break;
      }
    }
  }
  return readonlyArray;
});

// node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make17 = (params) => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
};
var environment = () => make17({
  empty: empty12(),
  combine: (first, second) => combine4(second)(first),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch7, oldValue) => patch(oldValue)(patch7)
});
var hashSet = () => make17({
  empty: empty13(),
  combine: (first, second) => combine5(second)(first),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch7, oldValue) => patch2(oldValue)(patch7)
});
var readonlyArray = (differ) => make17({
  empty: empty14(),
  combine: (first, second) => combine6(first, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch7, oldValue) => patch3(patch7, oldValue, differ)
});
var update2 = () => updateWith((_, a) => a);
var updateWith = (f) => make17({
  empty: identity,
  combine: (first, second) => {
    if (first === identity) {
      return second;
    }
    if (second === identity) {
      return first;
    }
    return (a) => second(first(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch7, oldValue) => f(oldValue, patch7(oldValue))
});

// node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch7) => patch7 & BIT_MASK;
var enabled = (patch7) => patch7 >> BIT_SHIFT & BIT_MASK;
var make18 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty18 = /* @__PURE__ */ make18(0, 0);
var enable = (flag) => make18(flag, flag);
var disable = (flag) => make18(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self2, flag) => make18(active(self2) & ~flag, enabled(self2)));
var andThen = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self2) => isEnabled(self2, CooperativeYielding);
var disable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
var interruptible = (self2) => interruption(self2) && !windDown(self2);
var interruption = (self2) => isEnabled(self2, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
var make19 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = /* @__PURE__ */ make19(None2);
var runtimeMetrics = (self2) => isEnabled(self2, RuntimeMetrics);
var windDown = (self2) => isEnabled(self2, WindDown);
var diff7 = /* @__PURE__ */ dual(2, (self2, that) => make18(self2 ^ that, that));
var patch7 = /* @__PURE__ */ dual(2, (self2, patch8) => self2 & (invert(active(patch8)) | enabled(patch8)) | active(patch8) & enabled(patch8));
var differ = /* @__PURE__ */ make17({
  empty: empty18,
  diff: (oldValue, newValue) => diff7(oldValue, newValue),
  combine: (first, second) => andThen(second)(first),
  patch: (_patch, oldValue) => patch7(oldValue, _patch)
});

// node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty19 = empty18;
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// node_modules/effect/dist/esm/internal/blockedRequests.js
var empty20 = {
  _tag: "Empty"
};
var par = (self2, that) => ({
  _tag: "Par",
  left: self2,
  right: that
});
var seq = (self2, that) => ({
  _tag: "Seq",
  left: self2,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var flatten3 = (self2) => {
  let current = of3(self2);
  let updated = empty11();
  while (true) {
    const [parallel, sequential] = reduce7(current, [parallelCollectionEmpty(), empty11()], ([parallel2, sequential2], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel2, par2), appendAll3(sequential2, seq2)];
    });
    updated = merge4(updated, parallel);
    if (isNil(sequential)) {
      return reverse3(updated);
    }
    current = sequential;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current = requests;
  let parallel = parallelCollectionEmpty();
  let stack = empty11();
  let sequential = empty11();
  while (true) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left3 = current.left;
        const right3 = current.right;
        switch (left3._tag) {
          case "Empty": {
            current = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current = left3;
            sequential = cons(right3, sequential);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel = parallelCollectionAdd(parallel, current);
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential, parallel) => {
  if (isNil(sequential)) {
    return of3(parallelCollectionToSequentialCollection(parallel));
  }
  if (parallelCollectionIsEmpty(parallel)) {
    return sequential;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential.head);
  const parKeys = parallelCollectionKeys(parallel);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel), sequential);
};
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");

class EntryImpl {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request, result, listeners, ownerId, state) {
    this.request = request;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
}
var blockedRequestVariance = {
  _R: (_) => _
};
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  _R: (_) => _
};

class ParallelImpl {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map10) {
    this.map = map10;
  }
}
var parallelCollectionEmpty = () => new ParallelImpl(empty10());
var parallelCollectionAdd = (self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self2, that) => new ParallelImpl(reduce6(self2.map, that.map, (map10, value, key) => set4(map10, key, match2(get7(map10, key), {
  onNone: () => value,
  onSome: (other) => appendAll2(value, other)
}))));
var parallelCollectionIsEmpty = (self2) => isEmpty3(self2.map);
var parallelCollectionKeys = (self2) => Array.from(keys3(self2.map));
var parallelCollectionToSequentialCollection = (self2) => sequentialCollectionMake(map9(self2.map, (x) => of2(x)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  _R: (_) => _
};

class SequentialImpl {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map10) {
    this.map = map10;
  }
}
var sequentialCollectionMake = (map10) => new SequentialImpl(map10);
var sequentialCollectionCombine = (self2, that) => new SequentialImpl(reduce6(that.map, self2.map, (map10, value, key) => set4(map10, key, match2(get7(map10, key), {
  onNone: () => empty6(),
  onSome: (a) => appendAll2(a, value)
}))));
var sequentialCollectionKeys = (self2) => Array.from(keys3(self2.map));
var sequentialCollectionToChunk = (self2) => Array.from(self2.map);

// node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance7 = {
  _E: (_) => _
};
var proto2 = {
  [CauseTypeId]: variance7,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty21 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto2);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error) => {
  const o = Object.create(proto2);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto2);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId) => {
  const o = Object.create(proto2);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto2);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto2);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self2) => self2._tag === OP_EMPTY;
var isFailType = (self2) => self2._tag === OP_FAIL;
var isDieType = (self2) => self2._tag === OP_DIE;
var isEmpty5 = (self2) => {
  if (self2._tag === OP_EMPTY) {
    return true;
  }
  return reduce8(self2, true, (acc, cause) => {
    switch (cause._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self2) => isSome2(interruptOption(self2));
var isInterruptedOnly = (self2) => reduceWithContext2(undefined, IsInterruptedOnlyCauseReducer)(self2);
var failures = (self2) => reverse2(reduce8(self2, empty6(), (list, cause) => cause._tag === OP_FAIL ? some2(pipe(list, prepend2(cause.error))) : none2()));
var defects = (self2) => reverse2(reduce8(self2, empty6(), (list, cause) => cause._tag === OP_DIE ? some2(pipe(list, prepend2(cause.defect))) : none2()));
var interruptors = (self2) => reduce8(self2, empty9(), (set5, cause) => cause._tag === OP_INTERRUPT ? some2(pipe(set5, add4(cause.fiberId))) : none2());
var failureOption = (self2) => find(self2, (cause) => cause._tag === OP_FAIL ? some2(cause.error) : none2());
var failureOrCause = (self2) => {
  const option = failureOption(self2);
  switch (option._tag) {
    case "None": {
      return right2(self2);
    }
    case "Some": {
      return left2(option.value);
    }
  }
};
var flipCauseOption = (self2) => match5(self2, {
  onEmpty: some2(empty21),
  onFail: map2(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId) => some2(interrupt(fiberId)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self2) => find(self2, (cause) => cause._tag === OP_INTERRUPT ? some2(cause.fiberId) : none2());
var keepDefects = (self2) => match5(self2, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self2) => match5(self2, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self2) => match5(self2, {
  onEmpty: empty21,
  onFail: () => empty21,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self2) => match5(self2, {
  onEmpty: empty21,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var map11 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (e) => fail(f(e))));
var flatMap7 = /* @__PURE__ */ dual(2, (self2, f) => match5(self2, {
  onEmpty: empty21,
  onFail: (error) => f(error),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId) => interrupt(fiberId),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten4 = (self2) => flatMap7(self2, identity);
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce8([empty9(), empty6()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union4(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce8([empty9(), empty6()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union4(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause) => {
  return flattenCauseLoop(of2(cause), empty6());
};
var flattenCauseLoop = (causes, flattened) => {
  while (true) {
    const [parallel2, sequential2] = pipe(causes, reduce([empty9(), empty6()], ([parallel3, sequential3], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return [pipe(parallel3, union4(par2)), pipe(sequential3, appendAll2(seq2))];
    }));
    const updated = size3(parallel2) > 0 ? pipe(flattened, prepend2(parallel2)) : flattened;
    if (isEmpty(sequential2)) {
      return reverse2(updated);
    }
    causes = sequential2;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self2, pf) => {
  const stack = [self2];
  while (stack.length > 0) {
    const item = stack.pop();
    const option = pf(item);
    switch (option._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option;
      }
    }
  }
  return none2();
});
var evaluateCause = (self2) => {
  let cause = self2;
  const stack = [];
  let _parallel = empty9();
  let _sequential = empty6();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make7(cause._tag, cause.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make7(cause._tag, cause.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make7(cause._tag, cause.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause.left._tag) {
          case OP_EMPTY: {
            cause = cause.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
            break;
          }
          case OP_PARALLEL: {
            cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause.right);
            cause = cause.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause.right);
        cause = cause.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match5 = /* @__PURE__ */ dual(2, (self2, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt,
  onParallel,
  onSequential
}) => {
  return reduceWithContext2(self2, undefined, {
    emptyCase: () => onEmpty,
    failCase: (_, error) => onFail(error),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId) => onInterrupt(fiberId),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce8 = /* @__PURE__ */ dual(3, (self2, zero2, pf) => {
  let accumulator = zero2;
  let cause = self2;
  const causes = [];
  while (cause !== undefined) {
    const option = pf(accumulator, cause);
    accumulator = isSome2(option) ? option.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      default: {
        cause = undefined;
        break;
      }
    }
    if (cause === undefined && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext2 = /* @__PURE__ */ dual(3, (self2, context, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context, cause.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context, cause.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context, cause.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either2 = output.pop();
    switch (either2._tag) {
      case "Left": {
        switch (either2.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.sequentialCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.parallelCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either2.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === undefined) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join(`
`);
};
var renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split(`
`);
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length;i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};

class PrettyError extends globalThis.Error {
  span = undefined;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new PrettyError(originalError.cause)
    } : undefined);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
}
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {}
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => new WeakMap);
var prettyErrorStack = (message, stack, span2) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split(`
`) : stack.split(`
`);
  for (let i = 1;i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span2) {
    let current = span2;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match6 = false;
          for (const [, location2] of locationMatchAll) {
            match6 = true;
            out.push(`    at ${current.name} (${location2})`);
          }
          if (!match6) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join(`
`);
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause) => reduceWithContext2(cause, undefined, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect) => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
};

// node_modules/effect/dist/esm/internal/singleShotGen.js
class SingleShotGen2 {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(this.self);
  }
}

// node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
};
var runRequestBlock = (blockedRequests) => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");

class RevertFlags {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch8, op) {
    this.patch = patch8;
    this.op = op;
  }
}

class EffectPrimitive {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveFailure {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string2(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveSuccess {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string2(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap8(acquire, (a) => flatMap8(exit(suspend(() => restore(use(a)))), (exit) => {
  return suspend(() => release(a, exit)).pipe(matchCauseEffect({
    onFailure: (cause) => {
      switch (exit._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit.effect_instruction_i0, cause));
        case OP_SUCCESS:
          return failCause(cause);
      }
    },
    onSuccess: () => exit
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self2, value) => flatMap8(self2, () => succeed(value)));
var asVoid = (self2) => as(self2, undefined);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = undefined;
  effect.effect_instruction_i0 = (resume) => {
    cancelerRef = register(resume);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume, blockingOn = none4) => {
  return custom(resume, function() {
    let backingResume = undefined;
    let pendingEffect = undefined;
    function proxyResume(effect2) {
      if (backingResume) {
        backingResume(effect2);
      } else if (pendingEffect === undefined) {
        pendingEffect = effect2;
      }
    }
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = (resume2) => {
      backingResume = resume2;
      if (pendingEffect) {
        resume2(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = undefined;
    let controllerRef = undefined;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController;
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect = new EffectPrimitive(OP_ON_FAILURE);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = f;
  return effect;
});
var catchAll = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause(self2, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return predicate(either2.left) ? f(either2.left) : failCause(cause);
    case "Right":
      return failCause(either2.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return pipe(pf(either2.left), getOrElse(() => failCause(cause)));
    case "Right":
      return failCause(either2.right);
  }
}));
var checkInterruptible = (f) => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags)));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span2) => {
  if (isSome2(span2)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span2.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate) => flatMap8(sync(evaluate), die2);
var either2 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self2) => matchCause(self2, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
var failSync = (evaluate) => flatMap8(sync(evaluate), fail2);
var failCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var failCauseSync = (evaluate) => flatMap8(sync(evaluate), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap8 = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = f;
  return effect;
});
var andThen2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume) => {
      b.then((a2) => resume(succeed(a2)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self2) => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self2;
  return effect;
};
var flatten5 = (self2) => flatMap8(self2, identity);
var flip = (self2) => matchEffect(self2, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause) => succeed(options.onFailure(cause)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
var matchEffect = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(electFailures(cause));
    }
    const failures2 = failures(cause);
    if (failures2.length > 0) {
      return options.onFailure(unsafeHead2(failures2));
    }
    return failCause(cause);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable(self2);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable(self2);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = /* @__PURE__ */ dual((args) => typeof args[0] === "boolean" || isEffect(args[0]), (self2, options) => isEffect(self2) ? flatMap8(self2, (b) => b ? options.onTrue() : options.onFalse()) : self2 ? options.onTrue() : options.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap8(fiberId, (fiberId2) => interruptWith(fiberId2));
var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
var interruptible2 = (self2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = () => self2;
  return effect;
};
var interruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask((restore) => flatMap8(exit(restore(self2)), (exit2) => deferredDone(deferred, exit2))));
var map12 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (a) => sync(() => f(a))));
var mapBoth2 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const either3 = failureOrCause(cause);
    switch (either3._tag) {
      case "Left": {
        return failSync(() => f(either3.left));
      }
      case "Right": {
        return failCause(either3.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit2) => exitIsSuccess(exit2) ? void_ : cleanup(exit2.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
  onFailure: (cause) => isInterruptedOnly(cause) ? asVoid(cleanup(interruptors(cause))) : void_,
  onSuccess: () => void_
})));
var orElse2 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
var orDie = (self2) => orDieWith(self2, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var partitionMap2 = partitionMap;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status) => succeed(status.runtimeFlags));
var succeed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var suspend = (evaluate) => {
  const effect = new EffectPrimitive(OP_COMMIT);
  effect.commit = evaluate;
  return effect;
};
var sync = (thunk) => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = thunk;
  return effect;
};
var tap = /* @__PURE__ */ dual((args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && ("onlyEffect" in args[1])), (self2, f) => flatMap8(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume) => {
      b.then((_) => resume(succeed(a)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = () => self2;
  return effect;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var void_ = /* @__PURE__ */ succeed(undefined);
var updateRuntimeFlags = (patch8) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch8;
  effect.effect_instruction_i1 = undefined;
  return effect;
};
var whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => {
  if (b) {
    return pipe(self2, map12(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
};
var fromIterator = (iterator) => suspend(() => {
  const effect = new EffectPrimitive(OP_ITERATOR);
  effect.effect_instruction_i0 = iterator();
  return effect;
});
var gen = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args) {
  return fromIterator(() => body.apply(this, args));
} : function(...args) {
  let effect = fromIterator(() => body.apply(this, args));
  for (const x of pipeables) {
    effect = x(effect, ...args);
  }
  return effect;
}, "length", {
  value: body.length,
  configurable: true
});
var withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update3) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = update3;
  effect.effect_instruction_i1 = () => self2;
  return effect;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerEnabled, enabled2));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
var zip2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a) => map12(that, (b) => [a, b])));
var zipLeft = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a) => as(that, a)));
var zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, () => that));
var zipWith3 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap8(self2, (a) => map12(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {}, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self2) => flatMap8(fiberId, (fiberId2) => pipe(self2, interruptAsFiber(fiberId2)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId2) => flatMap8(self2.interruptAsFork(fiberId2), () => self2.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 50000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 40000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 30000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 20000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  _A: (_) => _
};
var fiberRefGet = (self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(fiberRefGet(self2), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self2, value) => fiberRefModify(self2, () => [undefined, value]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self2));
  state.setFiberRef(self2, a);
  return succeed(b);
}));
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self2, value) => acquireUseRelease(zipLeft(fiberRefGet(self2), fiberRefSet(self2, value)), () => use, (oldValue) => fiberRefSet(self2, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use, self2, f(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update2(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ2 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ2 = readonlyArray(update2());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ2 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first, second) => options.differ.combine(first, second),
    patch: (patch8) => (oldValue) => options.differ.patch(patch8, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty5()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty10()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty11()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentSchedulingPriority, scheduler));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty3()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty21, {
  fork: () => empty21,
  join: (parent, _) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty10()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty6()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self2, finalizer) => self2.addFinalizer(() => asVoid(finalizer));
var scopeAddFinalizerExit = (self2, finalizer) => self2.addFinalizer(finalizer);
var scopeClose = (self2, exit2) => self2.close(exit2);
var scopeFork = (self2, strategy) => self2.fork(strategy);
var causeSquash = (self2) => {
  return causeSquashWith(identity)(self2);
};
var causeSquashWith = /* @__PURE__ */ dual(2, (self2, f) => {
  const option = pipe(self2, failureOption, map2(f));
  switch (option._tag) {
    case "None": {
      return pipe(defects(self2), head2, match2({
        onNone: () => {
          const interrupts = fromIterable(interruptors(self2)).flatMap((fiberId2) => fromIterable(ids2(fiberId2)).map((id) => `#${id}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : undefined);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ function() {

  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message)
        obj.message = this.message;
      if (this.cause)
        obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split(`
`).slice(1).join(`
`)}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
}();
var makeException = (proto3, tag) => {

  class Base2 extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base2.prototype, proto3);
  Base2.prototype.name = tag;
  return Base2;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format2(duration)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {

  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause, message) {
      super(message ?? "An unknown error occurred", {
        cause
      });
      this.error = cause;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u) => isEffect(u) && ("_tag" in u) && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self2) => self2._tag === "Failure";
var exitIsSuccess = (self2) => self2._tag === "Success";
var exitIsInterrupted = (self2) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return isInterrupted(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return false;
  }
};
var exitAs = /* @__PURE__ */ dual(2, (self2, value) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value);
    }
  }
});
var exitAsVoid = (self2) => exitAs(self2, undefined);
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error) => exitFailCause(fail(error));
var exitFailCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var exitFlatMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self2.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self2) => pipe(self2, exitFlatMap(identity));
var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
var exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self2.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self2.effect_instruction_i0, map11(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self2.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitSucceed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var exitVoid = /* @__PURE__ */ exitSucceed(undefined);
var exitZip = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self2.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list2, value) => pipe(list2, prepend2(value)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk) => toReadonlyArray(chunk)), some2);
};
var deferredUnsafeMake = (fiberId2) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make13(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId2
  };
  return _deferred;
};
var deferredMake = () => flatMap8(fiberId, (id) => deferredMakeAs(id));
var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
var deferredAwait = (self2) => asyncInterrupt((resume) => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume);
      return deferredInterruptJoiner(self2, resume);
    }
  }
}, self2.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self2, effect) => intoDeferred(effect, self2));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect) => sync(() => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set3(self2.state, done(effect));
      for (let i = 0, len = state.joiners.length;i < len; i++) {
        state.joiners[i](effect);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self2, exit2) => deferredCompleteWith(self2, exit2));
var deferredFail = /* @__PURE__ */ dual(2, (self2, error) => deferredCompleteWith(self2, fail2(error)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause) => deferredCompleteWith(self2, failCause(cause)));
var deferredInterrupt = (self2) => flatMap8(fiberId, (fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self2, fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
var deferredIsDone = (self2) => sync(() => get6(self2.state)._tag === OP_STATE_DONE);
var deferredPoll = (self2) => sync(() => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some2(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
});
var deferredSucceed = /* @__PURE__ */ dual(2, (self2, value) => deferredCompleteWith(self2, succeed(value)));
var deferredUnsafeDone = (self2, effect) => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    set3(self2.state, done(effect));
    for (let i = 0, len = state.joiners.length;i < len; i++) {
      state.joiners[i](effect);
    }
  }
};
var deferredInterruptJoiner = (self2, joiner) => sync(() => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f) => flatMap8(context(), f);
var provideContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocally(currentContext, context2)(self2));
var provideSomeContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context2))(self2));
var mapInputContext = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context2) => provideContext(self2, f(context2))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => flatMap8(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options) => filterEffectOrElse(self2, {
  predicate: options.predicate,
  orElse: (a) => fail2(options.orFailWith(a))
}));
var currentSpanFromFiber = (fiber) => {
  const span2 = fiber.currentSpan;
  return span2 !== undefined && span2._tag === "Span" ? some2(span2) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map,
  links: [],
  kind: "internal",
  attribute() {},
  event() {},
  end() {},
  addLinks() {}
};
var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

// node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration) {
    const millis2 = toMillis(duration);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === undefined) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();

class ClockImpl {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration) {
    return async_((resume) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_), duration);
      return asVoid(sync(canceler));
    });
  }
}
var make20 = () => new ClockImpl;

// node_modules/effect/dist/esm/Number.js
var Order2 = number3;
var nextPow2 = (n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
var parse = (s) => {
  if (s === "NaN") {
    return some(NaN);
  }
  if (s === "Infinity") {
    return some(Infinity);
  }
  if (s === "-Infinity") {
    return some(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some(n);
};
var round = /* @__PURE__ */ dual(2, (self2, precision) => {
  const factor = Math.pow(10, precision);
  return Math.round(self2 * factor) / factor;
});

// node_modules/effect/dist/esm/RegExp.js
var escape = (string4) => string4.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty22 = {
  _tag: "Empty"
};
var patch8 = /* @__PURE__ */ dual(2, (path, patch9) => {
  let input = of3(patch9);
  let output = path;
  while (isCons(input)) {
    const patch10 = input.head;
    switch (patch10._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch10.first, cons(patch10.second, input.tail));
        break;
      }
      case "MapName": {
        output = map5(output, patch10.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch10.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch10.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make21 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split2 = true) => options.load(path, config, split2),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make21({
  load: (config) => flatMap8(fromFlatLoop(flat, empty3(), config, false), (chunk) => match2(head(chunk), {
    onNone: () => fail2(MissingData(empty3(), `Expected a single value having structure: ${config}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && ("env" in process) && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split2 = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap8((value) => parsePrimitive(value, path, primitive, seqDelim, split2)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current = getEnv();
    const keys4 = Object.keys(current);
    const keyPaths = keys4.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0;i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty22
  }));
};
var extend2 = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config, split2) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split2));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split2)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split2), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split2));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split2), flatMap8(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split2));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.load(prefix2, op, split2), flatMap8((values3) => {
        if (values3.length === 0) {
          const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values3);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap8((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap8(indicesFrom), flatMap8((indices) => {
        if (indices.length === 0) {
          return suspend(() => map12(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map12((chunkChunk) => {
          const flattened = flatten(chunkChunk);
          if (flattened.length === 0) {
            return of(empty3());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap8((keys4) => {
        return pipe(keys4, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split2)), map12((matrix) => {
          if (matrix.length === 0) {
            return of(empty10());
          }
          return pipe(transpose(matrix), map5((values3) => fromIterable6(zip(fromIterable(keys4), values3))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split2), either2, flatMap8((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split2), either2, flatMap8((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail3 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend2(fail3, fail3, pipe(left3.right, map5(right2)), pipe(right3.right, map5(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map12(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
var splitPathString = (text, delim) => {
  const split2 = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split2;
};
var parsePrimitive = (text, path, primitive, delimiter, split2) => {
  if (!split2) {
    return pipe(primitive.parse(text), mapBoth2({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError(prefixed(path)));
};
var transpose = (array4) => {
  return Object.keys(array4[0]).map((column) => array4.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
  onFailure: () => empty3(),
  onSuccess: sort(Order2)
}), either2, map12(merge));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match6 = str.match(QUOTED_INDEX_REGEX);
  if (match6 !== null) {
    const matchedIndex = match6[2];
    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId8]: TypeId8,
  assert(condition, ...args) {
    return sync(() => {
      console.assert(condition, ...args);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args) {
    return sync(() => {
      console.debug(...args);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args) {
    return sync(() => {
      console.dirxml(...args);
    });
  },
  error(...args) {
    return sync(() => {
      console.error(...args);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args) {
    return sync(() => {
      console.info(...args);
    });
  },
  log(...args) {
    return sync(() => {
      console.log(...args);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args) {
    return sync(() => {
      console.timeLog(label, ...args);
    });
  },
  trace(...args) {
    return sync(() => {
      console.trace(...args);
    });
  },
  warn(...args) {
    return sync(() => {
      console.warn(...args);
    });
  },
  unsafe: console
};

// node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");

class RandomImpl {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map12(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min4, max4) {
    return map12(this.next, (n) => (max4 - min4) * n + min4);
  }
  nextIntBetween(min4, max4) {
    return sync(() => this.PRNG.integer(max4 - min4) + min4);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
}
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap8((buffer) => {
    const numbers = [];
    for (let i = buffer.length;i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map12((k) => swap(buffer, n - 1, k)))), as(fromIterable2(buffer)));
  })));
};
var swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
};
var make22 = (seed) => new RandomImpl(hash(seed));

// node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make23 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length2) {
    let result = "";
    for (let i = 0;i < length2; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();

class NativeSpan {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context2, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context2;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map;
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit2) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit2,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
}
var nativeTracer = /* @__PURE__ */ make23({
  span: (name, parent, context2, links, startTime, kind) => new NativeSpan(name, parent, context2, links, startTime, kind),
  context: (f) => f()
});
var addSpanStackTrace = (options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error;
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== undefined) {
        const stack = traceError.stack.split(`
`);
        if (stack[3] !== undefined) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty5(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make22(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration) => {
  const decodedDuration = decode(duration);
  return clockWith((clock) => clock.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock) => clock.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock) => clock.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect));
var withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self2));
var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_) => _.load(config2));
var randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
var withRandom = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect));
var tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
var withTracer = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect));

// node_modules/effect/dist/esm/Boolean.js
var not = (self2) => !self2;

// node_modules/effect/dist/esm/Deferred.js
var DeferredTypeId2 = DeferredTypeId;
var make24 = deferredMake;
var _await = deferredAwait;
var complete = deferredComplete;
var done2 = deferredDone;
var fail3 = deferredFail;
var failCause2 = deferredFailCause;
var interrupt3 = deferredInterrupt;
var isDone = deferredIsDone;
var poll = deferredPoll;
var succeed2 = deferredSucceed;
var unsafeMake3 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
class Class extends Base2 {
}

// node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self2) => self2._tag === OP_SEQUENTIAL2;
var isParallel = (self2) => self2._tag === OP_PARALLEL2;

// node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake4(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty23() {
  return unsafeMake4(new Map);
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");

class FiberRefsImpl {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = undefined;
  while (ret === undefined) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self2, fiberId2, that) => {
  const parentFiberRefs = new Map(self2.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId2)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch9 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId2)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId2, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
  const map13 = new Map;
  unsafeForkAs(self2, map13, childId);
  return new FiberRefsImpl(map13);
});
var unsafeForkAs = (self2, map13, fiberId2) => {
  self2.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map13.set(fiberRef, stack);
    } else {
      map13.set(fiberRef, [[fiberId2, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self2) => fromIterable5(self2.locals.keys());
var setAll = (self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef)));
var delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  const locals = new Map(self2.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get8 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  if (!self2.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self2.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get8(self2, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self2, {
  fiberId: fiberId2,
  fiberRef,
  value
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map([[fiberRef, [[fiberId2, value]]]]));
  }
  const locals = new Map(self2.locals);
  unsafeUpdateAs(locals, fiberId2, fiberRef, value);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId2, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId2)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId2, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId2, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId2, value]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self2, {
  entries: entries2,
  forkAs: forkAs2
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries2));
  }
  const locals = new Map(self2.locals);
  if (forkAs2 !== undefined) {
    unsafeForkAs(self2, locals, forkAs2);
  }
  entries2.forEach(([fiberRef, values3]) => {
    if (values3.length === 1) {
      unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
    } else {
      values3.forEach(([fiberId2, value]) => {
        unsafeUpdateAs(locals, fiberId2, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/effect/dist/esm/FiberRefs.js
var get9 = get8;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var empty24 = empty23;

// node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty25 = {
  _tag: OP_EMPTY2
};
var diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch9 = empty25;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch9 = combine10({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch9);
      }
    } else {
      patch9 = combine10({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch9);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch9 = combine10({
      _tag: OP_REMOVE,
      fiberRef
    })(patch9);
  }
  return patch9;
};
var combine10 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: OP_AND_THEN,
  first: self2,
  second: that
}));
var patch9 = /* @__PURE__ */ dual(3, (self2, fiberId2, oldValue) => {
  let fiberRefs2 = oldValue;
  let patches = of(self2);
  while (isNonEmptyReadonlyArray(patches)) {
    const head3 = headNonEmpty(patches);
    const tail2 = tailNonEmpty(patches);
    switch (head3._tag) {
      case OP_EMPTY2: {
        patches = tail2;
        break;
      }
      case OP_ADD: {
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.value
        });
        patches = tail2;
        break;
      }
      case OP_REMOVE: {
        fiberRefs2 = delete_(fiberRefs2, head3.fiberRef);
        patches = tail2;
        break;
      }
      case OP_UPDATE: {
        const value = getOrDefault(fiberRefs2, head3.fiberRef);
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.fiberRef.patch(head3.patch)(value)
        });
        patches = tail2;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head3.first)(prepend(head3.second)(tail2));
        break;
      }
    }
  }
  return fiberRefs2;
});

// node_modules/effect/dist/esm/FiberRefsPatch.js
var diff9 = diff8;
var patch10 = patch9;

// node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string2(`${FiberStatusSymbolKey}-${OP_DONE}`);

class Done {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
}

class Running {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
}

class Suspended {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
}
var done3 = /* @__PURE__ */ new Done;
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self2) => self2._tag === OP_DONE;

// node_modules/effect/dist/esm/FiberStatus.js
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isDone3 = isDone2;

// node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var Order3 = /* @__PURE__ */ pipe(Order2, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan3 = /* @__PURE__ */ greaterThan(Order3);
var fromLiteral = (literal) => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// node_modules/effect/dist/esm/Micro.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};

class MicroCauseImpl extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split(`
`).length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(`
`).slice(0, messageLines + 3).join(`
`)}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join(`
    `)}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
}
class Die extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
}
var causeDie = (defect, traces = []) => new Die(defect, traces);

class Interrupt extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
}
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self2) => self2._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};

class MicroFiberImpl {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context2, interruptible3 = true) {
    this.context = context2;
    this.interruptible = interruptible3;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== undefined) {
      const yielded = this._yielded;
      this._yielded = undefined;
      yielded();
    }
    const exit2 = this.runLoop(effect);
    if (exit2 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== undefined) {
      return this.evaluate(flatMap9(interruptChildren, () => exit2));
    }
    this._exit = exit2;
    for (let i = 0;i < this._observers.length; i++) {
      this._observers[i](exit2);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap9(yieldNow2, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = undefined;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error) {
      if (!hasProperty(current, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie2(error);
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op)
        return;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont)
        return {
          [symbol3]: cont
        };
      if (op[symbol3])
        return op;
    }
  }
  _yielded = undefined;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= new Set;
  }
}
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: undefined
}));
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId9]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : undefined
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto = makePrimitiveProto(options);
  return function() {
    const self2 = Object.create(Proto);
    self2[args] = options.single === false ? arguments : arguments[0];
    return self2;
  };
};
var makeExit = (options) => {
  const Proto = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string2(options.op))(hash(this[args])));
    }
  };
  return function(value) {
    const self2 = Object.create(Proto);
    self2[args] = value;
    self2[successCont] = undefined;
    self2[failureCont] = undefined;
    self2[ensureCont] = undefined;
    return self2;
  };
};
var succeed3 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause3 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed)
        return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_2 = /* @__PURE__ */ succeed3(undefined);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var flatMap9 = /* @__PURE__ */ dual(2, (self2, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self2;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed3;
var exitFailCause2 = failCause3;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(undefined);
var setImmediate2 = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);

class MicroSchedulerDefault {
  tasks = [];
  running = false;
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate2(this.afterScheduled);
    }
  }
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length;i < len; i++) {
      tasks[i]();
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
}
var updateContext = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self2, () => {
    fiber.context = prev;
    return void_2;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
}
class CurrentScheduler extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault
})) {
}
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options) => {
  const primitive = Object.create(OnSuccessAndFailureProto);
  primitive[args] = self2;
  primitive[successCont] = options.onSuccess;
  primitive[failureCont] = options.onFailure;
  return primitive;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var onExit2 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
  onFailure: (cause) => flatMap9(f(exitFailCause2(cause)), () => failCause3(cause)),
  onSuccess: (a) => flatMap9(f(exitSucceed2(a)), () => succeed3(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self2) => withMicroFiber((fiber) => {
  if (fiber.interruptible)
    return self2;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted)
    return exitInterrupt2;
  return self2;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible)
    return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var runFork = (effect, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault));
  fiber.evaluate(effect);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};

// node_modules/effect/dist/esm/Readable.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId10]: TypeId10,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  _A: (_) => _
};

class RefImpl extends Class {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = get6(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        set3(a)(this.ref);
      }
      return b;
    });
  }
}
var unsafeMake5 = (value) => new RefImpl(make13(value));
var make25 = (value) => sync(() => unsafeMake5(value));
var get10 = (self2) => self2.get;
var set5 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [undefined, value]));
var getAndSet2 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify((a) => [a, value]));
var modify3 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
var update3 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [undefined, f(a)]));
var updateAndGet2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => {
  const result = f(a);
  return [result, result];
}));

// node_modules/effect/dist/esm/Ref.js
var make26 = make25;
var get11 = get10;
var getAndSet3 = getAndSet2;
var modify4 = modify3;
var set6 = set5;
var update4 = update3;
var updateAndGet3 = updateAndGet2;

// node_modules/effect/dist/esm/Scheduler.js
class PriorityBuckets {
  buckets = [];
  scheduleTask(task, priority) {
    const length2 = this.buckets.length;
    let bucket = undefined;
    let index = 0;
    for (;index < length2; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length2) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
}

class MixedScheduler {
  maxNextTickBeforeTimer;
  running = false;
  tasks = /* @__PURE__ */ new PriorityBuckets;
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0;i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));

class SyncScheduler {
  tasks = /* @__PURE__ */ new PriorityBuckets;
  deferred = false;
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0;i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
}
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentScheduler, scheduler));

// node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map));

// node_modules/effect/dist/esm/internal/concurrency.js
var match7 = (concurrency, sequential4, unbounded, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return unbounded();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded() : concurrency2 > 1 ? bounded(concurrency2) : sequential4());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential4();
  }
};
var matchSimple = (concurrency, sequential4, concurrent) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
    default:
      return concurrency > 1 ? concurrent() : sequential4();
  }
};

// node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// node_modules/effect/dist/esm/internal/logSpan.js
var make27 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now) => (self2) => {
  const label = formatLabel(self2.label);
  return `${label}=${now - self2.startTime}ms`;
};

// node_modules/effect/dist/esm/LogSpan.js
var make28 = make27;

// node_modules/effect/dist/esm/Tracer.js
var ParentSpan = spanTag;
var tracerWith2 = tracerWith;

// node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);

class MetricLabelImpl {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string2(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make29 = (key, value) => {
  return new MetricLabelImpl(key, value);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations) => Object.entries(args2[1]).reduce((acc, [key, value]) => set4(acc, key, value), annotations));
});
var asSome = (self2) => map12(self2, some2);
var asSomeError = (self2) => mapError(self2, some2);
var try_ = (arg) => {
  let evaluate2;
  let onFailure = undefined;
  if (typeof arg === "function") {
    evaluate2 = arg;
  } else {
    evaluate2 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate2));
    } catch (error) {
      return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = /* @__PURE__ */ dual(3, (self2, tag, options) => catchAll(self2, (e) => {
  if (hasProperty(e, tag) && e[tag] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause) => {
  const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
  switch (option._tag) {
    case "None": {
      return failCause(cause);
    }
    case "Some": {
      return f(option.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const option = f(cause);
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        return option.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
  const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
  switch (option._tag) {
    case "None": {
      return failCause(cause);
    }
    case "Some": {
      const optionEffect = pf(option.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, ...args2) => {
  const f = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = (e) => {
      const tag = hasProperty(e, "_tag") ? e["_tag"] : undefined;
      if (!tag)
        return false;
      for (let i = 0;i < args2.length - 1; i++) {
        if (args2[i] === tag)
          return true;
      }
      return false;
    };
  }
  return catchIf(self2, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
  let keys4;
  return catchIf(self2, (e) => {
    keys4 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys4.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self2) => matchCause(self2, {
  onFailure: identity,
  onSuccess: () => empty21
});
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self2, duration) => zipRight(sleep2(duration), self2));
var descriptorWith = (f) => withFiberRuntime((state, status) => f({
  id: state.id(),
  status,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor) => size3(descriptor.interruptors) > 0 ? interrupt2 : void_);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = (self2) => summarized(self2, fiberRefs2, diff8);
var diffFiberRefsAndRuntimeFlags = (self2) => summarized(self2, zip2(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff8(refs, refsNew), diff7(flags, flagsNew)]);
var Do2 = /* @__PURE__ */ succeed({});
var bind3 = /* @__PURE__ */ bind(map12, flatMap8);
var bindTo3 = /* @__PURE__ */ bindTo(map12);
var let_3 = /* @__PURE__ */ let_(map12);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap8(dropping, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return map12(dropping, () => builder);
}));
var dropWhile3 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap8(dropping, (d) => map12(d ? predicate(a, index) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map12(dropping, () => builder);
}));
var contextWith = (f) => map12(context(), f);
var eventually = (self2) => orElse2(self2, () => flatMap8(yieldNow(), () => eventually(self2)));
var filterMap5 = /* @__PURE__ */ dual(2, (elements, pf) => map12(forEachSequential(elements, identity), filterMap2(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith2) => filterOrElse(self2, predicate, (a) => dieSync(() => orDieWith2(a))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse3) => flatMap8(self2, (a) => predicate(a) ? succeed(a) : orElse3(a)));
var liftPredicate2 = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
var filterOrFail = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a) => orFailWith === undefined ? fail2(new NoSuchElementException) : failSync(() => orFailWith(a))));
var findFirst5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, predicate, next.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index, f, value) => flatMap8(f(value, index), (result) => {
  if (result) {
    return succeed(some2(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index + 1, f, next.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
});
var flipWith = /* @__PURE__ */ dual(2, (self2, f) => flip(f(flip(self2))));
var match8 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index, f) => {
  const next = iterator.next();
  return next.done ? succeed(true) : flatMap8(f(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
};
var forever = (self2) => {
  const loop = flatMap8(flatMap8(self2, () => yieldNow()), () => loop);
  return loop;
};
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head3 = (self2) => flatMap8(self2, (as2) => {
  const iterator = as2[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return fail2(new NoSuchElementException);
  }
  return succeed(next.value);
});
var ignore = (self2) => match8(self2, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self2) => matchCauseEffect(self2, {
  onFailure: (cause2) => logDebug(cause2, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure = (self2) => match8(self2, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess = (self2) => match8(self2, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap8(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause2 = undefined;
  for (let i = 0, len = message.length;i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause2 !== undefined) {
        cause2 = sequential(cause2, msg);
      } else {
        cause2 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause2 === undefined) {
    cause2 = empty21;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause2, levelOption);
    return void_;
  });
};
var log = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect, label) => flatMap8(currentTimeMillis2, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend3(make28(label, now)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map12(loopInternal(initial, options.while, options.step, options.body), fromIterable);
var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), (a) => map12(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty11()));
var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_);
var mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index = i++;
    const value = next.value;
    result = flatMap8(result, (state) => map12(f(state, value, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map12(result, (z) => [z, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var memoize = (self2) => pipe(deferredMake(), flatMap8((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred), once, map12((complete2) => zipRight(complete2, pipe(deferredAwait(deferred), flatMap8(([patch11, a]) => as(zip2(patchFiberRefs(patch11[0]), updateRuntimeFlags(patch11[1])), a))))))));
var merge5 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate = (self2) => map12(self2, (b) => !b);
var none6 = (self2) => flatMap8(self2, (option) => {
  switch (option._tag) {
    case "None":
      return void_;
    case "Some":
      return fail2(new NoSuchElementException);
  }
});
var once = (self2) => map12(make26(true), (ref) => asVoid(whenEffect(self2, getAndSet3(ref, false))));
var option = (self2) => matchEffect(self2, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some2(a))
});
var orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate2) => orElse2(self2, () => failSync(evaluate2)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate2) => orElse2(self2, () => sync(evaluate2)));
var parallelErrors = (self2) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const errors = fromIterable(failures(cause2));
    return errors.length === 0 ? failCause(cause2) : fail2(errors);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch11) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch11, patch9(fiberId2, fiberRefs3)));
var promise = (evaluate2) => evaluate2.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate2(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
}) : async_((resolve) => {
  try {
    evaluate2().then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
});
var provideService = /* @__PURE__ */ dual(3, (self2, tag, service) => contextWithEffect((env) => provideContext(self2, add2(env, tag, service))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag, effect) => contextWithEffect((env) => flatMap8(effect, (service) => provideContext(self2, pipe(env, add2(tag, service))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce11 = /* @__PURE__ */ dual(3, (elements, zero2, f) => fromIterable(elements).reduce((acc, el, i) => flatMap8(acc, (a) => f(a, el, i)), succeed(zero2)));
var reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero2, f) => fromIterable(elements).reduceRight((acc, el, i) => flatMap8(acc, (a) => f(el, a, i)), succeed(zero2)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero2, options) => flatMap8(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero2, options.while, options.body)));
var reduceWhileLoop = (iterator, index, state, predicate, f) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return flatMap8(f(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
};
var repeatN = /* @__PURE__ */ dual(2, (self2, n) => suspend(() => repeatNLoop(self2, n)));
var repeatNLoop = (self2, n) => flatMap8(self2, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self2, n - 1)));
var sandbox = (self2) => matchCauseEffect(self2, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = (value) => succeed(some2(value));
var summarized = /* @__PURE__ */ dual(3, (self2, summary, f) => flatMap8(summary, (start) => flatMap8(self2, (value) => map12(summary, (end) => [f(start, end), value]))));
var tagMetrics = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make29(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make29(k, v)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    effect = flatMap8(effect, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map12(effect, () => builder);
}));
var takeWhile3 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    taking = flatMap8(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map12((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map12(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left": {
        return zipRight(onFailure(either3.left), failCause(cause2));
      }
      case "Right": {
        return failCause(cause2);
      }
    }
  },
  onSuccess: (a) => as(onSuccess(a), a)
}));
var tapDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause2) => match2(keepDefects(cause2), {
  onNone: () => failCause(cause2),
  onSome: (a) => zipRight(f(a), failCause(cause2))
})));
var tapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left":
        return zipRight(f(either3.left), failCause(cause2));
      case "Right":
        return failCause(cause2);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self2, k, f) => tapError(self2, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause2) => zipRight(f(cause2), failCause(cause2)),
  onSuccess: succeed
}));
var timed = (self2) => timedWith(self2, currentTimeNanos2);
var timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start, end) => nanos(end - start)));
var tracerWith3 = tracerWith2;
var tracer = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate2;
  let catcher = undefined;
  if (typeof arg === "function") {
    evaluate2 = arg;
  } else {
    evaluate2 = arg.try;
    catcher = arg.catch;
  }
  const fail4 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate2.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate2(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(fail4(e)));
      } catch (e) {
        resolve(fail4(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate2().then((a) => resolve(exitSucceed(a)), (e) => resolve(fail4(e)));
    } catch (e) {
      resolve(fail4(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => try_({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
var unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => b ? succeedNone : asSome(self2)));
var unsandbox = (self2) => mapErrorCause(self2, flatten4);
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
});
var updateService = /* @__PURE__ */ dual(3, (self2, tag, f) => mapInputContext(self2, (context2) => add2(context2, tag, f(unsafeGet3(context2, tag)))));
var when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map12(self2, some2) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap8(fiberRefGet(fiberRef), (s) => predicate(s) ? map12(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self2, ref, predicate) => flatMap8(get11(ref), (s) => predicate(s) ? map12(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
var serviceFunctionEffect = (getService, f) => (...args2) => flatMap8(getService, (a) => f(a)(...args2));
var serviceFunction = (getService, f) => (...args2) => map12(getService, (a) => f(a)(...args2));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap8(getService, (s) => s[prop](...args2));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap8(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag) => map12(context(), getOption2(tag));
var serviceOptional = (tag) => flatMap8(context(), getOption2(tag));
var annotateCurrentSpan = function() {
  const args2 = arguments;
  return ignore(flatMap8(currentSpan, (span2) => sync(() => {
    if (typeof args2[0] === "string") {
      span2.attribute(args2[0], args2[1]);
    } else {
      for (const key in args2[0]) {
        span2.attribute(key, args2[0][key]);
      }
    }
  })));
};
var linkSpanCurrent = function() {
  const args2 = arguments;
  const links = Array.isArray(args2[0]) ? args2[0] : [{
    _tag: "SpanLink",
    span: args2[0],
    attributes: args2[1] ?? {}
  }];
  return ignore(flatMap8(currentSpan, (span2) => sync(() => span2.addLinks(links))));
};
var annotateSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations) => Object.entries(args2[1]).reduce((acc, [key, value]) => set4(acc, key, value), annotations));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap8(/* @__PURE__ */ context(), (context2) => {
  const span2 = context2.unsafeMap.get(spanTag.key);
  return span2 !== undefined && span2._tag === "Span" ? succeed(span2) : fail2(new NoSuchElementException);
});
var linkSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, span2, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span2,
  attributes: attributes ?? {}
})));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get3(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
var unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
  const context2 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context2, spanTag));
  let span2;
  if (disablePropagation) {
    span2 = noopSpan({
      name,
      parent,
      context: add2(options.context ?? empty5(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer2 = get3(services, tracerTag);
    const clock2 = get3(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get9(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get9(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty3();
    span2 = tracer2.span(name, parent, options.context ?? empty5(), links, timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint02, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach5(annotationsFromEnv.value, (value, key) => span2.attribute(key, value));
    }
    if (options.attributes !== undefined) {
      Object.entries(options.attributes).forEach(([k, v]) => span2.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span2, options.captureStackTrace);
  }
  return span2;
};
var makeSpan = (name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
};
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = (span2, exit2, clock2, timingEnabled) => sync(() => {
  if (span2.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit2) && spanToTrace.has(span2)) {
    span2.attribute("code.stacktrace", spanToTrace.get(span2)());
  }
  span2.end(timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint02, exit2);
});
var useSpan = (name, ...args2) => {
  const options = addSpanStackTrace(args2.length === 1 ? undefined : args2[0]);
  const evaluate2 = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span2 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock2 = get3(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate2(span2), (exit2) => endSpan(span2, exit2, clock2, timingEnabled));
  });
};
var withParentSpan = /* @__PURE__ */ dual(2, (self2, span2) => provideService(self2, spanTag, span2));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return useSpan(name, options, (span2) => withParentSpan(self2, span2));
  }
  return (self2) => useSpan(name, options, (span2) => withParentSpan(self2, span2));
};
var functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error;
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error.stack) {
        const stack = error.stack.trim().split(`
`);
        cache = stack.slice(2).join(`
`).trim();
        return cache;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
var fromNullable3 = (value) => value == null ? fail2(new NoSuchElementException) : succeed(value);
var optionFromOptional = (self2) => catchAll(map12(self2, some2), (error) => isNoSuchElementException(error) ? succeedNone : fail2(error));

// node_modules/effect/dist/esm/Exit.js
var isExit = exitIsExit;
var isFailure2 = exitIsFailure;
var isSuccess2 = exitIsSuccess;
var isInterrupted2 = exitIsInterrupted;
var asVoid2 = exitAsVoid;
var all2 = exitCollectAll;
var die3 = exitDie;
var fail4 = exitFail;
var failCause4 = exitFailCause;
var flatten6 = exitFlatten;
var interrupt4 = exitInterrupt;
var map13 = exitMap;
var mapBoth3 = exitMapBoth;
var match9 = exitMatch;
var succeed4 = exitSucceed;
var void_3 = exitVoid;
var zip3 = exitZip;
var zipRight2 = exitZipRight;

// node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause2) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause2
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect) => ({
  _tag: OP_RESUME,
  effect
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);

class Global {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set;
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
}

class Local {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId2, parent) {
    this.fiberId = fiberId2;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
}
var unsafeMake6 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global);

// node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  _E: (_) => _,
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var _await2 = (self2) => self2.await;
var inheritAll = (self2) => self2.inheritAll;
var interruptAllAs = /* @__PURE__ */ dual(2, (fibers, fiberId2) => pipe(forEachSequentialDiscard(fibers, interruptAsFork(fiberId2)), zipRight(pipe(fibers, forEachSequentialDiscard(_await2)))));
var interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId2) => self2.interruptAsFork(fiberId2));
var join2 = (self2) => zipLeft(flatten5(self2.await), self2.inheritAll);
var _never = {
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: () => never
};
var poll2 = (self2) => self2.poll;
var currentFiberURI = "effect/FiberCurrent";
var getCurrentFiber = () => fromNullable(globalThis[currentFiberURI]);

// node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  _Message: (_) => _,
  _Output: (_) => _
};
var makeLogger = (log2) => ({
  [LoggerTypeId]: loggerVariance,
  log: log2,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var textOnly = /^[^\s"=]*$/;
var format3 = (quoteValue, whitespace) => ({
  annotations,
  cause: cause2,
  date,
  fiberId: fiberId2,
  logLevel,
  message,
  spans
}) => {
  const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
  const format4 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
  const append3 = (label, value) => " " + format4(label, value);
  let out = format4("timestamp", date.toISOString());
  out += append3("level", logLevel.label);
  out += append3("fiber", threadName(fiberId2));
  const messages = ensure(message);
  for (let i = 0;i < messages.length; i++) {
    out += append3("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause2)) {
    out += append3("cause", pretty(cause2, {
      renderErrorCause: true
    }));
  }
  for (const span2 of spans) {
    out += " " + render(date.getTime())(span2);
  }
  for (const [label, value] of annotations) {
    out += append3(label, toStringUnknown(value, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var structuredMessage = (u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
};
var withColor = (text, ...colors) => {
  let out = "";
  for (let i = 0;i < colors.length; i++) {
    out += `\x1B[${colors[i]}m`;
  }
  return out + text + "\x1B[0m";
};
var withColorNoop = (text, ..._colors) => text;
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = (date) => `${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}.${date.getMilliseconds().toString().padStart(3, "0")}`;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = (options) => {
  const mode_ = options?.mode ?? "auto";
  const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
  const isBrowser = mode === "browser";
  const showColors = typeof options?.colors === "boolean" ? options.colors : processStdoutIsTTY || isBrowser;
  const formatDate = options?.formatDate ?? defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate,
    stderr: options?.stderr === true
  });
};
var prettyLoggerTty = (options) => {
  const processIsBun = typeof process === "object" && "isBun" in process && process.isBun === true;
  const color = options.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations,
    cause: cause2,
    context: context2,
    date,
    fiberId: fiberId2,
    logLevel,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context2, currentServices);
    const console2 = get3(services, consoleTag).unsafe;
    const log2 = options.stderr === true ? console2.error : console2.log;
    const message = ensure(message_);
    let firstLine = color(`[${options.formatDate(date)}]`, colors.white) + ` ${color(logLevel.label, ...logLevelColors[logLevel._tag])}` + ` (${threadName(fiberId2)})`;
    if (isCons(spans)) {
      const now = date.getTime();
      const render2 = render(now);
      for (const span2 of spans) {
        firstLine += " " + render2(span2);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log2(firstLine);
    if (!processIsBun)
      console2.group();
    if (!isEmpty5(cause2)) {
      log2(pretty(cause2, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (;messageIndex < message.length; messageIndex++) {
        log2(redact(message[messageIndex]));
      }
    }
    if (size4(annotations) > 0) {
      for (const [key, value] of annotations) {
        log2(color(`${key}:`, colors.bold, colors.white), redact(value));
      }
    }
    if (!processIsBun)
      console2.groupEnd();
  });
};
var prettyLoggerBrowser = (options) => {
  const color = options.colors ? "%c" : "";
  return makeLogger(({
    annotations,
    cause: cause2,
    context: context2,
    date,
    fiberId: fiberId2,
    logLevel,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context2, currentServices);
    const console2 = get3(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color}[${options.formatDate(date)}]`;
    const firstParams = [];
    if (options.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color}${logLevel.label}${color} (${threadName(fiberId2)})`;
    if (options.colors) {
      firstParams.push(logLevelStyle[logLevel._tag], "");
    }
    if (isCons(spans)) {
      const now = date.getTime();
      const render2 = render(now);
      for (const span2 of spans) {
        firstLine += " " + render2(span2);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color}${firstMaybeString}`;
        if (options.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console2.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty5(cause2)) {
      console2.error(pretty(cause2, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (;messageIndex < message.length; messageIndex++) {
        console2.log(redact(message[messageIndex]));
      }
    }
    if (size4(annotations) > 0) {
      for (const [key, value] of annotations) {
        const redacted = redact(value);
        if (options.colors) {
          console2.log(`%c${key}:`, "color:gray", redacted);
        } else {
          console2.log(`${key}:`, redacted);
        }
      }
    }
    console2.groupEnd();
  });
};
var prettyLoggerDefault = /* @__PURE__ */ globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);

class MetricBoundariesImpl {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values3) {
    this.values = values3;
    this._hash = pipe(string2(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable7 = (iterable) => {
  const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values3);
};
var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable7);

// node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  _In: (_) => _,
  _Out: (_) => _
};

class CounterKeyType {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string2(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var GaugeKeyTypeHash = /* @__PURE__ */ string2(GaugeKeyTypeSymbolKey);

class GaugeKeyType {
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint) {
    this.bigint = bigint;
  }
  [symbol]() {
    return GaugeKeyTypeHash;
  }
  [symbol2](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class HistogramKeyType {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string2(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var gauge = (options) => new GaugeKeyType(options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  _Type: (_) => _
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence3(equals);

class MetricKeyImpl {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string2(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
var gauge2 = (name, options) => new MetricKeyImpl(name, gauge(options), fromNullable(options?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union(self2.tags, extraTags)));

// node_modules/effect/dist/esm/MutableHashMap.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};

class MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self2) {
    this.self = self2;
    this.referentialIterator = self2.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== undefined) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this.self);
  }
}

class BucketIterator {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === undefined) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = undefined;
      return this.next();
    }
    return result;
  }
}
var empty26 = () => {
  const self2 = Object.create(MutableHashMapProto);
  self2.referential = new Map;
  self2.buckets = new Map;
  self2.bucketsSize = 0;
  return self2;
};
var get12 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    return self2.referential.has(key) ? some2(self2.referential.get(key)) : none2();
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    return none2();
  }
  return getFromBucket(self2, bucket, key);
});
var getFromBucket = (self2, bucket, key, remove6 = false) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove6) {
        bucket.splice(i, 1);
        self2.bucketsSize--;
      }
      return some2(value);
    }
  }
  return none2();
};
var has6 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get12(self2, key)));
var set7 = /* @__PURE__ */ dual(3, (self2, key, value) => {
  if (isEqual(key) === false) {
    self2.referential.set(key, value);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    self2.buckets.set(hash2, [[key, value]]);
    self2.bucketsSize++;
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  bucket.push([key, value]);
  self2.bucketsSize++;
  return self2;
});
var removeFromBucket = (self2, bucket, key) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self2.bucketsSize--;
      return;
    }
  }
};
var remove6 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    self2.referential.delete(key);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  if (bucket.length === 0) {
    self2.buckets.delete(hash2);
  }
  return self2;
});
var clear = (self2) => {
  self2.referential.clear();
  self2.buckets.clear();
  self2.bucketsSize = 0;
  return self2;
};
var size5 = (self2) => {
  return self2.referential.size + self2.bucketsSize;
};

// node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  _A: (_) => _
};

class CounterState {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var arrayEquals = /* @__PURE__ */ getEquivalence3(equals);

class FrequencyState {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string2(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class GaugeState {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class HistogramState {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min4, max4, sum2) {
    this.buckets = buckets;
    this.count = count;
    this.min = min4;
    this.max = max4;
    this.sum = sum2;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class SummaryState {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min4, max4, sum2) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min4;
    this.max = max4;
    this.sum = sum2;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter3 = (count) => new CounterState(count);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge3 = (count) => new GaugeState(count);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  _In: (_) => _,
  _Out: (_) => _
};
var make30 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum2 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint03 : (value) => value >= 0 : (_value) => true;
  const update5 = (value) => {
    if (canUpdate(value)) {
      sum2 = sum2 + value;
    }
  };
  return make30({
    get: () => counter3(sum2),
    update: update5,
    modify: update5
  });
};
var frequency3 = (key) => {
  const values3 = new Map;
  for (const word of key.keyType.preregisteredWords) {
    values3.set(word, 0);
  }
  const update5 = (word) => {
    const slotCount = values3.get(word) ?? 0;
    values3.set(word, slotCount + 1);
  };
  return make30({
    get: () => frequency2(values3),
    update: update5,
    modify: update5
  });
};
var gauge4 = (_key, startAt) => {
  let value = startAt;
  return make30({
    get: () => gauge3(value),
    update: (v) => {
      value = v;
    },
    modify: (v) => {
      value = value + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size6 = bounds.length;
  const values3 = new Uint32Array(size6 + 1);
  const boundaries = new Float32Array(size6);
  let count = 0;
  let sum2 = 0;
  let min4 = Number.MAX_VALUE;
  let max4 = Number.MIN_VALUE;
  pipe(bounds, sort(Order2), map5((n, i) => {
    boundaries[i] = n;
  }));
  const update5 = (value) => {
    let from = 0;
    let to = size6;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values3[from] = values3[from] + 1;
    count = count + 1;
    sum2 = sum2 + value;
    if (value < min4) {
      min4 = value;
    }
    if (value > max4) {
      max4 = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size6);
    let cumulated = 0;
    for (let i = 0;i < size6; i++) {
      const boundary = boundaries[i];
      const value = values3[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make30({
    get: () => histogram3({
      buckets: getBuckets(),
      count,
      min: min4,
      max: max4,
      sum: sum2
    }),
    update: update5,
    modify: update5
  });
};
var summary3 = (key) => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order2));
  const values3 = allocate(maxSize);
  let head4 = 0;
  let count = 0;
  let sum2 = 0;
  let min4 = 0;
  let max4 = 0;
  const snapshot = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values3[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo(age, zero) && lessThanOrEqualTo(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Order2));
  };
  const observe = (value, timestamp) => {
    if (maxSize > 0) {
      head4 = head4 + 1;
      const target = head4 % maxSize;
      values3[target] = [timestamp, value];
    }
    min4 = count === 0 ? value : Math.min(min4, value);
    max4 = count === 0 ? value : Math.max(max4, value);
    count = count + 1;
    sum2 = sum2 + value;
  };
  return make30({
    get: () => summary2({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min: min4,
      max: max4,
      sum: sum2
    }),
    update: ([value, timestamp]) => observe(value, timestamp),
    modify: ([value, timestamp]) => observe(value, timestamp)
  });
};
var calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty3();
  }
  const head4 = sortedQuantiles[0];
  const tail2 = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head4, sortedSamples);
  const resolved = of(resolvedHead);
  tail2.forEach((quantile) => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map5(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (true) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  _Type: (_) => _
};
var unsafeMake7 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);

class MetricRegistryImpl {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty26();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake7(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get12(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const counter5 = counter4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set7(key, counter5));
      }
      value = counter5;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const frequency4 = frequency3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set7(key, frequency4));
      }
      value = frequency4;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const gauge5 = gauge4(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set7(key, gauge5));
      }
      value = gauge5;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const histogram5 = histogram4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set7(key, histogram5));
      }
      value = histogram5;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe(this.map, get12(key), getOrUndefined);
    if (value == null) {
      const summary4 = summary3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set7(key, summary4));
      }
      value = summary4;
    }
    return value;
  }
}
var make31 = () => {
  return new MetricRegistryImpl;
};

// node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  _Type: (_) => _,
  _In: (_) => _,
  _Out: (_) => _
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make31());
var make32 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect) => tap(effect, (a) => update5(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name, options) => fromMetricKey(counter2(name, options));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = new WeakMap;
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== undefined) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make32(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var gauge5 = (name, options) => fromMetricKey(gauge2(name, options));
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self2, key, value) => taggedWithLabels2(self2, [make29(key, value)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
  return make32(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union(extraTags, extraTags1)));
});
var update5 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self2.unsafeUpdate(input, tags))));

// node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u) => hasProperty(u, RequestTypeId);
var complete2 = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map14) => sync(() => {
  if (map14.has(self2)) {
    const entry = map14.get(self2);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
class Listeners {
  count = 0;
  observers = /* @__PURE__ */ new Set;
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
}

// node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};

class RedBlackTreeIterator {
  self;
  stack;
  direction;
  count = 0;
  constructor(self2, stack, direction) {
    this.self = self2;
    this.stack = stack;
    this.direction = direction;
  }
  clone() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  reversed() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2;s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1;s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1;s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
}

// node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};

// node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  _Key: (_) => _,
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash2 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries2 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries2[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var keysForward = (self2) => keys4(self2, Direction.Forward);
var keys4 = (self2, direction) => {
  const begin = self2[Symbol.iterator]();
  let count = 0;
  return {
    [Symbol.iterator]: () => keys4(self2, direction),
    next: () => {
      count++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};

// node_modules/effect/dist/esm/RedBlackTree.js
var keys5 = keysForward;

// node_modules/effect/dist/esm/SortedSet.js
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId12]: {
    _A: (_) => _
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId12)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys5(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSortedSet = (u) => hasProperty(u, TypeId12);

// node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  _T: (_) => _
};

class ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context2, effect, parent, fiber) {
    this.underlying.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}

class Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context2, effect, parent, fiber) {
    this.left.onStart(context2, effect, parent, fiber);
    this.right.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}
var isZip = (self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip");

class Track {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set;
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {}
  onSuspend(_fiber) {}
  onResume(_fiber) {}
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}

class Const {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {}
  onEnd(_value, _fiber) {}
  onEffect(_fiber, _effect) {}
  onSuspend(_fiber) {}
  onResume(_fiber) {}
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
var unsafeTrack = () => {
  return new Track;
};
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect = (effect) => {
  return new Const(effect);
};
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// node_modules/effect/dist/esm/Differ.js
var make34 = make17;

// node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty29 = {
  _tag: OP_EMPTY3
};
var combine11 = (self2, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self2,
    second: that
  };
};
var patch11 = (self2, supervisor) => {
  return patchLoop(supervisor, of2(self2));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head4 = headNonEmpty2(patches);
    switch (head4._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head4.first)(prepend2(head4.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self2, that) => {
  if (equals(self2, that)) {
    return none8;
  } else {
    if (isZip(self2)) {
      return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
    } else {
      return self2;
    }
  }
};
var toSet3 = (self2) => {
  if (equals(self2, none8)) {
    return empty9();
  } else {
    if (isZip(self2)) {
      return pipe(toSet3(self2.left), union4(toSet3(self2.right)));
    } else {
      return make12(self2);
    }
  }
};
var diff10 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty29;
  }
  const oldSupervisors = toSet3(oldValue);
  const newSupervisors = toSet3(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty29, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty29, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine11(added, removed);
};
var differ2 = /* @__PURE__ */ make34({
  empty: empty29,
  patch: patch11,
  combine: combine11,
  diff: diff10
});

// node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var absurd = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: (_, _cont, value) => {
    return exitSucceed(exitSucceed(value));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS]: (self2, cont, value) => {
    self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
    if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
      return exitFailCause(self2.getInterruptedCause());
    } else {
      return exitSucceed(value);
    }
  },
  [OP_WHILE]: (self2, cont, value) => {
    internalCall(() => cont.effect_instruction_i2(value));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self2.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self2, cont, value) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value));
    if (state.done)
      return exitSucceed(state.value);
    self2.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
    self2.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
    message.onFiber(self2, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap8(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self2) => forEachSequentialDiscard(flatten3(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
  const map14 = new Map;
  const arr = [];
  for (const block of sequential4) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map14.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map14);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();

class FiberRuntime extends Class {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array;
  _children = null;
  _observers = /* @__PURE__ */ new Array;
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId2, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId2;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  id() {
    return this._fiberId;
  }
  resume(effect) {
    this.tell(resume(effect));
  }
  get status() {
    return this.ask((_, status) => status);
  }
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (isDone3(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  scope() {
    return unsafeMake6(this);
  }
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  getChildren() {
    if (this._children === null) {
      this._children = new Set;
    }
    return this._children;
  }
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
      }));
      return deferredAwait(deferred);
    });
  }
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit2) => resume2(succeed(exit2));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch12 = pipe(diff7(parentRuntimeFlags, updatedRuntimeFlags), exclude2(Interruption), exclude2(WindDown));
      return updateRuntimeFlags(patch12);
    });
  }
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  unsafePoll() {
    return this._exitValue;
  }
  interruptAsFork(fiberId2) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
  }
  unsafeInterruptAsFork(fiberId2) {
    this.tell(interruptSignal(interrupt(fiberId2)));
  }
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  addChild(child) {
    this.getChildren().add(child);
  }
  removeChild(child) {
    this.getChildren().delete(child);
  }
  transferChildren(scope) {
    const children = this._children;
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        if (child._exitValue === null) {
          scope.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  isInterrupted() {
    return !isEmpty5(this.getFiberRef(currentInterruptedCause));
  }
  addInterruptedCause(cause2) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
  }
  processNewInterruptSignal(cause2) {
    this.addInterruptedCause(cause2);
    this.sendInterruptSignalToAllChildren();
  }
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone4 = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone4 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone4,
        body,
        step: () => {}
      });
    }
    return null;
  }
  reportExitValue(exit2) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit2._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit2._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit2.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit2.cause, level);
      }
    }
  }
  setExitValue(exit2) {
    this._exitValue = exit2;
    this.reportExitValue(exit2);
    for (let i = this._observers.length - 1;i >= 0; i--) {
      this._observers[i](exit2);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause2, overrideLogLevel) {
    const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get3(this.getFiberRef(currentServices), clockTag);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause: cause2,
            context: contextMap,
            spans,
            annotations,
            date
          });
        }
      });
    }
  }
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit2 = this.runLoop(eff);
        if (exit2 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect = null;
            } else {
              effect = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect = flatMap8(interruption2, () => exit2);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit2);
            } else {
              this.tell(resume(exit2));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect));
    }
  }
  startFork(effect) {
    this.tell(resume(effect));
  }
  patchRuntimeFlags(oldRuntimeFlags, patch12) {
    const newRuntimeFlags = patch7(oldRuntimeFlags, patch12);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException);
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit2) => {
        if (exit2._tag === "Success") {
          return resume2(exitSucceed(exit2.value));
        }
        switch (exit2.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit2.cause.error));
          }
          case "Die": {
            return resume2(die2(exit2.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause2 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== undefined) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause2, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause2);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause2);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff9(snap.refs, refs);
      const patchFlags = diff7(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch7(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap8(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, undefined);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap8(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId2]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
}
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get3(services, consoleTag).unsafe.log(self2.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations,
  cause: cause2,
  context: context2,
  fiberId: fiberId2,
  logLevel,
  message
}) => {
  const span2 = getOption2(getOrDefault(context2, currentContext), spanTag);
  if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context2, currentServices), clockTag);
  const attributes = {};
  for (const [key, value] of annotations) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName2(fiberId2);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause2 !== null && cause2._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause2, {
      renderErrorCause: true
    });
  }
  span2.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make12(defaultLogger, tracerLogger)));
var annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set4(arguments[0], arguments[1]));
  }
  const entries2 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations) => {
    for (let i = 0;i < entries2.length; i++) {
      const [key, value] = entries2[i];
      set4(annotations, key, value);
    }
    return annotations;
  }));
};
var whenLogLevel = /* @__PURE__ */ dual(2, (effect, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel, requiredLogLevel)) {
      return succeed(none2());
    }
    return map12(effect, some2);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit2) => release(a, exit2)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit2) => release(exit2))));
var addFinalizer = (finalizer) => withFiberRuntime((runtime3) => {
  const acquireRefs = runtime3.getFiberRefs();
  const acquireFlags = disable2(runtime3.currentRuntimeFlags, Interruption);
  return flatMap8(scope, (scope) => scopeAddFinalizerExit(scope, (exit2) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer(exit2), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self2) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self2);
};
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists2 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach8(elements, (a, i) => if_(predicate(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index, f) => {
  const next = iterator.next();
  if (next.done) {
    return succeed(false);
  }
  return pipe(flatMap8(f(next.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f)));
};
var filter6 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map12(predicate(a, i), not) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i) => zipWith3(effect, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array))), () => map12(forEach8(elements, (a, i) => map12(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys6 = Object.keys(input);
  const size8 = keys6.length;
  return [keys6.map((k) => input[k]), some2((values3) => {
    const res = {};
    for (let i = 0;i < size8; i++) {
      res[keys6[i]] = values3[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  return flatMap8(forEach8(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none9 = none2();
    const size8 = eithers.length;
    const errors = new Array(size8);
    const successes = new Array(size8);
    let errored = false;
    for (let i = 0;i < size8; i++) {
      const either3 = eithers[i];
      if (either3._tag === "Left") {
        errors[i] = some2(either3.left);
        errored = true;
      } else {
        successes[i] = either3.right;
        errors[i] = none9;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  if (options?.discard) {
    return forEach8(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map12(forEach8(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all3 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map12(forEach8(effects, identity, options), reconcile.value) : forEach8(effects, identity, options);
};
var allWith = (options) => (arg) => all3(arg, options);
var allSuccesses = (elements, options) => map12(all3(fromIterable(elements).map(exit), options), filterMap2((exit2) => exitIsSuccess(exit2) ? some2(exit2.effect_instruction_i0) : none2()));
var replicate2 = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
  length: n
}, () => self2));
var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, n, options) => all3(replicate2(self2, n), options));
var forEach8 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match7(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match7(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self2, f, batching) => suspend(() => {
  const as2 = fromIterable(self2);
  const array4 = new Array(as2.length);
  const fn = (a, i) => flatMap8(f(a, i), (b) => sync(() => array4[i] = b));
  return zipRight(forEachConcurrentDiscard(as2, fn, batching, false), succeed(array4));
});
var forEachConcurrentDiscard = (self2, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self2).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter6 = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = new Set;
  const results = new Array;
  const interruptAll = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array;
  const joinOrder = new Array;
  const residual = new Array;
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit2
    }) => exit2._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit2
    }) => exit2);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter6++;
          return flatMap8(yieldNow(), () => flatMap8(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap8(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit2;
          if (wrapped._op === "Failure") {
            exit2 = wrapped;
          } else {
            exit2 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit2, index);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0;i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit(flatten5(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause2) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check = (index2, hitNext) => (exit2) => {
          exits[index2] = exit2;
          count++;
          if (count === target2) {
            cb(exitSucceed(exitFailCause(cause2)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check(index, true));
          index++;
        };
        processingFiber.addObserver(check(index, false));
        index++;
        for (let i = 0;i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self2, n, f, batching) => suspend(() => {
  const as2 = fromIterable(self2);
  const array4 = new Array(as2.length);
  const fn = (a, i) => map12(f(a, i), (b) => array4[i] = b);
  return zipRight(forEachConcurrentDiscard(as2, fn, batching, false, n), succeed(array4));
});
var fork = (self2) => withFiberRuntime((state, status) => succeed(unsafeFork(self2, state, status.runtimeFlags)));
var forkDaemon = (self2) => forkWithScopeOverride(self2, globalScope);
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause2) => {
  const either3 = failureOrCause(cause2);
  switch (either3._tag) {
    case "Left":
      return handler(either3.left);
    case "Right":
      return failCause(either3.right);
  }
})));
var unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
};
var unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake2();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
  childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll2 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero2, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero2)), () => flatMap8(make26(zero2), (acc) => flatMap8(forEach8(elements, (effect, i) => flatMap8(effect, (a) => update4(acc, (b) => f(b, a, i))), options), () => get11(acc)))));
var partition3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach8(elements, (a, i) => either2(f(a, i)), options), map12((chunk2) => partitionMap2(chunk2, identity))));
var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap8(partition3(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_ : succeed(bs)));
var raceAll = (all4) => {
  const list = fromIterable2(all4);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self2 = headNonEmpty2(list);
  const effects = tailNonEmpty2(list);
  const inheritAll2 = (res) => pipe(inheritAll(res[1]), as(res[0]));
  return pipe(deferredMake(), flatMap8((done5) => pipe(make26(effects.length), flatMap8((fails) => uninterruptibleMask((restore) => pipe(fork(interruptible2(self2)), flatMap8((head4) => pipe(effects, forEachSequential((effect) => fork(interruptible2(effect))), map12((fibers) => unsafeFromArray(fibers)), map12((tail2) => pipe(tail2, prepend2(head4))), tap((fibers) => pipe(fibers, reduce(void_, (effect, fiber) => pipe(effect, zipRight(pipe(_await2(fiber), flatMap8(raceAllArbiter(fibers, fiber, done5, fails)), fork, asVoid)))))), flatMap8((fibers) => pipe(restore(pipe(_await(done5), flatMap8(inheritAll2))), onInterrupt(() => pipe(fibers, reduce(void_, (effect, fiber) => pipe(effect, zipLeft(interruptFiber(fiber))))))))))))))));
};
var raceAllArbiter = (fibers, winner, deferred, fails) => (exit2) => exitMatchEffect(exit2, {
  onFailure: (cause2) => pipe(modify4(fails, (fails2) => [fails2 === 0 ? pipe(deferredFailCause(deferred, cause2), asVoid) : void_, fails2 - 1]), flatten5),
  onSuccess: (value) => pipe(deferredSucceed(deferred, [value, winner]), flatMap8((set8) => set8 ? pipe(fromIterable2(fibers), reduce(void_, (effect, fiber) => fiber === winner ? effect : pipe(effect, zipLeft(interruptFiber(fiber))))) : void_))
});
var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero2, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), zero2), () => suspend(() => pipe(mergeAll2([zero2, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f(acc.value, elem, i));
    }
  }
}, options), map12((option2) => {
  switch (option2._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option2.value;
    }
  }
})))));
var parallelFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Parallel":
        return self2;
      case "Sequential":
      case "ParallelN":
        return flatMap8(scopeFork(scope, parallel3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
      return self2;
    }
    return flatMap8(scopeFork(scope, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
  }
}));
var finalizersMask = (strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2);
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2(identity),
  onSome: (scope) => {
    if (concurrentFinalizers === true) {
      const patch12 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope.strategy._tag) {
        case "Parallel":
          return patch12(self2(parallelFinalizers));
        case "Sequential":
          return patch12(self2(sequentialFinalizers));
        case "ParallelN":
          return patch12(self2(parallelNFinalizers(scope.strategy.parallelism)));
      }
    } else {
      return self2(identity);
    }
  }
}));
var scopeWith = (f) => flatMap8(scopeTag, f);
var scopedWith = (f) => flatMap8(scopeMake(), (scope) => onExit(f(scope), (exit2) => scope.close(exit2)));
var scopedEffect = (effect) => flatMap8(scopeMake(), (scope) => scopeUse(effect, scope));
var sequentialFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Sequential":
        return self2;
      case "Parallel":
      case "ParallelN":
        return flatMap8(scopeFork(scope, sequential3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var tagMetricsScoped = (key, value) => labelMetricsScoped([make29(key, value)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels));
var using = /* @__PURE__ */ dual(2, (self2, use) => scopedWith((scope) => flatMap8(scopeExtend(self2, scope), use)));
var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => validateWith(self2, that, (a, b) => [a, b], options));
var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => flatten5(zipWithOptions(exit(self2), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flip(forEach8(elements, (a, i) => flip(f(a, i)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
var withRandomScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value));
var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
var withEarlyRelease = (self2) => scopeWith((parent) => flatMap8(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map12((value) => [fiberIdWith((fiberId2) => scopeClose(child, exitInterrupt(fiberId2))), value]))));
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => zipWithOptions(self2, that, (a, b) => [a, b], options));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipLeft(self2, that);
  }
  return zipWithOptions(self2, that, (a, _) => a, options);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipRight(self2, that);
  }
  return zipWithOptions(self2, that, (_, b) => b, options);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => map12(all3([self2, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = (update6) => {
  if (update6 === empty19) {
    return void_;
  }
  return pipe(runtimeFlags, flatMap8((runtimeFlags2) => {
    const updatedRuntimeFlags = patch7(runtimeFlags2, update6);
    const revertRuntimeFlags = diff7(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update6), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
  }), uninterruptible);
};
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope2, fin) => {
  if (scope2.state._tag === "Open") {
    scope2.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit2) => newScope.close(exit2);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit2) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit2
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit2))), flatMap8((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit2)), false), flatMap8((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit2)), false), flatMap8((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope2 = Object.create(ScopeImplProto);
  scope2.strategy = strategy;
  scope2.state = {
    _tag: "Open",
    finalizers: new Map
  };
  return scope2;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect, scope2) => mapInputContext(effect, merge3(make6(scopeTag, scope2))));
var scopeUse = /* @__PURE__ */ dual(2, (effect, scope2) => pipe(effect, scopeExtend(scope2), onExit((exit2) => scope2.close(exit2))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty29
});
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value) => asVoid(acquireRelease(flatMap8(fiberRefGet(self2), (oldValue) => as(fiberRefSet(self2, value), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers) => forEach8(fibers, _await2);
var fiberAll = (fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join2(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable(fibers).reduce((id, fiber) => combine3(id, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten5(fiber.await), false)),
    children: map12(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map12(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array)), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk2) => [a, ...chunk2],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId2))
  };
  return _fiberAll;
};
var fiberInterruptFork = (self2) => asVoid(forkDaemon(interruptFiber(self2)));
var fiberJoinAll = (fibers) => join2(fiberAll(fibers));
var raceWith = /* @__PURE__ */ dual(3, (self2, other, options) => raceFibersWith(self2, other, {
  onSelfWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap8(winner.inheritAll, () => options.onSelfDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit2, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap8(winner.inheritAll, () => options.onOtherDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit2, loser);
      }
    }
  })
}));
var disconnect = (self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId2) => flatMap8(forkDaemon(restore(self2)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId2)))))));
var race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
  onSelfDone: (exit2, right3) => exitMatchEffect(exit2, {
    onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
    onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as(value))
  }),
  onOtherDone: (exit2, left3) => exitMatchEffect(exit2, {
    onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
    onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as(value))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make13(true);
  const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self2);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self2, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => matchCauseEffect(finalizer, {
    onFailure: (cause2) => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as(finalizer, a)
})));
var invokeWithInterrupt = (self2, entries2, onInterrupt2) => fiberIdWith((id) => flatMap8(flatMap8(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
  const counts = entries2.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count) => count === 0)) {
      if (entries2.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt2?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit2) => {
    cleanup.forEach((f) => f());
    cb(exit2);
  });
  const cleanup = entries2.map((r, i) => {
    const observer = (count) => {
      counts[i] = count;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries2.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete2(entry.request, exitInterrupt(id)));
})));
var makeSpanScoped = (name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope2 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
    const span2 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
    return as(scopeAddFinalizerExit(scope2, (exit2) => endSpan(span2, exit2, clock_, timingEnabled)), span2);
  }));
};
var withTracerScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value));
var withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
  }
  return (self2) => flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
};

// node_modules/effect/dist/esm/Cause.js
var YieldableError2 = YieldableError;
var empty30 = empty21;
var fail5 = fail;
var die4 = die;
var interrupt5 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterrupted3 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var interruptors2 = interruptors;
var failureOption2 = failureOption;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var map14 = map11;
var squash = causeSquash;
var reduceWithContext3 = reduceWithContext2;
var IllegalArgumentException2 = IllegalArgumentException;
var NoSuchElementException2 = NoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var pretty2 = pretty;

// node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty31 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make35 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty31;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan3 = /* @__PURE__ */ dual(2, (self2, that) => min4(self2, that) === self2);
var min4 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.endMillis <= that.startMillis)
    return self2;
  if (that.endMillis <= self2.startMillis)
    return that;
  if (self2.startMillis < that.startMillis)
    return self2;
  if (that.startMillis < self2.startMillis)
    return that;
  if (self2.endMillis <= that.endMillis)
    return self2;
  return that;
});
var isEmpty6 = (self2) => {
  return self2.startMillis >= self2.endMillis;
};
var intersect = /* @__PURE__ */ dual(2, (self2, that) => {
  const start = Math.max(self2.startMillis, that.startMillis);
  const end = Math.min(self2.endMillis, that.endMillis);
  return make35(start, end);
});
var size9 = (self2) => {
  return millis(self2.endMillis - self2.startMillis);
};
var after = (startMilliseconds) => {
  return make35(startMilliseconds, Number.POSITIVE_INFINITY);
};

// node_modules/effect/dist/esm/ScheduleInterval.js
var make36 = make35;
var empty32 = empty31;
var lessThan4 = lessThan3;
var isEmpty7 = isEmpty6;
var intersect2 = intersect;
var size10 = size9;
var after2 = after;

// node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make37 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var union7 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (!isNonEmpty(that.intervals)) {
    return self2;
  }
  if (!isNonEmpty(self2.intervals)) {
    return that;
  }
  if (headNonEmpty2(self2.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
    return unionLoop(tailNonEmpty2(self2.intervals), that.intervals, headNonEmpty2(self2.intervals), empty6());
  }
  return unionLoop(self2.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty6());
});
var unionLoop = (_self, _that, _interval, _acc) => {
  let self2 = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty(self2) || isNonEmpty(that)) {
    if (!isNonEmpty(self2) && isNonEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
        self2 = empty6();
      } else {
        interval = make36(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
        self2 = empty6();
      }
    } else if (isNonEmpty(self2) && isEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(self2).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(self2);
        that = empty6();
        self2 = tailNonEmpty2(self2);
      } else {
        interval = make36(interval.startMillis, headNonEmpty2(self2).endMillis);
        that = empty6();
        self2 = tailNonEmpty2(self2);
      }
    } else if (isNonEmpty(self2) && isNonEmpty(that)) {
      if (headNonEmpty2(self2).startMillis < headNonEmpty2(that).startMillis) {
        if (interval.endMillis < headNonEmpty2(self2).startMillis) {
          acc = pipe(acc, prepend2(interval));
          interval = headNonEmpty2(self2);
          self2 = tailNonEmpty2(self2);
        } else {
          interval = make36(interval.startMillis, headNonEmpty2(self2).endMillis);
          self2 = tailNonEmpty2(self2);
        }
      } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
      } else {
        interval = make36(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return make37(pipe(acc, prepend2(interval), reverse2));
};
var intersect3 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty6()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty(left3) && isNonEmpty(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty7(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan4(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make37(reverse2(acc));
};
var start = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty32)).startMillis;
};
var end = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty32)).endMillis;
};
var lessThan5 = /* @__PURE__ */ dual(2, (self2, that) => start(self2) < start(that));
var isNonEmpty3 = (self2) => {
  return isNonEmpty(self2.intervals);
};

// node_modules/effect/dist/esm/ScheduleIntervals.js
var make38 = make37;
var union8 = union7;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan6 = lessThan5;
var isNonEmpty4 = isNonEmpty3;

// node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make38(of2(interval))
  };
};
var done5 = {
  _tag: OP_DONE2
};
var isContinue = (self2) => {
  return self2._tag === OP_CONTINUE;
};
var isDone4 = (self2) => {
  return self2._tag === OP_DONE2;
};

// node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done6 = done5;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend3 = scopeExtend;
var fork2 = scopeFork;
var make39 = scopeMake;

// node_modules/effect/dist/esm/internal/effect/circular.js
class Semaphore {
  permits;
  waiters = /* @__PURE__ */ new Set;
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTaken = (f) => withFiberRuntime((fiber) => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = (n) => (self2) => uninterruptibleMask((restore) => flatMap8(restore(this.take(n)), (permits) => ensuring(restore(self2), this.release(permits))));
  withPermitsIfAvailable = (n) => (self2) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self2)), this.release(n));
  }));
}
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));

class Latch extends Class {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0;i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen)
      return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index = this.waiters.indexOf(resume2);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self2) => {
    return zipRight(this.await, self2);
  };
}
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
var awaitAllChildren = (self2) => ensuringChildren(self2, fiberAwaitAll);
var cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map12(cachedInvalidateWithTTL(self2, timeToLive), (tuple3) => tuple3[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
  const duration = decode(timeToLive);
  return flatMap8(context(), (env) => map12(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self2, duration, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = (self2, timeToLive, start3) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap((deferred) => intoDeferred(self2, deferred)), map12((deferred) => some2([start3 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self2, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock2) => clock2.currentTimeMillis), flatMap8((time) => updateSomeAndGetEffectSynchronized(cache, (option2) => {
  switch (option2._tag) {
    case "None": {
      return some2(computeCachedValue(self2, timeToLive, time));
    }
    case "Some": {
      const [end3] = option2.value;
      return end3 - time <= 0 ? some2(computeCachedValue(self2, timeToLive, time)) : none2();
    }
  }
})), flatMap8((option2) => isNone2(option2) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option2.value[1])))));
var invalidateCache = (cache) => set5(cache, none2());
var ensuringChild = /* @__PURE__ */ dual(2, (self2, f) => ensuringChildren(self2, (children) => f(fiberAll(children))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self2, children) => flatMap8(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap8(supervisor.value, children)))));
var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map12(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self2, scope2) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope2;
  const fiber = unsafeFork(self2, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed")
        return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self2) => scopeWith((scope2) => forkIn(self2, scope2));
var fromFiber = (fiber) => join2(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap8(fiber, join2));
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");

class Key {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
}
var cachedFunction = (f, eq) => {
  return pipe(sync(() => empty26()), flatMap8(makeSynchronized), map12((ref) => (a) => pipe(ref.modifyEffect((map15) => {
    const result = pipe(map15, get12(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map12((deferred) => [deferred, pipe(map15, set7(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map15]);
  }), flatMap8(deferredAwait), flatMap8(([patch12, b]) => pipe(patchFiberRefs(patch12), as(b))))));
};
var raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit(self2), race(exit(that)), (effect) => flatten5(effect)));
var supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self2);
});
var timeout = /* @__PURE__ */ dual(2, (self2, duration) => timeoutFail(self2, {
  onTimeout: () => timeoutExceptionFromDuration(duration),
  duration
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onTimeout
}) => flatten5(timeoutTo(self2, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onTimeout
}) => flatten5(timeoutTo(self2, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self2, duration) => timeoutTo(self2, {
  duration,
  onSuccess: some2,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration)), {
  onSelfWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
    } else {
      return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  _A: (_) => _
};

class SynchronizedImpl extends Class {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get10(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap8(get10(this.ref), f), flatMap8(([b, a]) => as(set5(this.ref, a), b))));
  }
}
var makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value));
var unsafeMakeSynchronized = (value) => {
  const ref = unsafeMake5(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value) => {
  const result = pf(value);
  switch (result._tag) {
    case "None": {
      return succeed([value, value]);
    }
    case "Some": {
      return map12(result.value, (a) => [a, a]);
    }
  }
}));
var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, f, options) => flatMap8(self2, (a) => all3(f(a), options).pipe(map12((record) => Object.assign({}, a, record)))));

// node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/effect/dist/esm/Fiber.js
var _await3 = _await2;
var getCurrentFiber2 = getCurrentFiber;
var inheritAll2 = inheritAll;
var interrupt6 = interruptFiber;
var interruptAs = interruptAsFiber;
var interruptAllAs2 = interruptAllAs;
var interruptFork = fiberInterruptFork;
var join3 = join2;
var joinAll = fiberJoinAll;
var poll3 = poll2;

// node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime3 = arguments[0];
    return (effect, ...args2) => f(runtime3, effect, ...args2);
  }
  return f.apply(this, arguments);
};
var unsafeFork2 = /* @__PURE__ */ makeDual((runtime3, self2, options) => {
  const fiberId2 = unsafeMake2();
  const fiberRefUpdates = [[currentContext, [[fiberId2, runtime3.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId2, options.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime3.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId2
  });
  if (options?.updateRefs) {
    fiberRefs3 = options.updateRefs(fiberRefs3, fiberId2);
  }
  const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime3.runtimeFlags);
  let effect = self2;
  if (options?.scope) {
    effect = flatMap8(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self2, (exit2) => close(closeableScope, exit2))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime3.context, effect, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
  }
  globalScope.add(runtime3.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime3, effect, options = {}) => {
  const fiberRuntime = unsafeFork2(runtime3, effect, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit2) => {
      options.onExit(exit2);
    });
  }
  return (id2, cancelOptions) => unsafeRunCallback(runtime3)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit2) => cancelOptions.onExit(flatten6(exit2)) : undefined
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime3, effect) => {
  const result = unsafeRunSyncExit(runtime3)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});

class AsyncFiberExceptionImpl extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
}
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
};
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");

class FiberFailureImpl extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause2) {
    const head4 = prettyErrors(cause2)[0];
    super(head4?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause2;
    this.name = head4 ? `(FiberFailure) ${head4.name}` : "FiberFailure";
    if (head4?.stack) {
      this.stack = head4.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
}
var fiberFailure = (cause2) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause2);
  Error.stackTraceLimit = limit;
  return error;
};
var fastPath = (effect) => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime3, effect) => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler;
  const fiberRuntime = unsafeFork2(runtime3)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime3, effect, options) => unsafeRunPromiseExit(runtime3, effect, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime3, effect, options) => new Promise((resolve) => {
  const op = fastPath(effect);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork2(runtime3)(effect);
  fiber.addObserver((exit2) => {
    resolve(exit2);
  });
  if (options?.signal !== undefined) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));

class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context2, runtimeFlags2, fiberRefs3) {
    this.context = context2;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make40 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make19(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make40({
  context: /* @__PURE__ */ empty5(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty24()
});
var updateContext2 = /* @__PURE__ */ dual(2, (self2, f) => make40({
  context: f(self2.context),
  runtimeFlags: self2.runtimeFlags,
  fiberRefs: self2.fiberRefs
}));
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork2(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = undefined;
  return flatMap8(deferredMake(), (deferred) => flatMap8(runtime3(), (runtime4) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime4)(intoDeferred(cb, deferred))), {
    onFailure: (cause2) => deferredFailCause(deferred, cause2),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_))))));
});

// node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));
var updateEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect((value) => map12(f(value), (result) => [undefined, result])));

// node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  _RIn: (_) => _,
  _E: (_) => _,
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self2) => {
  return self2._op_layer === OP_FRESH;
};

class MemoMapImpl {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  getOrElseMemoize(layer, scope2) {
    return pipe(modifyEffect(this.ref, (map16) => {
      const inMap = map16.get(layer);
      if (inMap !== undefined) {
        const [acquire, release] = inMap;
        const cached3 = pipe(acquire, flatMap8(([patch12, b]) => pipe(patchFiberRefs(patch12), as(b))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope2, release)
        })));
        return succeed([cached3, map16]);
      }
      return pipe(make25(0), flatMap8((observers) => pipe(deferredMake(), flatMap8((deferred) => pipe(make25(() => void_), map12((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap8((innerScope) => pipe(restore(flatMap8(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap8((exit2) => {
          switch (exit2._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight(scopeClose(innerScope, exit2)), zipRight(failCause(exit2.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set5(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update3(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync(() => map16.delete(layer)), zipRight(get10(finalizerRef)), flatMap8((finalizer) => finalizer(exit3))))), zipRight(deferredSucceed(deferred, exit2.effect_instruction_i0)), as(exit2.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update3(observers, (n) => n + 1)
        }))), (exit2) => pipe(get10(finalizerRef), flatMap8((finalizer) => finalizer(exit2)))];
        return [resource, isFresh(layer) ? map16 : map16.set(layer, memoized)];
      }))))));
    }), flatten5);
  }
}
var makeMemoMap = /* @__PURE__ */ suspend(() => map12(makeSynchronized(new Map), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map));
var buildWithScope = /* @__PURE__ */ dual(2, (self2, scope2) => flatMap8(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope2)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope2) => flatMap8(makeBuilder(self2, scope2), (run) => provideService(run(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self2, scope2, inMemoMap = false) => {
  const op = self2;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect({
        onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope2),
        onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope2)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope2)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap8((env) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope2)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith3(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope2), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var context2 = () => fromEffectContext(context());
var fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return fromEffectContext(map12(effect, (service) => make6(tag, service)));
});
var fromEffectDiscard = (effect) => fromEffectContext(map12(effect, () => empty5()));
function fromEffectContext(effect) {
  const fromEffect4 = Object.create(proto3);
  fromEffect4._op_layer = OP_FROM_EFFECT;
  fromEffect4.effect = effect;
  return fromEffect4;
}
var merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith6(self2, that, (a, b) => merge3(a, b)));
var mergeAll3 = (...layers) => {
  let final = layers[0];
  for (let i = 1;i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
};
var scoped = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return scopedContext(map12(effect, (service) => make6(tag, service)));
});
var scopedDiscard = (effect) => scopedContext(pipe(effect, as(empty5())));
var scopedContext = (effect) => {
  const scoped2 = Object.create(proto3);
  scoped2._op_layer = OP_SCOPED;
  scoped2.effect = effect;
  return scoped2;
};
var succeed6 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make6(tag, resource)));
});
var succeedContext = (context3) => {
  return fromEffectContext(succeed(context3));
};
var suspend2 = (evaluate2) => {
  const suspend3 = Object.create(proto3);
  suspend3._op_layer = OP_SUSPEND;
  suspend3.evaluate = evaluate2;
  return suspend3;
};
var sync2 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const evaluate2 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make6(tag, evaluate2())));
});
var provide = /* @__PURE__ */ dual(2, (self2, that) => suspend2(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll3(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self2;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
  const zipWith6 = Object.create(proto3);
  zipWith6._op_layer = OP_PROVIDE_MERGE;
  zipWith6.first = self2;
  zipWith6.second = provide(that, self2);
  zipWith6.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith6;
});
var zipWith6 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend2(() => {
  const zipWith7 = Object.create(proto3);
  zipWith7._op_layer = OP_ZIP_WITH2;
  zipWith7.first = self2;
  zipWith7.second = that;
  zipWith7.zipK = f;
  return zipWith7;
}));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer) => scopedWith((scope2) => flatMap8(buildWithScope(layer, scope2), (context3) => provideSomeContext(self2, context3))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
  const patchRefs = diff9(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff7(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch7(patchFlags)(oldFlags);
    const rollbackRefs = diff9(newRefs, oldRefs);
    const rollbackFlags = diff7(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch7(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self2, mergeAll3(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self2, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self2, source);
  } else if (TypeId13 in source) {
    return flatMap8(source.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
  } else {
    return provideSomeRuntime(self2, source);
  }
});

// node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map12(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag)));
var withConsole = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add2(consoleTag, value)));
var withConsoleScoped = (console3) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console3));
var setConsole = (console3) => scopedDiscard(fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console3)));
var assert = (condition, ...args2) => consoleWith((_) => _.assert(condition, ...args2));
var clear2 = /* @__PURE__ */ consoleWith((_) => _.clear);
var count = (label) => consoleWith((_) => _.count(label));
var countReset = (label) => consoleWith((_) => _.countReset(label));
var debug = (...args2) => consoleWith((_) => _.debug(...args2));
var dir = (item, options) => consoleWith((_) => _.dir(item, options));
var dirxml = (...args2) => consoleWith((_) => _.dirxml(...args2));
var error = (...args2) => consoleWith((_) => _.error(...args2));
var group2 = (options) => consoleWith((_) => acquireRelease(_.group(options), () => _.groupEnd));
var info = (...args2) => consoleWith((_) => _.info(...args2));
var log2 = (...args2) => consoleWith((_) => _.log(...args2));
var table = (tabularData, properties) => consoleWith((_) => _.table(tabularData, properties));
var time = (label) => consoleWith((_) => acquireRelease(_.time(label), () => _.timeEnd(label)));
var timeLog = (label, ...args2) => consoleWith((_) => _.timeLog(label, ...args2));
var trace = (...args2) => consoleWith((_) => _.trace(...args2));
var warn = (...args2) => consoleWith((_) => _.warn(...args2));
var withGroup = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, options) => consoleWith((_) => acquireUseRelease(_.group(options), () => self2, () => _.groupEnd)));
var withTime = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, label) => consoleWith((_) => acquireUseRelease(_.time(label), () => self2, () => _.timeEnd(label))));

// node_modules/effect/dist/esm/Console.js
var TypeId14 = TypeId8;
var Console = consoleTag;
var withConsole2 = withConsole;
var setConsole2 = setConsole;
var consoleWith2 = consoleWith;
var assert2 = assert;
var clear3 = clear2;
var count2 = count;
var countReset2 = countReset;
var debug2 = debug;
var dir2 = dir;
var dirxml2 = dirxml;
var error2 = error;
var group3 = group2;
var info2 = info;
var log3 = log2;
var table2 = table;
var time2 = time;
var timeLog2 = timeLog;
var trace2 = trace;
var warn2 = warn;
var withGroup2 = withGroup;
var withTime2 = withTime;

// node_modules/effect/dist/esm/Effect.js
var exports_Effect = {};
__export(exports_Effect, {
  zipWith: () => zipWith7,
  zipRight: () => zipRight3,
  zipLeft: () => zipLeft2,
  zip: () => zip5,
  yieldNow: () => yieldNow4,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  withTracerTiming: () => withTracerTiming2,
  withTracerScoped: () => withTracerScoped2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracer: () => withTracer2,
  withSpanScoped: () => withSpanScoped2,
  withSpan: () => withSpan2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withScheduler: () => withScheduler2,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRequestCaching: () => withRequestCaching2,
  withRequestCache: () => withRequestCache2,
  withRequestBatching: () => withRequestBatching2,
  withRandomScoped: () => withRandomScoped2,
  withRandom: () => withRandom2,
  withParentSpan: () => withParentSpan2,
  withMetric: () => withMetric2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withLogSpan: () => withLogSpan2,
  withFiberRuntime: () => withFiberRuntime2,
  withExecutionPlan: () => withExecutionPlan2,
  withEarlyRelease: () => withEarlyRelease2,
  withConsoleScoped: () => withConsoleScoped2,
  withConsole: () => withConsole3,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConfigProvider: () => withConfigProvider2,
  withConcurrency: () => withConcurrency2,
  withClockScoped: () => withClockScoped2,
  withClock: () => withClock2,
  whileLoop: () => whileLoop2,
  whenRef: () => whenRef2,
  whenLogLevel: () => whenLogLevel2,
  whenFiberRef: () => whenFiberRef2,
  whenEffect: () => whenEffect2,
  when: () => when2,
  void: () => _void,
  validateWith: () => validateWith2,
  validateFirst: () => validateFirst2,
  validateAll: () => validateAll2,
  validate: () => validate2,
  using: () => using2,
  useSpan: () => useSpan2,
  updateService: () => updateService2,
  updateFiberRefs: () => updateFiberRefs2,
  unsandbox: () => unsandbox2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unlessEffect: () => unlessEffect2,
  unless: () => unless2,
  uninterruptibleMask: () => uninterruptibleMask3,
  uninterruptible: () => uninterruptible2,
  tryPromise: () => tryPromise2,
  tryMapPromise: () => tryMapPromise2,
  tryMap: () => tryMap2,
  try: () => try_2,
  transposeOption: () => transposeOption,
  transposeMapOption: () => transposeMapOption,
  transplant: () => transplant2,
  tracerWith: () => tracerWith4,
  tracer: () => tracer2,
  timeoutTo: () => timeoutTo2,
  timeoutOption: () => timeoutOption2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutFail: () => timeoutFail2,
  timeout: () => timeout2,
  timedWith: () => timedWith2,
  timed: () => timed2,
  tapErrorTag: () => tapErrorTag2,
  tapErrorCause: () => tapErrorCause2,
  tapError: () => tapError2,
  tapDefect: () => tapDefect2,
  tapBoth: () => tapBoth2,
  tap: () => tap2,
  takeWhile: () => takeWhile4,
  takeUntil: () => takeUntil2,
  tagMetricsScoped: () => tagMetricsScoped2,
  tagMetrics: () => tagMetrics2,
  sync: () => sync3,
  suspend: () => suspend3,
  supervised: () => supervised2,
  summarized: () => summarized2,
  succeedSome: () => succeedSome2,
  succeedNone: () => succeedNone2,
  succeed: () => succeed8,
  step: () => step3,
  spanLinks: () => spanLinks2,
  spanAnnotations: () => spanAnnotations2,
  sleep: () => sleep4,
  setFiberRefs: () => setFiberRefs2,
  serviceOptional: () => serviceOptional2,
  serviceOption: () => serviceOption2,
  serviceMembers: () => serviceMembers2,
  serviceFunctions: () => serviceFunctions2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunction: () => serviceFunction2,
  serviceConstants: () => serviceConstants2,
  sequentialFinalizers: () => sequentialFinalizers2,
  scopedWith: () => scopedWith2,
  scoped: () => scoped2,
  scopeWith: () => scopeWith2,
  scope: () => scope2,
  scheduleFrom: () => scheduleFrom,
  scheduleForked: () => scheduleForked2,
  schedule: () => schedule,
  sandbox: () => sandbox2,
  runtime: () => runtime4,
  runSyncExit: () => runSyncExit,
  runSync: () => runSync,
  runRequestBlock: () => runRequestBlock2,
  runPromiseExit: () => runPromiseExit,
  runPromise: () => runPromise,
  runFork: () => runFork2,
  runCallback: () => runCallback,
  retryOrElse: () => retryOrElse,
  retry: () => retry,
  request: () => request,
  replicateEffect: () => replicateEffect2,
  replicate: () => replicate3,
  repeatOrElse: () => repeatOrElse,
  repeatN: () => repeatN2,
  repeat: () => repeat,
  reduceWhile: () => reduceWhile2,
  reduceRight: () => reduceRight4,
  reduceEffect: () => reduceEffect2,
  reduce: () => reduce13,
  randomWith: () => randomWith2,
  random: () => random3,
  raceWith: () => raceWith2,
  raceFirst: () => raceFirst2,
  raceAll: () => raceAll2,
  race: () => race2,
  provideServiceEffect: () => provideServiceEffect2,
  provideService: () => provideService2,
  provide: () => provide2,
  promise: () => promise2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  patchFiberRefs: () => patchFiberRefs2,
  partition: () => partition4,
  parallelFinalizers: () => parallelFinalizers2,
  parallelErrors: () => parallelErrors2,
  orElseSucceed: () => orElseSucceed2,
  orElseFail: () => orElseFail2,
  orElse: () => orElse4,
  orDieWith: () => orDieWith2,
  orDie: () => orDie2,
  optionFromOptional: () => optionFromOptional2,
  option: () => option2,
  once: () => once3,
  onInterrupt: () => onInterrupt2,
  onExit: () => onExit3,
  onError: () => onError2,
  none: () => none9,
  never: () => never3,
  negate: () => negate2,
  metricLabels: () => metricLabels2,
  mergeAll: () => mergeAll4,
  merge: () => merge7,
  matchEffect: () => matchEffect2,
  matchCauseEffect: () => matchCauseEffect3,
  matchCause: () => matchCause2,
  match: () => match12,
  mapInputContext: () => mapInputContext2,
  mapErrorCause: () => mapErrorCause2,
  mapError: () => mapError2,
  mapBoth: () => mapBoth4,
  mapAccum: () => mapAccum4,
  map: () => map17,
  makeSpanScoped: () => makeSpanScoped2,
  makeSpan: () => makeSpan2,
  makeSemaphore: () => makeSemaphore2,
  makeLatch: () => makeLatch2,
  loop: () => loop2,
  logWithLevel: () => logWithLevel2,
  logWarning: () => logWarning2,
  logTrace: () => logTrace2,
  logInfo: () => logInfo2,
  logFatal: () => logFatal2,
  logError: () => logError2,
  logDebug: () => logDebug2,
  logAnnotations: () => logAnnotations2,
  log: () => log4,
  locallyWith: () => locallyWith,
  locallyScopedWith: () => locallyScopedWith,
  locallyScoped: () => locallyScoped,
  locally: () => locally,
  linkSpans: () => linkSpans2,
  linkSpanCurrent: () => linkSpanCurrent2,
  liftPredicate: () => liftPredicate3,
  let: () => let_4,
  labelMetricsScoped: () => labelMetricsScoped2,
  labelMetrics: () => labelMetrics2,
  iterate: () => iterate2,
  isSuccess: () => isSuccess3,
  isFailure: () => isFailure4,
  isEffect: () => isEffect2,
  intoDeferred: () => intoDeferred2,
  interruptibleMask: () => interruptibleMask2,
  interruptible: () => interruptible4,
  interruptWith: () => interruptWith2,
  interrupt: () => interrupt7,
  inheritFiberRefs: () => inheritFiberRefs2,
  ignoreLogged: () => ignoreLogged2,
  ignore: () => ignore2,
  if: () => if_2,
  head: () => head4,
  getRuntimeFlags: () => getRuntimeFlags,
  getFiberRefs: () => getFiberRefs,
  gen: () => gen2,
  functionWithSpan: () => functionWithSpan2,
  fromNullable: () => fromNullable4,
  fromFiberEffect: () => fromFiberEffect2,
  fromFiber: () => fromFiber2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  forkScoped: () => forkScoped2,
  forkIn: () => forkIn2,
  forkDaemon: () => forkDaemon2,
  forkAll: () => forkAll2,
  fork: () => fork3,
  forever: () => forever3,
  forEach: () => forEach9,
  fnUntraced: () => fnUntraced2,
  fn: () => fn,
  flipWith: () => flipWith2,
  flip: () => flip2,
  flatten: () => flatten7,
  flatMap: () => flatMap10,
  firstSuccessOf: () => firstSuccessOf2,
  findFirst: () => findFirst7,
  finalizersMask: () => finalizersMask2,
  filterOrFail: () => filterOrFail2,
  filterOrElse: () => filterOrElse2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrDie: () => filterOrDie2,
  filterMap: () => filterMap6,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterEffectOrElse: () => filterEffectOrElse2,
  filter: () => filter8,
  fiberIdWith: () => fiberIdWith2,
  fiberId: () => fiberId2,
  failSync: () => failSync2,
  failCauseSync: () => failCauseSync2,
  failCause: () => failCause7,
  fail: () => fail8,
  exit: () => exit2,
  exists: () => exists3,
  every: () => every6,
  eventually: () => eventually2,
  ensuringChildren: () => ensuringChildren2,
  ensuringChild: () => ensuringChild2,
  ensuring: () => ensuring2,
  either: () => either3,
  dropWhile: () => dropWhile4,
  dropUntil: () => dropUntil2,
  disconnect: () => disconnect2,
  diffFiberRefs: () => diffFiberRefs2,
  dieSync: () => dieSync2,
  dieMessage: () => dieMessage2,
  die: () => die5,
  descriptorWith: () => descriptorWith2,
  descriptor: () => descriptor2,
  delay: () => delay2,
  daemonChildren: () => daemonChildren2,
  custom: () => custom2,
  currentSpan: () => currentSpan2,
  currentParentSpan: () => currentParentSpan2,
  contextWithEffect: () => contextWithEffect2,
  contextWith: () => contextWith2,
  context: () => context3,
  consoleWith: () => consoleWith3,
  console: () => console3,
  configProviderWith: () => configProviderWith2,
  clockWith: () => clockWith4,
  clock: () => clock2,
  checkInterruptible: () => checkInterruptible2,
  cause: () => cause2,
  catchTags: () => catchTags2,
  catchTag: () => catchTag2,
  catchSomeDefect: () => catchSomeDefect2,
  catchSomeCause: () => catchSomeCause2,
  catchSome: () => catchSome2,
  catchIf: () => catchIf2,
  catchAllDefect: () => catchAllDefect2,
  catchAllCause: () => catchAllCause2,
  catchAll: () => catchAll2,
  catch: () => _catch2,
  cachedWithTTL: () => cachedWithTTL,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedFunction: () => cachedFunction2,
  cached: () => cached3,
  cacheRequestResult: () => cacheRequestResult,
  blocked: () => blocked2,
  bindTo: () => bindTo4,
  bindAll: () => bindAll2,
  bind: () => bind4,
  awaitAllChildren: () => awaitAllChildren2,
  asyncEffect: () => asyncEffect2,
  async: () => async,
  asVoid: () => asVoid4,
  asSomeError: () => asSomeError2,
  asSome: () => asSome2,
  as: () => as3,
  ap: () => ap,
  annotateSpans: () => annotateSpans2,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateLogs: () => annotateLogs2,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  andThen: () => andThen4,
  allowInterrupt: () => allowInterrupt2,
  allWith: () => allWith2,
  allSuccesses: () => allSuccesses2,
  all: () => all5,
  addFinalizer: () => addFinalizer3,
  acquireUseRelease: () => acquireUseRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireRelease: () => acquireRelease2,
  Tag: () => Tag3,
  Service: () => Service,
  EffectTypeId: () => EffectTypeId3,
  Do: () => Do3
});

// node_modules/effect/dist/esm/Data.js
var struct2 = struct;
var tagged2 = (tag) => (args2) => {
  const value = args2 === undefined ? Object.create(StructuralPrototype) : struct2(args2);
  value._tag = tag;
  return value;
};
var Class2 = Structural;
var TaggedClass = (tag) => {

  class Base3 extends Class2 {
    _tag = tag;
  }
  return Base3;
};
var taggedEnum = () => new Proxy({}, {
  get(_target, tag, _receiver) {
    if (tag === "$is") {
      return isTagged;
    } else if (tag === "$match") {
      return taggedMatch;
    }
    return tagged2(tag);
  }
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value2) {
      return cases2[value2._tag](value2);
    };
  }
  const value = arguments[0];
  const cases = arguments[1];
  return cases[value._tag](value);
}
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : undefined);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError = (tag) => {
  const O = {
    BaseEffectError: class extends Error3 {
      _tag = tag;
    }
  };
  O.BaseEffectError.prototype.name = tag;
  return O.BaseEffectError;
};

// node_modules/effect/dist/esm/internal/dateTime.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/DateTime");
var TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId15]: TypeId15,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol]() {
    return pipe(number2(this.epochMillis), combine(hash(this.zone)), cached(this));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol]() {
    return cached(this, string2(`Named:${this.id}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol]() {
    return cached(this, string2(`Offset:${this.offset}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var isDateTime = (u) => hasProperty(u, TypeId15);
var isTimeZone = (u) => hasProperty(u, TimeZoneTypeId);
var minEpochMillis = -8640000000000000 + 12 * 60 * 60 * 1000;
var maxEpochMillis = 8640000000000000 - 14 * 60 * 60 * 1000;
var toDateUtc = (self2) => new Date(self2.epochMillis);
var toDate = (self2) => {
  if (self2._tag === "Utc") {
    return new Date(self2.epochMillis);
  } else if (self2.zone._tag === "Offset") {
    return new Date(self2.epochMillis + self2.zone.offset);
  } else if (self2.adjustedEpochMillis !== undefined) {
    return new Date(self2.adjustedEpochMillis);
  }
  const parts2 = self2.zone.format.formatToParts(self2.epochMillis).filter((_) => _.type !== "literal");
  const date = new Date(0);
  date.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self2.adjustedEpochMillis = date.getTime();
  return date;
};
var zonedOffset = (self2) => {
  const date = toDate(self2);
  return date.getTime() - toEpochMillis(self2);
};
var offsetToString = (offset) => {
  const abs = Math.abs(offset);
  let hours2 = Math.floor(abs / (60 * 60 * 1000));
  let minutes2 = Math.round(abs % (60 * 60 * 1000) / (60 * 1000));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
};
var zonedOffsetIso = (self2) => offsetToString(zonedOffset(self2));
var toEpochMillis = (self2) => self2.epochMillis;
var formatIsoOffset = (self2) => {
  const date = toDate(self2);
  return self2._tag === "Utc" ? date.toISOString() : `${date.toISOString().slice(0, -1)}${zonedOffsetIso(self2)}`;
};
var formatIsoZoned = (self2) => self2.zone._tag === "Offset" ? formatIsoOffset(self2) : `${formatIsoOffset(self2)}[${self2.zone.id}]`;

// node_modules/effect/dist/esm/String.js
var Equivalence2 = string;

// node_modules/effect/dist/esm/Cron.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/Cron");
var CronProto = {
  [TypeId16]: TypeId16,
  [symbol2](that) {
    return isCron(that) && equals3(this, that);
  },
  [symbol]() {
    return pipe(hash(this.tz), combine(array2(fromIterable(this.seconds))), combine(array2(fromIterable(this.minutes))), combine(array2(fromIterable(this.hours))), combine(array2(fromIterable(this.days))), combine(array2(fromIterable(this.months))), combine(array2(fromIterable(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable(this.seconds),
      minutes: fromIterable(this.minutes),
      hours: fromIterable(this.hours),
      days: fromIterable(this.days),
      months: fromIterable(this.months),
      weekdays: fromIterable(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u) => hasProperty(u, TypeId16);
var Equivalence3 = /* @__PURE__ */ make((self2, that) => restrictionsEquals(self2.seconds, that.seconds) && restrictionsEquals(self2.minutes, that.minutes) && restrictionsEquals(self2.hours, that.hours) && restrictionsEquals(self2.days, that.days) && restrictionsEquals(self2.months, that.months) && restrictionsEquals(self2.weekdays, that.weekdays));
var restrictionsArrayEquals = /* @__PURE__ */ array(number);
var restrictionsEquals = (self2, that) => restrictionsArrayEquals(fromIterable(self2), fromIterable(that));
var equals3 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence3(self2, that));

// node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: undefined,
  elapsed: zero,
  elapsedSincePrevious: zero,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  _Out: (_) => _,
  _In: (_) => _,
  _R: (_) => _
};
var scheduleDriverVariance = {
  _Out: (_) => _,
  _In: (_) => _,
  _R: (_) => _
};

class ScheduleImpl {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step3) {
    this.initial = initial;
    this.step = step3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var updateInfo = (iterationMetaRef, now, input) => update3(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: zero,
  elapsedSincePrevious: zero,
  start: now
} : {
  now,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now - prev.start),
  elapsedSincePrevious: millis(now - prev.now),
  start: prev.start
});

class ScheduleDriverImpl {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule, ref) {
    this.schedule = schedule;
    this.ref = ref;
  }
  get state() {
    return map12(get10(this.ref), (tuple3) => tuple3[1]);
  }
  get last() {
    return flatMap8(get10(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException);
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake5(defaultIterationMetadata);
  get reset() {
    return set5(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set5(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map12(get10(this.ref), (tuple3) => tuple3[1]), flatMap8((state) => pipe(currentTimeMillis2, flatMap8((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap8(([state2, out, decision]) => {
      const setState = set5(this.ref, [some2(out), state2]);
      if (isDone5(decision)) {
        return setState.pipe(zipRight(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now;
      if (millis2 <= 0) {
        return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input)), as(out));
      }
      const duration = millis(millis2);
      return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input)), zipRight(sleep3(duration)), as(out));
    }))))));
  }
}
var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
var addDelay = /* @__PURE__ */ dual(2, (self2, f) => addDelayEffect(self2, (out) => sync(() => f(out))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration) => map12(f(out), (delay2) => sum(duration, decode(delay2)))));
var asVoid3 = (self2) => map16(self2, constVoid);
var check = /* @__PURE__ */ dual(2, (self2, test) => checkEffect(self2, (input, out) => sync(() => test(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self2, test) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done6]);
  }
  return map12(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
})));
var delayedSchedule = (schedule) => addDelay(schedule, (x) => x);
var driver = (self2) => pipe(make25([none2(), self2.initial]), map12((ref) => new ScheduleDriverImpl(self2, ref)));
var exponential2 = (baseInput, factor = 2) => {
  const base = decode(baseInput);
  return delayedSchedule(map16(forever2, (i) => times(base, Math.pow(factor, i))));
};
var intersect5 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now, input, state) => pipe(zipWith3(self2.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap8(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self2, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done6]);
}))));
var intersectWithLoop = (self2, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan6(rInterval))) {
    return flatMap8(self2.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done6]);
      }
      return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap8(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done6]);
    }
    return intersectWithLoop(self2, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
};
var map16 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect2(self2, (out) => sync(() => f(out))));
var mapEffect2 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => map12(f(out), (out2) => [state2, out2, decision]))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay2 = size10(make36(now, start2(intervals)));
  return map12(f(out, delay2), (durationInput) => {
    const duration = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now + toMillis(duration);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make36(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var passthrough = (self2) => makeWithState(self2.initial, (now, input, state) => pipe(self2.step(now, input, state), map12(([state2, _, decision]) => [state2, input, decision])));
var recurs = (n) => whileOutput(forever2, (out) => out < n);
var spaced = (duration) => addDelay(forever2, () => duration);
var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
var union9 = /* @__PURE__ */ dual(2, (self2, that) => unionWith2(self2, that, union8));
var unionWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now, input, state) => zipWith3(self2.step(now, input, state[0]), that.step(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
  if (isDone5(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], done6];
  }
  if (isDone5(lDecision) && isContinue2(rDecision)) {
    return [[lState, rState], [l, r], _continue2(rDecision.intervals)];
  }
  if (isContinue2(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], _continue2(lDecision.intervals)];
  }
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const combined = f(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l, r], _continue2(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})));
var untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_, out) => f(out)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");

class ScheduleDefect {
  error;
  [ScheduleDefectTypeId];
  constructor(error3) {
    this.error = error3;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
}
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => cause2,
  onSome: (error3) => fail(error3.error)
});
var scheduleDefectRefail = (effect) => catchAllCause(effect, (cause2) => failCause(scheduleDefectRefailCause(cause2)));
var repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => repeatOrElse_Effect(self2, schedule, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self2, options);
  }
  const base = options.schedule ?? passthrough(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map16((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self2, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule, orElse4) => flatMap8(driver(schedule), (driver2) => matchEffect(self2, {
  onFailure: (error3) => orElse4(error3, none2()),
  onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get10(driver2.iterationMeta)), driver2, (error3, option2) => provideServiceEffect(orElse4(error3, option2), CurrentIterationMetadata, get10(driver2.iterationMeta)), value)
})));
var repeatOrElseEffectLoop = (self2, driver2, orElse4, value) => matchEffect(driver2.next(value), {
  onFailure: () => orDie(driver2.last),
  onSuccess: (b) => matchEffect(self2, {
    onFailure: (error3) => orElse4(error3, some2(b)),
    onSuccess: (value2) => repeatOrElseEffectLoop(self2, driver2, orElse4, value2)
  })
});
var retry_Effect = /* @__PURE__ */ dual(2, (self2, policy) => retryOrElse_Effect(self2, policy, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self2, options);
  }
  return scheduleDefectRefail(retry_Effect(self2, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy, orElse4) => flatMap8(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get10(driver2.iterationMeta)), driver2, (e, out) => provideServiceEffect(orElse4(e, out), CurrentIterationMetadata, get10(driver2.iterationMeta)))));
var retryOrElse_EffectLoop = (self2, driver2, orElse4) => {
  return catchAll(self2, (e) => matchEffect(driver2.next(e), {
    onFailure: () => pipe(driver2.last, orDie, flatMap8((out) => orElse4(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self2, driver2, orElse4)
  }));
};
var schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => scheduleFrom_Effect(self2, undefined, schedule));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule) => flatMap8(driver(schedule), (driver2) => scheduleFrom_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get10(driver2.iterationMeta)), initial, driver2)));
var scheduleFrom_EffectLoop = (self2, initial, driver2) => matchEffect(driver2.next(initial), {
  onFailure: () => orDie(driver2.last),
  onSuccess: () => flatMap8(self2, (a) => scheduleFrom_EffectLoop(self2, a, driver2))
});
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var once2 = /* @__PURE__ */ asVoid3(/* @__PURE__ */ recurs(1));
var scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule) => forkScoped(schedule_Effect(self2, schedule)));

// node_modules/effect/dist/esm/internal/executionPlan.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/ExecutionPlan");
var withExecutionPlan = /* @__PURE__ */ dual(2, (effect, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap8(whileLoop({
    while: () => i < plan.steps.length && (result === undefined || isLeft2(result)),
    body: () => {
      const step3 = plan.steps[i];
      let nextEffect = effect_provide(effect, step3.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted)
            return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step3, false)));
      } else {
        const schedule = scheduleFromStep(step3, true);
        nextEffect = schedule ? scheduleDefectRefail(retry_Effect(nextEffect, schedule)) : nextEffect;
      }
      return either2(nextEffect);
    },
    step: (either3) => {
      result = either3;
      i++;
    }
  }), () => result);
}));
var scheduleFromStep = (step3, first2) => {
  if (!first2) {
    return fromRetryOptions({
      schedule: step3.schedule ? step3.schedule : step3.attempts ? undefined : once2,
      times: step3.attempts,
      while: step3.while
    });
  } else if (step3.attempts === 1 || !(step3.schedule || step3.attempts)) {
    return;
  }
  return fromRetryOptions({
    schedule: step3.schedule,
    while: step3.while,
    times: step3.attempts ? step3.attempts - 1 : undefined
  });
};

// node_modules/effect/dist/esm/MutableList.js
var TypeId18 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId18]: TypeId18,
  [Symbol.iterator]() {
    let done8 = false;
    let head4 = this.head;
    return {
      next() {
        if (done8) {
          return this.return();
        }
        if (head4 == null) {
          done8 = true;
          return this.return();
        }
        const value = head4.value;
        head4 = head4.next;
        return {
          done: done8,
          value
        };
      },
      return(value) {
        if (!done8) {
          done8 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value) => ({
  value,
  removed: false,
  prev: undefined,
  next: undefined
});
var empty34 = () => {
  const list = Object.create(MutableListProto);
  list.head = undefined;
  list.tail = undefined;
  list._length = 0;
  return list;
};
var isEmpty8 = (self2) => length2(self2) === 0;
var length2 = (self2) => self2._length;
var append3 = /* @__PURE__ */ dual(2, (self2, value) => {
  const node = makeNode(value);
  if (self2.head === undefined) {
    self2.head = node;
  }
  if (self2.tail === undefined) {
    self2.tail = node;
  } else {
    self2.tail.next = node;
    node.prev = self2.tail;
    self2.tail = node;
  }
  self2._length += 1;
  return self2;
});
var shift = (self2) => {
  const head4 = self2.head;
  if (head4 !== undefined) {
    remove8(self2, head4);
    return head4.value;
  }
  return;
};
var remove8 = (self2, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== undefined && node.next !== undefined) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== undefined) {
    self2.tail = node.prev;
    node.prev.next = undefined;
  } else if (node.next !== undefined) {
    self2.head = node.next;
    node.next.prev = undefined;
  } else {
    self2.tail = undefined;
    self2.head = undefined;
  }
  if (self2._length > 0) {
    self2._length -= 1;
  }
};

// node_modules/effect/dist/esm/MutableQueue.js
var TypeId19 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId19]: TypeId19,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make41 = (capacity) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty34();
  queue.capacity = capacity;
  return queue;
};
var bounded = (capacity) => make41(capacity);
var unbounded = () => make41(undefined);
var length3 = (self2) => length2(self2.queue);
var isEmpty9 = (self2) => isEmpty8(self2.queue);
var capacity = (self2) => self2.capacity === undefined ? Infinity : self2.capacity;
var offer = /* @__PURE__ */ dual(2, (self2, value) => {
  const queueLength = length2(self2.queue);
  if (self2.capacity !== undefined && queueLength === self2.capacity) {
    return false;
  }
  append3(value)(self2.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self2, values3) => {
  const iterator = values3[Symbol.iterator]();
  let next4;
  let remainder = empty6();
  let offering = true;
  while (offering && (next4 = iterator.next()) && !next4.done) {
    offering = offer(next4.value)(self2);
  }
  while (next4 != null && !next4.done) {
    remainder = prepend2(next4.value)(remainder);
    next4 = iterator.next();
  }
  return reverse2(remainder);
});
var poll4 = /* @__PURE__ */ dual(2, (self2, def) => {
  if (isEmpty8(self2.queue)) {
    return def;
  }
  return shift(self2.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self2, n) => {
  let result = empty6();
  let count3 = 0;
  while (count3 < n) {
    const element = poll4(EmptyMutableQueue)(self2);
    if (element === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element)(result);
    count3 += 1;
  }
  return reverse2(result);
});

// node_modules/effect/dist/esm/internal/cache.js
var complete3 = (key, exit2, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit2,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete4) => struct({
  _tag: "Refreshing",
  deferred,
  complete: complete4
});
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");

class MapKeyImpl {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = undefined;
  next = undefined;
  constructor(current) {
    this.current = current;
  }
  [symbol]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
}
var makeMapKey = (current) => new MapKeyImpl(current);
var isMapKey = (u) => hasProperty(u, MapKeyTypeId);

class KeySetImpl {
  head = undefined;
  tail = undefined;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === undefined) {
        this.head = key;
        this.tail = key;
      } else {
        const previous = key.previous;
        const next4 = key.next;
        if (next4 !== undefined) {
          key.next = undefined;
          if (previous !== undefined) {
            previous.next = next4;
            next4.previous = previous;
          } else {
            this.head = next4;
            this.head.previous = undefined;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== undefined) {
      const next4 = key.next;
      if (next4 !== undefined) {
        key.next = undefined;
        this.head = next4;
        this.head.previous = undefined;
      } else {
        this.head = undefined;
        this.tail = undefined;
      }
    }
    return key;
  }
}
var makeKeySet = () => new KeySetImpl;
var makeCacheState = (map17, keys6, accesses, updating, hits, misses) => ({
  map: map17,
  keys: keys6,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty26(), makeKeySet(), unbounded(), make13(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  _Key: (_) => _,
  _Error: (_) => _,
  _Value: (_) => _
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  _Key: (_) => _,
  _Error: (_) => _,
  _Value: (_) => _
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});

class CacheImpl {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity2, context3, fiberId2, lookup, timeToLive) {
    this.capacity = capacity2;
    this.context = context3;
    this.fiberId = fiberId2;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map12(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size5(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get12(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get12(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value, true)
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option2 = get12(this.cacheState.map, key);
      if (isSome2(option2)) {
        switch (option2.value._tag) {
          case "Complete": {
            const loaded = option2.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option2.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = undefined;
      let deferred = undefined;
      let value = getOrUndefined(get12(this.cacheState.map, k));
      if (value === undefined) {
        deferred = unsafeMake3(this.fiberId);
        mapKey = makeMapKey(k);
        if (has6(this.cacheState.map, k)) {
          value = getOrUndefined(get12(this.cacheState.map, k));
        } else {
          set7(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value === undefined) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map12(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap8(this.resolveMapValue(value), match2({
          onNone: () => this.getEither(key),
          onSome: (value2) => succeed(left2(value2))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove6(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when2) {
    return sync(() => {
      const value = get12(this.cacheState.map, key);
      if (isSome2(value) && value.value._tag === "Complete") {
        if (value.value.exit._tag === "Success") {
          if (when2(value.value.exit.value)) {
            remove6(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty26();
    });
  }
  refresh(key) {
    return clockWith3((clock2) => suspend(() => {
      const k = key;
      const deferred = unsafeMake3(this.fiberId);
      let value = getOrUndefined(get12(this.cacheState.map, k));
      if (value === undefined) {
        if (has6(this.cacheState.map, k)) {
          value = getOrUndefined(get12(this.cacheState.map, k));
        } else {
          set7(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value === undefined) {
        return asVoid(this.lookupValueOf(key, deferred));
      } else {
        switch (value._tag) {
          case "Complete": {
            if (this.hasExpired(clock2, value.timeToLiveMillis)) {
              const found = getOrUndefined(get12(this.cacheState.map, k));
              if (equals(found, value)) {
                remove6(this.cacheState.map, k);
              }
              return asVoid(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current = getOrUndefined(get12(this.cacheState.map, k));
              if (equals(current, value)) {
                const mapValue = refreshing(deferred, value);
                set7(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid);
          }
          case "Pending": {
            return _await(value.deferred);
          }
          case "Refreshing": {
            return _await(value.deferred);
          }
        }
      }
    }));
  }
  set(key, value) {
    return clockWith3((clock2) => sync(() => {
      const now = clock2.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed4(value);
      const mapValue = complete3(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
      set7(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size5(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values3 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values3.push(entry[1].exit.value);
        }
      }
      return values3;
    });
  }
  get entries() {
    return sync(() => {
      const values3 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values3.push([entry[0], entry[1].exit.value]);
        }
      }
      return values3;
    });
  }
  get keys() {
    return sync(() => {
      const keys6 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys6.push(entry[0]);
        }
      }
      return keys6;
    });
  }
  resolveMapValue(value, ignorePending = false) {
    return clockWith3((clock2) => {
      switch (value._tag) {
        case "Complete": {
          this.trackAccess(value.key);
          if (this.hasExpired(clock2, value.timeToLiveMillis)) {
            remove6(this.cacheState.map, value.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map12(value.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map12(_await(value.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value.complete.key);
          this.trackHit();
          if (this.hasExpired(clock2, value.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map12(_await(value.deferred), some2);
          }
          return map12(value.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop2 = true;
      while (loop2) {
        const key2 = poll4(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop2 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size11 = size5(this.cacheState.map);
      loop2 = size11 > this.capacity;
      while (loop2) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== undefined) {
          if (has6(this.cacheState.map, key2.current)) {
            remove6(this.cacheState.map, key2.current);
            size11 = size11 - 1;
            loop2 = size11 > this.capacity;
          }
        } else {
          loop2 = false;
        }
      }
      set3(this.cacheState.updating, false);
    }
  }
  hasExpired(clock2, timeToLiveMillis) {
    return clock2.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock2) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap8((exit2) => {
        const now = clock2.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now);
        const value = complete3(makeMapKey(key), exit2, stats, now + toMillis(decode(this.timeToLive(exit2))));
        set7(this.cacheState.map, key, value);
        return zipRight(done2(deferred, exit2), exit2);
      }), onInterrupt(() => zipRight(interrupt3(deferred), sync(() => {
        remove6(this.cacheState.map, key);
      }))));
    }));
  }
}
var unsafeMakeWith = (capacity2, lookup, timeToLive) => new CacheImpl(capacity2, empty5(), none3, lookup, (exit2) => decode(timeToLive(exit2)));

// node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map12(deferredMake(), (handle) => ({
  listeners: new Listeners,
  handle
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request, dataSource) => flatMap8(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
  const proxy = new Proxy(request, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached3 = fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap8(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached3);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap8(exit(blocked(empty20, restore(deferredAwait(orNew.left.handle)))), (exit2) => {
              orNew.left.listeners.decrement();
              return exit2;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap8(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id2,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached3;
    }
    const listeners = new Listeners;
    listeners.increment();
    return flatMap8(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id2,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(request), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_;
  });
};
var withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(2, (self2, cache) => fiberRefLocally(self2, currentCache, cache));

// node_modules/effect/dist/esm/Request.js
var isRequest2 = isRequest;

// node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all5 = all3;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile4 = dropWhile3;
var takeUntil2 = takeUntil;
var takeWhile4 = takeWhile3;
var every6 = every5;
var exists3 = exists2;
var filter8 = filter6;
var filterMap6 = filterMap5;
var findFirst7 = findFirst5;
var forEach9 = forEach8;
var head4 = head3;
var mergeAll4 = mergeAll2;
var partition4 = partition3;
var reduce13 = reduce11;
var reduceWhile2 = reduceWhile;
var reduceRight4 = reduceRight3;
var reduceEffect2 = reduceEffect;
var replicate3 = replicate2;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail8 = fail2;
var failSync2 = failSync;
var failCause7 = failCause;
var failCauseSync2 = failCauseSync;
var die5 = die2;
var dieMessage2 = dieMessage;
var dieSync2 = dieSync;
var gen2 = gen;
var never3 = never;
var none9 = none6;
var promise2 = promise;
var succeed8 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend3 = suspend;
var sync3 = sync;
var _void = void_;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll2 = catchAll;
var catchAllCause2 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_2 = try_;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt7 = interrupt2;
var interruptWith2 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate3 = liftPredicate2;
var as3 = as;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid4 = asVoid;
var flip2 = flip;
var flipWith2 = flipWith;
var map17 = map12;
var mapAccum4 = mapAccum3;
var mapBoth4 = mapBoth2;
var mapError2 = mapError;
var mapErrorCause2 = mapErrorCause;
var merge7 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope2 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith3 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole3 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext2 = mapInputContext;
var provide2 = effect_provide;
var provideService2 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do3 = Do2;
var bind4 = bind3;
var bindAll2 = bindAll;
var bindTo4 = bindTo3;
var let_4 = let_3;
var option2 = option;
var either3 = either2;
var exit2 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap10 = flatMap8;
var andThen4 = andThen2;
var flatten7 = flatten5;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap2 = tap;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError2 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause2 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop2 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs2 = updateFiberRefs;
var isFailure4 = isFailure;
var isSuccess3 = isSuccess;
var match12 = match8;
var matchCause2 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var log4 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs2 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie2 = orDie;
var orDieWith2 = orDieWith;
var orElse4 = orElse2;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip5 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight3 = zipRightOptions;
var zipWith7 = zipWithOptions;
var ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith7(self2, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans2 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan2 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan2 = withParentSpan;
var fromNullable4 = fromNullable3;
var optionFromOptional2 = optionFromOptional;
var transposeOption = (self2) => {
  return isNone(self2) ? succeedNone2 : map17(self2.value, some);
};
var transposeMapOption = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? succeedNone2 : map17(f(self2.value), some));
var makeTagProxy = (TagClass) => {
  const cache = new Map;
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn = (...args2) => andThen2(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen2(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen2(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen2(target, (s) => s[prop]);
      Object.assign(fn, cn);
      Object.setPrototypeOf(fn, Object.getPrototypeOf(cn));
      cache.set(prop, fn);
      return fn;
    }
  });
};
var Tag3 = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen2(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var Service = function() {
  return function() {
    const [id2, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = function(service) {
      if (patchState === "unchecked") {
        const proto4 = Object.getPrototypeOf(service);
        if (proto4 === Object.prototype || proto4 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto4);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service, Object.getPrototypeOf(this));
        return service;
      }
    };
    TagClass.prototype._tag = id2;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service) => new this(service);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen2(this, body);
      }
    });
    TagClass.key = id2;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect3(TagClass, map17(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect3(TagClass, map17(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped(TagClass, map17(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped(TagClass, map17(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync2(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed6(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
};
var fn = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error;
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
};
function defineLength(length4, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length4,
    configurable: true
  });
}
function fnApply(options) {
  let effect;
  let fnError = undefined;
  if (isGeneratorFunction(options.body)) {
    effect = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect = options.body.apply(options.self, options.args);
    } catch (error3) {
      fnError = error3;
      effect = die5(error3);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect = x(effect, ...options.args);
      }
    } catch (error3) {
      effect = fnError ? failCause7(sequential(die(fnError), die(error3))) : die5(error3);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split(`
`);
      const stackCall = options.errorCall.stack.trim().split(`
`);
      let endStackDef = stackDef.slice(2).join(`
`).trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join(`
`).trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan2(effect, options.spanName, opts);
}
var fnUntraced2 = fnUntraced;

// node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk = (f) => {
  let done8 = false;
  let a;
  return () => {
    if (done8) {
      return a;
    }
    a = f();
    done8 = true;
    return a;
  };
};
var formatDate = (date) => {
  try {
    return date.toISOString();
  } catch {
    return String(date);
  }
};
var formatUnknown = (u, checkCircular = true) => {
  if (Array.isArray(u)) {
    return `[${u.map((i) => formatUnknown(i, checkCircular)).join(",")}]`;
  }
  if (isDate(u)) {
    return formatDate(u);
  }
  if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  if (isString(u)) {
    return JSON.stringify(u);
  }
  if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  }
  if (isBigInt(u)) {
    return String(u) + "n";
  }
  if (isIterable(u)) {
    return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
  }
  try {
    if (checkCircular) {
      JSON.stringify(u);
    }
    const pojo = `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
    const name = u.constructor.name;
    return u.constructor !== Object.prototype.constructor ? `${name}(${pojo})` : pojo;
  } catch {
    return "<circular structure>";
  }
};
var formatPropertyKey = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
var isNonEmpty6 = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path) => isNonEmpty6(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

// node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== undefined) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getSchemaExtendErrorMessage = (x, y, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", undefined, undefined, ast);
var getASTUnsupportedLiteralErrorMessage = (literal) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown2, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown2;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => "<declaration schema>");
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var createASTGuard = (tag) => (ast) => ast._tag === tag;
class Literal {
  literal;
  annotations;
  _tag = "Literal";
  constructor(literal, annotations = {}) {
    this.literal = literal;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.literal));
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
class UniqueSymbol {
  symbol;
  annotations;
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations = {}) {
    this.symbol = symbol3;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
  }
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
class UndefinedKeyword {
  annotations;
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
class VoidKeyword {
  annotations;
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
class NeverKeyword {
  annotations;
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
class UnknownKeyword {
  annotations;
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
class AnyKeyword {
  annotations;
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
class StringKeyword {
  annotations;
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");

class NumberKeyword {
  annotations;
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");

class BooleanKeyword {
  annotations;
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");

class BigIntKeyword {
  annotations;
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
class SymbolKeyword {
  annotations;
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");

class ObjectKeyword {
  annotations;
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
class Type {
  type;
  annotations;
  constructor(type, annotations = {}) {
    this.type = type;
    this.annotations = annotations;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type);
  }
}

class OptionalType extends Type {
  isOptional;
  constructor(type, isOptional, annotations = {}) {
    super(type, annotations);
    this.isOptional = isOptional;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);

class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTuple(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head5, tail2) => {
      const formattedHead = String(head5);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail2.length > 0) {
        const formattedTail = tail2.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
class PropertySignature extends OptionalType {
  name;
  isReadonly;
  constructor(name, type, isOptional, isReadonly, annotations) {
    super(type, isOptional, annotations);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};

class IndexSignature {
  type;
  isReadonly;
  parameter;
  constructor(parameter, type, isReadonly) {
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}

class TypeLiteral {
  annotations;
  _tag = "TypeLiteral";
  propertySignatures;
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {}) {
    this.annotations = annotations;
    const keys6 = {};
    for (let i = 0;i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys6, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys6[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0;i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order2, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten8 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten8(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type = typeof ast.literal;
        switch (type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};

class Union {
  types;
  annotations;
  static make = (types, annotations) => {
    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
  };
  static unify = (candidates, annotations) => {
    return Union.make(unify(flatten8(candidates)), annotations);
  };
  _tag = "Union";
  constructor(types, annotations = {}) {
    this.types = types;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var mapMembers = (members, f) => members.map(f);
var isMembers = (as4) => as4.length > 1;
var isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => new WeakMap);

class Suspend {
  f;
  annotations;
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = memoizeThunk(f);
  }
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
  }
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
}
class Refinement {
  from;
  filter;
  annotations;
  _tag = "Refinement";
  constructor(from, filter9, annotations = {}) {
    this.from = from;
    this.filter = filter9;
    this.annotations = annotations;
  }
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};

class Transformation {
  from;
  to;
  transformation;
  annotations;
  _tag = "Transformation";
  constructor(from, to, transformation, annotations = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");

class FinalTransformation {
  decode;
  encode;
  _tag = "FinalTransformation";
  constructor(decode2, encode) {
    this.decode = decode2;
    this.encode = encode;
  }
}
var createTransformationGuard = (tag) => (ast) => ast._tag === tag;
class ComposeTransformation {
  _tag = "ComposeTransformation";
}
var composeTransformation = /* @__PURE__ */ new ComposeTransformation;
class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode2, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode2;
    this.encode = encode;
  }
}
class TypeLiteralTransformation {
  propertySignatureTransformations;
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
}
var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const value = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var STRING_KEYWORD_PATTERN = "[\\s\\S]*";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type, capture2) => {
  switch (type._tag) {
    case "Literal":
      return escape(String(type.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type, capture2, false);
    case "Union":
      return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture2)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type, s, capture2, top) => {
  if (isUnion(type)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture2, top) => {
  let pattern = ``;
  if (ast.head !== "") {
    const head5 = escape(ast.head);
    pattern += capture2 && top ? `(${head5})` : head5;
  }
  for (const span2 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture2);
    pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture2, top);
    if (span2.literal !== "") {
      const literal = escape(span2.literal);
      pattern += capture2 && top ? `(${literal})` : literal;
    }
  }
  return pattern;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var record = (key, value) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value, false, true));
        break;
      case "Union":
        key2.types.forEach(go);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = undefined;
  for (const id2 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id2)) {
      if (out === undefined) {
        out = {};
      }
      out[id2] = annotated.annotations[id2];
    }
  }
  return out;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id2 of annotationIds) {
    delete out[id2];
  }
  return out;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = typeAST(e.type);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type = typeAST(p.type);
        return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = typeAST(is.type);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
var createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier(annotated), {
  onNone: () => {
    return;
  },
  onSome: (identifier2) => ({
    [JSONIdentifierAnnotationId]: identifier2
  })
});
function changeMap(as4, f) {
  let changed = false;
  const out = allocate(as4.length);
  for (let i = 0;i < as4.length; i++) {
    const a = as4[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as4;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = encodedAST_(e.type, isBound);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type = encodedAST_(ps.type, isBound);
        return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = encodedAST_(is.type, isBound);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
      }
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return identifier2 ? annotations(from, identifier2) : from;
    }
    case "Transformation": {
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return encodedAST_(identifier2 ? annotations(ast.from, identifier2) : ast.from, isBound);
    }
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var toJSONAnnotations = (annotations2) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations2)) {
    out[String(k)] = annotations2[k];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var compose = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));

// node_modules/effect/dist/esm/ParseResult.js
class Pointer {
  path;
  actual;
  issue;
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}

class Unexpected {
  actual;
  message;
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
}

class Missing {
  ast;
  message;
  _tag = "Missing";
  actual = undefined;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
}

class Composite2 {
  ast;
  actual;
  issues;
  output;
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}

class Refinement2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Transformation2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Type2 {
  ast;
  actual;
  message;
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}

class Forbidden {
  ast;
  actual;
  message;
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
var isParseError = (u) => hasProperty(u, ParseErrorTypeId);

class ParseError extends (/* @__PURE__ */ TaggedError("ParseError")) {
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var parseError = (issue) => new ParseError({
  issue
});
var succeed9 = right2;
var fail9 = left2;
var fromOption4 = fromOption2;
var isEither3 = isEither2;
var flatMap11 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? match(self2, {
    onLeft: left2,
    onRight: f
  }) : flatMap10(self2, f);
});
var map18 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? map(self2, f) : map17(self2, f);
});
var mapError3 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? mapLeft(self2, f) : mapError2(self2, f);
});
var mapBoth5 = /* @__PURE__ */ dual(2, (self2, options) => {
  return isEither3(self2) ? mapBoth(self2, {
    onLeft: options.onFailure,
    onRight: options.onSuccess
  }) : mapBoth4(self2, options);
});
var orElse5 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? match(self2, {
    onLeft: f,
    onRight: right2
  }) : catchAll2(self2, f);
});
var mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
var decodeUnknown2 = (schema, options) => getEffect(schema.ast, true, options);
var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
var encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
var decodeSync = decodeUnknownSync;
var decode2 = decodeUnknown2;
var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
var is = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options, overrideOptions)
  }));
};
var encodeSync = encodeUnknownSync;
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap);
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap);
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse5(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption;
          const allErrors = options?.errors === "all";
          const result = flatMap11(orElse5(from(i, options), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options) => handleForbidden(flatMap11(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform2 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options) => handleForbidden(flatMap11(mapError3(from(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap11(mapError3(transform2(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError3(to(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden(parse3(i, options ?? defaultParseOption, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value]) => value === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len;i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = undefined;
        for (;i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap10(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head5, ...tail2] = rest;
          for (;i < len - tail2.length; i++) {
            const te = head5(input[i], options);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap10(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0;j < tail2.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail2[j](input[i], options);
              if (isEither3(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap10(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap10(forEach9(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is2) => [goMemo(is2.parameter, isDecoding), goMemo(is2.type, isDecoding), is2.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is2) => is2.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options);
            if (isEither3(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = undefined;
        const isExact = options?.exact === true;
        for (let i = 0;i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          if (isEither3(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap10(either3(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0;i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type = indexSignature[1];
          const keys6 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys6) {
            const keu = parameter(key, options);
            if (isEither3(keu) && isRight2(keu)) {
              const vpr = type(input[key], options);
              if (isEither3(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap10(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options?.propertyOrder === "original") {
            const keys6 = inputKeys || ownKeys(input);
            for (const name of expectedKeys) {
              if (keys6.indexOf(name) === -1) {
                keys6.push(name);
              }
            }
            const out = {};
            for (const key of keys6) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap10(forEach9(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys2 = ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys2.length;
      const astTypesLen = ast.types.length;
      const map19 = new Map;
      for (let i = 0;i < astTypesLen; i++) {
        map19.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0;i < ownKeysLen; i++) {
              const name = ownKeys2[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                  candidates = candidates.concat(buckets[literal]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = undefined;
        for (let i = 0;i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map19.get(candidate)(input, options);
          if (isEither3(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend3(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap10(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : left2(new Type2(ast, input));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es)
            };
            return flatMap10(forEach9(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get13 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
      return (a, options) => get13()(a, options);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0;i < ast.propertySignatures.length; i++) {
        const propertySignature = ast.propertySignatures[i];
        const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
        if (isLiteral(type) && !propertySignature.isOptional) {
          out.push([propertySignature.name, type]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0;i < ast.elements.length; i++) {
        const element = ast.elements[i];
        const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
        if (isLiteral(type) && !element.isOptional) {
          out.push([i, type]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys6 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0;i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      candidates.push(member);
      for (let j = 0;j < tags.length; j++) {
        const [key, literal] = tags[j];
        const hash2 = String(literal.literal);
        keys6[key] = keys6[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys6[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys6[key].literals.push(literal);
          keys6[key].candidates.push(member);
        } else {
          buckets[hash2] = [member];
          keys6[key].literals.push(literal);
          keys6[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys6,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect, ast, actual, options) => {
  if (options?.isEffectAllowed === true) {
    return effect;
  }
  if (isEither3(effect)) {
    return effect;
  }
  const scheduler = new SyncScheduler;
  const fiber = runFork2(effect, {
    scheduler
  });
  scheduler.flush();
  const exit3 = fiber.unsafePoll();
  if (exit3) {
    if (isSuccess2(exit3)) {
      return right2(exit3.value);
    }
    const cause3 = exit3.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty2(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map18(out, f);
        }
        return out;
      };
  }
};
var makeTree = (value, forest = []) => ({
  value,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map18(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither3(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error3) => TreeFormatter.formatIssue(error3.issue),
  formatErrorSync: (error3) => TreeFormatter.formatIssueSync(error3.issue)
};
var drawTree = (tree) => tree.value + draw(`
`, tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0;i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "└" : "├") + "─ " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "│  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
var Either_void = /* @__PURE__ */ right2(undefined);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union10 = messageAnnotation(issue);
    if (isString(union10)) {
      return right2({
        message: union10,
        override: false
      });
    }
    if (isEffect2(union10)) {
      return map17(union10, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union10.message)) {
      return right2({
        message: union10.message,
        override: union10.override
      });
    }
    return map17(union10.message, (message) => ({
      message,
      override: union10.override
    }));
  }
}));
var createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap11(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== undefined) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== undefined) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map18(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map18(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map18(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap11(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map18(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap11(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map18(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map18(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap11(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty6(issue.issues) ? map18(forEach9(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map18(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};

// node_modules/effect/dist/esm/Brand.js
var RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
var nominal = () => {
  return Object.assign((args2) => args2, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => some2(args2),
    either: (args2) => right2(args2),
    is: (_args) => true
  });
};

// node_modules/effect/dist/esm/FiberRef.js
var unsafeMake8 = fiberRefUnsafeMake;
var get13 = fiberRefGet;
var getWith = fiberRefGetWith;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentLogAnnotations2 = currentLogAnnotations;
var currentLoggers2 = currentLoggers;
var currentScheduler2 = currentScheduler;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;

// node_modules/effect/dist/esm/internal/layer/circular.js
var withMinimumLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(currentMinimumLogLevel, level)(self2));

// node_modules/effect/dist/esm/Layer.js
var isLayer2 = isLayer;
var buildWithScope2 = buildWithScope;
var context4 = context2;
var effect = fromEffect3;
var effectDiscard = fromEffectDiscard;
var merge8 = merge6;
var mergeAll5 = mergeAll3;
var scoped3 = scoped;
var succeed10 = succeed6;
var succeedContext2 = succeedContext;
var provide3 = provide;
var provideMerge2 = provideMerge;

// node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  _A: (_) => _
};
var backingQueueVariance = {
  _A: (_) => _
};
var enqueueVariance = {
  _In: (_) => _
};
var dequeueVariance = {
  _Out: (_) => _
};

class QueueImpl extends Class {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length3(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map12(this.size, (size11) => size11 <= 0);
  }
  get isFull() {
    return map12(this.size, (size11) => size11 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set3(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll4(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll4(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const values3 = fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values3.length)) : empty3;
      const [forTakers, remaining] = pipe(values3, splitAt(pTakers.length));
      for (let i = 0;i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values3 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values3);
      });
    });
  }
  takeUpTo(max7) {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values3 = this.queue.pollUpTo(max7);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable2(values3);
    }));
  }
  takeBetween(min5, max7) {
    return suspend(() => takeRemainderLoop(this, min5, max7, empty6()));
  }
}
var takeRemainderLoop = (self2, min5, max7, acc) => {
  if (max7 < min5) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self2, max7), flatMap8((bs) => {
    const remaining = min5 - bs.length;
    if (remaining === 1) {
      return pipe(take3(self2), map12((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take3(self2), flatMap8((b) => takeRemainderLoop(self2, remaining - 1, max7 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake9 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make43 = (queue, strategy) => pipe(deferredMake(), map12((deferred) => unsafeMake9(queue, unbounded(), deferred, make13(false), strategy)));

class BackingQueueFromMutableQueue {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable) {
    this.mutable = mutable;
  }
  poll(def) {
    return poll4(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element) {
    return offer(this.mutable, element);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length3(this.mutable);
  }
}
var backingQueueFromMutableQueue = (mutable) => new BackingQueueFromMutableQueue(mutable);
var capacity2 = (self2) => self2.capacity();
var size11 = (self2) => self2.size;
var isFull = (self2) => self2.isFull;
var isEmpty10 = (self2) => self2.isEmpty;
var isShutdown = (self2) => self2.isShutdown;
var awaitShutdown = (self2) => self2.awaitShutdown;
var shutdown = (self2) => self2.shutdown;
var offer2 = /* @__PURE__ */ dual(2, (self2, value) => self2.offer(value));
var offerAll2 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
var poll5 = (self2) => map12(self2.takeUpTo(1), head2);
var take3 = (self2) => self2.take;
var takeAll = (self2) => self2.takeAll;
var takeUpTo = /* @__PURE__ */ dual(2, (self2, max7) => self2.takeUpTo(max7));
var takeBetween = /* @__PURE__ */ dual(3, (self2, min5, max7) => self2.takeBetween(min5, max7));
var takeN = /* @__PURE__ */ dual(2, (self2, n) => self2.takeBetween(n, n));
var backPressureStrategy = () => new BackPressureStrategy;
var droppingStrategy = () => new DroppingStrategy;
var slidingStrategy = () => new SlidingStrategy;

class BackPressureStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /* @__PURE__ */ unbounded();
  surplusSize() {
    return length3(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty9(this.putters) && !isEmpty9(takers)) {
      const taker = poll4(takers, undefined);
      const putter = poll4(this.putters, undefined);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap8((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap8((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid) : void_, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown2) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll4(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable(iterable);
    for (let i = 0;i < stuff.length; i++) {
      const value = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value, deferred, true]));
      } else {
        pipe(this.putters, offer([value, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
  }
}

class DroppingStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {}
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {}
}

class SlidingStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {}
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {}
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next4;
    let offering = true;
    while (!(next4 = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next4.value);
    }
  }
}
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as4) => {
  return pipe(queue, offerAll(as4));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max7) => {
  return pipe(queue, pollUpTo(max7));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll4(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element = queue.poll(EmptyMutableQueue);
      if (element !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty9(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, new Set);
  }
  const set8 = subscribers.get(subscription);
  set8.add(pollers);
};
var removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set8 = subscribers.get(subscription);
  set8.delete(pollers);
  if (set8.size === 0) {
    subscribers.delete(subscription);
  }
};
var bounded3 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new BackPressureStrategy2);
});
var dropping2 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new DroppingStrategy2);
});
var sliding2 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new SlidingStrategy2);
});
var unbounded3 = (options) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options);
  return makePubSub(pubsub, new DroppingStrategy2);
});
var shutdown2 = (self2) => self2.shutdown;
var publish = /* @__PURE__ */ dual(2, (self2, value) => self2.publish(value));
var subscribe = (self2) => self2.subscribe;
var makeBoundedPubSub = (capacity3) => {
  const options = typeof capacity3 === "number" ? {
    capacity: capacity3
  } : capacity3;
  ensureCapacity(options.capacity);
  const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : undefined;
  if (options.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options.capacity) === options.capacity) {
    return new BoundedPubSubPow2(options.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options.capacity, replayBuffer);
  }
};
var makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : undefined);
var makeSubscription = (pubsub, subscribers, strategy) => map12(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make13(false), strategy));
var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());

class BoundedPubSubArb {
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity3, replayBuffer) {
    this.capacity = capacity3;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity3
    });
    this.subscribers = Array.from({
      length: capacity3
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty6();
    }
    const chunk2 = fromIterable2(elements);
    const n = chunk2.length;
    const size12 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size12;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk2;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet4(chunk2, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop2(chunk2, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubArbSubscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty6();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size12 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size12);
    if (toPoll <= 0) {
      return empty6();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
}

class BoundedPubSubPow2 {
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity3, replayBuffer) {
    this.capacity = capacity3;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity3
    });
    this.mask = capacity3 - 1;
    this.subscribers = Array.from({
      length: capacity3
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty6();
    }
    const chunk2 = fromIterable2(elements);
    const n = chunk2.length;
    const size12 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size12;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk2;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet4(chunk2, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop2(chunk2, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubPow2Subscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty6();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size12 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size12);
    if (toPoll <= 0) {
      return empty6();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
}

class BoundedPubSubSingle {
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty6();
    }
    const chunk2 = fromIterable2(elements);
    if (isEmpty(chunk2)) {
      return chunk2;
    }
    if (this.publish(unsafeHead2(chunk2))) {
      return drop2(chunk2, 1);
    } else {
      return chunk2;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubSingleSubscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty6();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
}

class UnboundedPubSub {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty6();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
}

class UnboundedPubSubSubscription {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty36 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty36 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty36;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
}

class SubscriptionImpl extends Class {
  pubsub;
  subscribers;
  subscription;
  pollers;
  shutdownHook;
  shutdownFlag;
  strategy;
  replayWindow;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map12(this.size, (size12) => size12 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set3(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty9(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const as4 = isEmpty9(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty6();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll2(this.replayWindow.takeAll(), as4));
      }
      return succeed(as4);
    });
  }
  takeUpTo(max7) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = undefined;
      if (this.replayWindow.remaining >= max7) {
        const as5 = this.replayWindow.takeN(max7);
        return succeed(as5);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max7 = max7 - replay.length;
      }
      const as4 = isEmpty9(this.pollers) ? unsafePollN2(this.subscription, max7) : empty6();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll2(replay, as4)) : succeed(as4);
    });
  }
  takeBetween(min5, max7) {
    return suspend(() => takeRemainderLoop2(this, min5, max7, empty6()));
  }
}
var takeRemainderLoop2 = (self2, min5, max7, acc) => {
  if (max7 < min5) {
    return succeed(acc);
  }
  return pipe(self2.takeUpTo(max7), flatMap8((bs) => {
    const remaining = min5 - bs.length;
    if (remaining === 1) {
      return pipe(self2.take, map12((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(self2.take, flatMap8((b) => takeRemainderLoop2(self2, remaining - 1, max7 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};

class PubSubImpl {
  pubsub;
  subscribers;
  scope;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, scope4, shutdownHook, shutdownFlag, strategy) {
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope4;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.pubsub.size());
  }
  get isFull() {
    return map12(this.size, (size12) => size12 === this.capacity());
  }
  get isEmpty() {
    return map12(this.size, (size12) => size12 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set3(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
    }));
  }
  publish(value) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value), this.shutdownFlag);
    });
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire = tap(all3([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple3) => tuple3[0].addFinalizer(() => tuple3[1].shutdown));
    return map12(acquireRelease(acquire, (tuple3, exit3) => tuple3[0].close(exit3)), (tuple3) => tuple3[1]);
  }
  offer(value) {
    return this.publish(value);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var makePubSub = (pubsub, strategy) => flatMap8(scopeMake(), (scope4) => map12(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, new Map, scope4, deferred, make13(false), strategy)));
var unsafeMakePubSub = (pubsub, subscribers, scope4, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope4, shutdownHook, shutdownFlag, strategy);
var ensureCapacity = (capacity3) => {
  if (capacity3 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity3}`);
  }
};
var unsafeCompleteDeferred2 = (deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll2 = (queue, as4) => {
  return pipe(queue, offerAll(as4));
};
var unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
var unsafePollN2 = (subscription, max7) => {
  return subscription.pollUpTo(max7);
};
var unsafePublishAll = (pubsub, as4) => {
  return pubsub.publishAll(as4);
};
var unsafeRemove2 = (queue, value) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter3((elem) => elem !== value)));
};

class BackPressureStrategy2 {
  publishers = /* @__PURE__ */ unbounded();
  get shutdown() {
    return flatMap8(fiberId, (fiberId3) => flatMap8(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last4]) => last4 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid) : void_, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown2) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll4(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next4 = iterator.next();
    if (!next4.done) {
      while (true) {
        const value = next4.value;
        next4 = iterator.next();
        if (next4.done) {
          pipe(this.publishers, offer([value, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter3(([_, a]) => a !== deferred)));
  }
}

class DroppingStrategy2 {
  get shutdown() {
    return void_;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
}

class SlidingStrategy2 {
  get shutdown() {
    return void_;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next4 = it.next();
    if (!next4.done && pubsub.capacity > 0) {
      let a = next4.value;
      let loop3 = true;
      while (loop3) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next4 = it.next()) && !next4.done) {
          a = next4.value;
        } else if (pub) {
          loop3 = false;
        }
      }
    }
  }
}
var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll4(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty9(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
};
var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
};

class ReplayBuffer {
  capacity;
  constructor(capacity3) {
    this.capacity = capacity3;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as4) {
    for (const a of as4) {
      this.offer(a);
    }
  }
}

class ReplayWindowImpl {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer) {
    this.buffer = buffer;
    this.index = buffer.index;
    this.remaining = buffer.size;
    this.head = buffer.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value = this.head.value;
    this.head = this.head.next;
    return value;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty6();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0;i < len; i++) {
      const value = this.head.value;
      this.head = this.head.next;
      items[i] = value;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
}
var emptyReplayWindow = {
  remaining: 0,
  take: () => {
    return;
  },
  takeN: () => empty6(),
  takeAll: () => empty6()
};

// node_modules/effect/dist/esm/PubSub.js
var bounded4 = bounded3;
var dropping3 = dropping2;
var sliding3 = sliding2;
var unbounded4 = unbounded3;
var shutdown3 = shutdown2;
var publish2 = publish;
var subscribe2 = subscribe;

// node_modules/effect/dist/esm/Queue.js
var DequeueTypeId2 = DequeueTypeId;
var bounded5 = bounded2;
var dropping4 = dropping;
var sliding4 = sliding;
var unbounded5 = unbounded2;
var capacity4 = capacity2;
var size13 = size11;
var isEmpty12 = isEmpty10;
var isFull3 = isFull;
var isShutdown3 = isShutdown;
var awaitShutdown3 = awaitShutdown;
var shutdown4 = shutdown;
var offer3 = offer2;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take4 = take3;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_CONTINUE2;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutDone: (_) => _,
  _OutErr2: (_) => _,
  _OutElem: (_) => _,
  _OutDone2: (_) => _
};

class ContinuationKImpl {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit3) {
    return isFailure2(exit3) ? this.onHalt(exit3.cause) : this.onSuccess(exit3.value);
  }
}

class ContinuationFinalizerImpl {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer) {
    this.finalizer = finalizer;
  }
}

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  _A: (_) => _
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutElem: (_) => _,
  _OutDone: (_) => _
};
var proto6 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self2, release) => {
  const op = Object.create(proto6);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self2;
  op.finalizer = release;
  return op;
});
var catchAllCause4 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(succeed11, f);
  return op;
});
var collectElements = (self2) => {
  return suspend4(() => {
    const builder = [];
    return flatMap13(pipeTo(self2, collectElementsReader(builder)), (value) => sync4(() => [fromIterable2(builder), value]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap13(sync4(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail11,
  onDone: succeedNow
});
var concatAllWith = (channels, f, g) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = /* @__PURE__ */ dual(4, (self2, f, g, h) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self2;
  op.k = f;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self2, input) => {
  const op = Object.create(proto6);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self2;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self2, finalizer) => {
  const op = Object.create(proto6);
  op._tag = OP_ENSURING;
  op.channel = self2;
  op.finalizer = finalizer;
  return op;
});
var fail11 = (error3) => failCause9(fail5(error3));
var failCause9 = (cause3) => failCauseSync4(() => cause3);
var failCauseSync4 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_FAIL3;
  op.error = evaluate2;
  return op;
};
var flatMap13 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(f, failCause9);
  return op;
});
var foldCauseChannel = /* @__PURE__ */ dual(2, (self2, options) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
var fromEffect4 = (effect2) => {
  const op = Object.create(proto6);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect2;
  return op;
};
var pipeTo = /* @__PURE__ */ dual(2, (self2, that) => {
  const op = Object.create(proto6);
  op._tag = OP_PIPE_TO;
  op.left = () => self2;
  op.right = () => that;
  return op;
});
var provideContext3 = /* @__PURE__ */ dual(2, (self2, env) => {
  const op = Object.create(proto6);
  op._tag = OP_PROVIDE2;
  op.context = () => env;
  op.inner = self2;
  return op;
});
var readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options.onFailure,
    onRight: failCause9
  }),
  onDone: options.onDone
});
var readWithCause = (options) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
};
var succeed11 = (value) => sync4(() => value);
var succeedNow = (result) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend4 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate2;
  return op;
};
var sync4 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate2;
  return op;
};
var void_5 = /* @__PURE__ */ succeedNow(undefined);
var write = (out) => {
  const op = Object.create(proto6);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  _E: (_) => _,
  _R: (_) => _
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto7);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto7);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect5 = (effect2) => {
  const op = Object.create(proto7);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect2;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone) => {
  const op = Object.create(proto7);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone;
  return op;
};
var isFromEffect = (self2) => self2._tag === OP_FROM_EFFECT3;
var effect2 = (self2) => isFromEffect(self2) ? self2.effect : _void;
var effectOrUndefinedIgnored = (self2) => isFromEffect(self2) ? ignore2(self2.effect) : undefined;

// node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";

class PullFromChild {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.childExecutor.close(exit3);
    const fin2 = this.parentSubexecutor.close(exit3);
    if (fin1 !== undefined && fin2 !== undefined) {
      return zipWith7(exit2(fin1), exit2(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
    } else if (fin1 !== undefined) {
      return fin1;
    } else if (fin2 !== undefined) {
      return fin2;
    } else {
      return;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}

class PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== undefined && next4 !== undefined) {
        return zipWith7(acc, exit2(next4), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== undefined) {
        return acc;
      } else if (next4 !== undefined) {
        return exit2(next4);
      } else {
        return;
      }
    }, undefined);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(child) {
    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
}

class DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== undefined && next4 !== undefined) {
        return zipWith7(acc, exit2(next4), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== undefined) {
        return acc;
      } else if (next4 !== undefined) {
        return exit2(next4);
      } else {
        return;
      }
    }, undefined);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(child) {
    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
}

class Emit2 {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value, next4) {
    this.value = value;
    this.next = next4;
  }
  close(exit3) {
    const result = this.next.close(exit3);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  _A: (_) => _
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value) => {
  const op = Object.create(proto8);
  op._tag = OP_PULLED;
  op.value = value;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto8);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};

// node_modules/effect/dist/esm/internal/channel/channelExecutor.js
class ChannelExecutor {
  _activeSubexecutor = undefined;
  _cancelled = undefined;
  _closeLastSubstream = undefined;
  _currentChannel;
  _done = undefined;
  _doneStack = [];
  _emitted = undefined;
  _executeCloseLastSubstream;
  _input = undefined;
  _inProgressFinalizer = undefined;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = undefined;
    while (result === undefined) {
      if (this._cancelled !== undefined) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== undefined) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === undefined) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect4(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== undefined) {
                  const inputExecutor = this._input;
                  this._input = undefined;
                  const drainer = () => flatMap10(bridgeInput.awaitRead(), () => suspend3(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match9(inputExecutor.getDone(), {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: (value) => bridgeInput.done(value)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap10(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  }));
                  result = fromEffect5(flatMap10(forkDaemon2(interruptible4(drainer())), (fiber) => sync3(() => this.addFinalizer((exit3) => flatMap10(interrupt6(fiber), () => suspend3(() => {
                    const effect3 = this.restorePipe(exit3, inputExecutor);
                    return effect3 !== undefined ? effect3 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect3) => sync3(() => {
                  const prevLastClose = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight3(effect3));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value) => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value) => channel.onEmit(value));
                this._closeLastSubstream = undefined;
                this._currentChannel = undefined;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== undefined ? undefined : void_5;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect3 = this._providedEnv === undefined ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect5(matchCauseEffect3(effect3, {
                  onFailure: (cause3) => {
                    const state = this.doneHalt(cause3);
                    return state !== undefined && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value) => {
                    const state = this.doneSucceed(value);
                    return state !== undefined && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect3) => this._executeCloseLastSubstream(effect3));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit3) => {
                  const effect3 = this.restorePipe(exit3, previousInput);
                  return effect3 !== undefined ? effect3 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync3(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read.more(emitted);
                  } catch (error3) {
                    this._currentChannel = read.done.onExit(die3(error3));
                  }
                  return;
                }, (exit3) => {
                  const onExit4 = (exit4) => {
                    return read.done.onExit(exit4);
                  };
                  this._currentChannel = onExit4(exit3);
                  return;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error3) {
          this._currentChannel = failCause9(die4(error3));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit3) {
    this._cancelled = exit3;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = undefined;
  }
  storeInProgressFinalizer(finalizer) {
    this._inProgressFinalizer = finalizer;
  }
  popAllFinalizers(exit3) {
    const finalizers = [];
    let next4 = this._doneStack.pop();
    while (next4) {
      if (next4._tag === "ContinuationFinalizer") {
        finalizers.push(next4.finalizer);
      }
      next4 = this._doneStack.pop();
    }
    const effect3 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit3);
    this.storeInProgressFinalizer(effect3);
    return effect3;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit3, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== undefined) {
      const effect3 = currInput.close(exit3);
      return effect3;
    }
    return _void;
  }
  close(exit3) {
    let runInProgressFinalizers = undefined;
    const finalizer = this._inProgressFinalizer;
    if (finalizer !== undefined) {
      runInProgressFinalizers = pipe(finalizer, ensuring2(sync3(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = undefined;
    const selfFinalizers = this.popAllFinalizers(exit3);
    if (selfFinalizers !== undefined) {
      closeSelf = pipe(selfFinalizers, ensuring2(sync3(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit3);
    if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {
      return;
    }
    return pipe(exit2(ifNotNull(closeSubexecutors)), zip5(exit2(ifNotNull(runInProgressFinalizers))), zip5(exit2(ifNotNull(closeSelf))), map17(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))), uninterruptible2, flatMap10((exit4) => suspend3(() => exit4)));
  }
  doneSucceed(value) {
    if (this._doneStack.length === 0) {
      this._done = succeed4(value);
      this._currentChannel = undefined;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head5.onSuccess(value);
      return;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed4(value);
      this._currentChannel = undefined;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed4(value));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap10(() => sync3(() => this.doneSucceed(value))));
    return fromEffect5(effect3);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause4(cause3);
      this._currentChannel = undefined;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head5.onHalt(cause3);
      } catch (error3) {
        this._currentChannel = failCause9(die4(error3));
      }
      return;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause4(cause3);
      this._currentChannel = undefined;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause4(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap10(() => sync3(() => this.doneHalt(cause3))));
    return fromEffect5(effect3);
  }
  processCancellation() {
    this._currentChannel = undefined;
    this._done = this._cancelled;
    this._cancelled = undefined;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect3 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync3(() => {
        this._currentChannel = failCause9(cause3);
      }),
      onSuccess: (out) => sync3(() => {
        this.addFinalizer((exit3) => this.provide(bracketOut.finalizer(out, exit3)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect5(effect3);
  }
  provide(effect3) {
    if (this._providedEnv === undefined) {
      return effect3;
    }
    return pipe(effect3, provide2(this._providedEnv));
  }
  runEnsuring(ensuring3) {
    this.addFinalizer(ensuring3.finalizer);
    this._currentChannel = ensuring3.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = undefined;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit3) {
    const state = match9(exit3, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value) => this.doneSucceed(value)
    });
    this._activeSubexecutor = undefined;
    return state === undefined ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach9((closeFunc) => pipe(sync3(() => closeFunc(subexecutorDone)), flatMap10((closeEffect) => closeEffect !== undefined ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match9({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value) => this.doneSucceed(value)
    }));
    this._activeSubexecutor = undefined;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
        return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return;
    }, match9({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === undefined ? undefined : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed4(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed4(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause4(cause3), (exit3) => parentSubexecutor.close(exit3), (exit3) => childExecutor.close(exit3));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === undefined) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect3) => {
      const closeLastSubstream = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
      this._closeLastSubstream = undefined;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight3(effect3));
    }, (emitted) => {
      if (this._closeLastSubstream !== undefined) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = undefined;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map17(() => {
          const childExecutor2 = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return;
        }));
      }
      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return;
    }, (exit3) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== undefined)) {
        const drain = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== undefined) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = undefined;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map17(() => this.replaceSubexecutor(drain)));
        }
        this.replaceSubexecutor(drain);
        return;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit3, map13((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit4) => subexecutor.upstreamExecutor.close(exit4));
      return state === undefined ? undefined : effectOrUndefinedIgnored(state);
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== undefined) {
        this.addFinalizer(() => succeed8(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit3) => subexecutor.upstreamExecutor.close(exit3));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === undefined) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return;
  }
}
var ifNotNull = (effect3) => effect3 !== undefined ? effect3 : _void;
var runFinalizers = (finalizers, exit3) => {
  return pipe(forEach9(finalizers, (fin) => exit2(fin(exit3))), map17((exits) => pipe(all2(exits), getOrElse(() => void_3))), flatMap10((exit4) => suspend3(() => exit4)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read = () => {
    const current = readStack.pop();
    if (current === undefined || current.upstream === undefined) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current.onEmit(current.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === undefined) {
            return suspend3(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === undefined) {
          return suspend3(() => read());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current.onDone(current.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === undefined) {
            return suspend3(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === undefined) {
          return suspend3(() => read());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current);
        return pipe(current.onEffect(state.effect), catchAllCause2((cause3) => suspend3(() => {
          const doneEffect = current.onDone(failCause4(cause3));
          return doneEffect === undefined ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_READ2: {
        readStack.push(current);
        readStack.push(state);
        return suspend3(() => read());
      }
    }
  };
  return read();
};
var runIn = /* @__PURE__ */ dual(2, (self2, scope4) => {
  const run = (channelDeferred, scopeDeferred, scope5) => acquireUseRelease2(sync3(() => new ChannelExecutor(self2, undefined, identity)), (exec) => suspend3(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight3(_await(channelDeferred)), zipLeft2(_await(scopeDeferred)))), (exec, exit3) => {
    const finalize = exec.close(exit3);
    if (finalize === undefined) {
      return _void;
    }
    return tapErrorCause2(finalize, (cause3) => addFinalizer2(scope5, failCause7(cause3)));
  });
  return uninterruptibleMask3((restore) => all5([fork2(scope4, sequential3), make24(), make24()]).pipe(flatMap10(([child, channelDeferred, scopeDeferred]) => restore(run(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope4), flatMap10((fiber) => scope4.addFinalizer((exit3) => {
    const interruptors3 = isFailure2(exit3) ? interruptors2(exit3.cause) : undefined;
    return isDone(channelDeferred).pipe(flatMap10((isDone6) => isDone6 ? succeed2(scopeDeferred, undefined).pipe(zipRight3(_await3(fiber)), zipRight3(inheritAll2(fiber))) : succeed2(scopeDeferred, undefined).pipe(zipRight3(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll3(interruptors3)) : interrupt6(fiber)), zipRight3(inheritAll2(fiber)))));
  }).pipe(zipRight3(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap10(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend3(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause7);
    }
  }
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Done3 = (effect3) => {
  const op = Object.create(proto9);
  op._tag = OP_DONE4;
  op.effect = effect3;
  return op;
};
var Await = (f) => {
  const op = Object.create(proto9);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto10);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
};
var RightDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var match14 = /* @__PURE__ */ dual(2, (self2, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self2._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
});
var stateDone = (done8) => ({
  _tag: OP_STATE_DONE2,
  done: done8
});

class SingleProducerAsyncInputImpl {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten7(modify4(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId3) => this.error(interrupt5(fiberId3)));
  }
  done(value) {
    return flatten7(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach9(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value)), {
            discard: true
          }), stateDone(value)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  emit(element) {
    return flatMap10(make24(), (deferred) => flatten7(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== undefined) {
            return [succeed2(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten7(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach9(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause4(map14(cause3, left2)), (elem) => succeed4(elem), (done8) => fail4(right2(done8)));
  }
  takeWith(onError3, onElement, onDone) {
    return flatMap10(make24(), (deferred) => flatten7(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight3(succeed2(state.notifyProducer, undefined), matchCause2(_await(deferred), {
            onFailure: onError3,
            onSuccess: match({
              onLeft: onDone,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause2(_await(deferred), {
            onFailure: onError3,
            onSuccess: match({
              onLeft: onDone,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed8(onError3(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed8(onDone(state.done)), state];
        }
      }
    })));
  }
}
var make44 = () => pipe(make24(), flatMap10((deferred) => make26(stateEmpty(deferred))), map17((ref) => new SingleProducerAsyncInputImpl(ref)));

// node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire, use, release) => flatMap13(fromEffect4(make26(() => _void)), (ref) => pipe(fromEffect4(uninterruptible2(tap2(acquire, (a) => set6(ref, (exit3) => release(a, exit3))))), flatMap13(use), ensuringWith((exit3) => flatMap10(get11(ref), (f) => f(exit3)))));
var as4 = /* @__PURE__ */ dual(2, (self2, value) => map20(self2, () => value));
var catchAll4 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause4(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause9
})));
var concatMap = /* @__PURE__ */ dual(2, (self2, f) => concatMapWith(self2, f, () => {
  return;
}, () => {
  return;
}));
var drain = (self2) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause9,
    onDone: succeed11
  });
  return pipeTo(self2, drainer);
};
var ensuring3 = /* @__PURE__ */ dual(2, (self2, finalizer) => ensuringWith(self2, () => finalizer));
var flatten10 = (self2) => flatMap13(self2, identity);
var foldChannel = /* @__PURE__ */ dual(2, (self2, options) => foldCauseChannel(self2, {
  onFailure: (cause3) => {
    const either4 = failureOrCause2(cause3);
    switch (either4._tag) {
      case "Left": {
        return options.onFailure(either4.left);
      }
      case "Right": {
        return failCause9(either4.right);
      }
    }
  },
  onSuccess: options.onSuccess
}));
var fromInput = (input) => unwrap(input.takeWith(failCause9, (elem) => flatMap13(write(elem), () => fromInput(input)), succeed11));
var fromQueue = (queue) => suspend4(() => fromQueueInternal(queue));
var fromQueueInternal = (queue) => pipe(fromEffect4(take4(queue)), flatMap13(match({
  onLeft: match9({
    onFailure: failCause9,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap13(write(elem), () => fromQueueInternal(queue))
})));
var identityChannel = () => readWith({
  onInput: (input) => flatMap13(write(input), () => identityChannel()),
  onFailure: fail11,
  onDone: succeedNow
});
var interruptWhen = /* @__PURE__ */ dual(2, (self2, effect3) => mergeWith2(self2, {
  other: fromEffect4(effect3),
  onSelfDone: (selfDone) => Done3(suspend3(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend3(() => effectDone))
}));
var interruptWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => interruptWhen(self2, _await(deferred)));
var map20 = /* @__PURE__ */ dual(2, (self2, f) => flatMap13(self2, (a) => sync4(() => f(a))));
var mapError5 = /* @__PURE__ */ dual(2, (self2, f) => mapErrorCause3(self2, map14(f)));
var mapErrorCause3 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause4(self2, (cause3) => failCause9(f(cause3))));
var mapOut = /* @__PURE__ */ dual(2, (self2, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap13(write(f(outElem)), () => reader),
    onFailure: fail11,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect4(f(outElem)), flatMap13(write), flatMap13(() => reader)),
    onFailure: failCause9,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffectPar = /* @__PURE__ */ dual(3, (self2, f, n) => unwrapScopedWith((scope4) => gen2(function* () {
  const input = yield* make44();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(n);
  yield* addFinalizer2(scope4, shutdown4(queue));
  const errorSignal = yield* make24();
  const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self2), toPullIn(scope4));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause7(cause3)),
    onSuccess: match({
      onLeft: (outDone) => zipRight3(interruptible4(withPermits(n)(_void)), asVoid4(offer3(queue, succeed8(left2(outDone))))),
      onRight: (outElem) => gen2(function* () {
        const deferred = yield* make24();
        const latch = yield* make24();
        yield* offer3(queue, map17(_await(deferred), right2));
        yield* succeed2(latch, undefined).pipe(zipRight3(uninterruptibleMask3((restore) => exit2(restore(_await(errorSignal))).pipe(raceFirst2(exit2(restore(f(outElem)))), flatMap10(identity))).pipe(tapErrorCause2((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope4));
        yield* _await(latch);
      })
    })
  }), forever3, interruptible4, forkIn2(scope4));
  const consumer = unwrap(matchCause2(flatten7(take4(queue)), {
    onFailure: failCause9,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap13(write(outElem), () => consumer)
    })
  }));
  return embedInput(consumer, input);
})));
var mergeAll6 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
};
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope4) => gen2(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make44();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(bufferSize);
  yield* addFinalizer2(scope4, shutdown4(queue));
  const cancelers = yield* unbounded5();
  yield* addFinalizer2(scope4, shutdown4(cancelers));
  const lastDone = yield* make26(none2());
  const errorSignal = yield* make24();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope4);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap10(match({
      onLeft: (done8) => succeed8(some2(done8)),
      onRight: (outElem) => as3(offer3(queue, succeed8(right2(outElem))), none2())
    })), repeat({
      until: (_) => isSome2(_)
    }), flatMap10((outDone) => update4(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
    }))), catchAllCause2((cause3) => isInterrupted3(cause3) ? failCause7(cause3) : offer3(queue, failCause7(cause3)).pipe(zipRight3(succeed2(errorSignal, undefined)), asVoid4)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause7(cause3)).pipe(zipRight3(succeed8(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as3(interrupt6(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight3(interrupt6(failureAwait), get11(lastDone).pipe(flatMap10(match2({
          onNone: () => offer3(queue, succeed8(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed8(left2(f(lastDone2, outDone))))
        })), as3(false)))
      }),
      onRight: (channel) => match14(mergeStrategy, {
        onBackPressure: () => gen2(function* () {
          const latch = yield* make24();
          const raceEffects = scopedWith2((scope5) => toPullIn(pipeTo(queueReader, channel), scope5).pipe(flatMap10((pull2) => race2(exit2(evaluatePull(pull2)), exit2(interruptible4(_await(errorSignal))))), flatMap10(identity)));
          yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope4));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen2(function* () {
          const canceler = yield* make24();
          const latch = yield* make24();
          const size14 = yield* size13(cancelers);
          yield* take4(cancelers).pipe(flatMap10((canceler2) => succeed2(canceler2, undefined)), when2(() => size14 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope5) => toPullIn(pipeTo(queueReader, channel), scope5).pipe(flatMap10((pull2) => exit2(evaluatePull(pull2)).pipe(race2(exit2(interruptible4(_await(errorSignal)))), race2(exit2(interruptible4(_await(canceler)))))), flatMap10(identity)));
          yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope4));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_) => _
  }), forkIn2(scope4));
  const consumer = pipe(take4(queue), flatten7, matchCause2({
    onFailure: failCause9,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap13(write(outElem), () => consumer)
    })
  }), unwrap);
  return embedInput(consumer, input);
}));
var mergeMap = /* @__PURE__ */ dual(3, (self2, f, options) => mergeAll6(options)(mapOut(self2, f)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self2, options) => {
  function merge9(scope4) {
    return gen2(function* () {
      const input = yield* make44();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self2), scope4);
      const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope4);
      function handleSide(exit3, fiber, pull) {
        return (done8, both2, single2) => {
          function onDecision(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed8(fromEffect4(zipRight3(interrupt6(fiber), op.effect)));
            }
            return map17(_await3(fiber), match9({
              onFailure: (cause3) => fromEffect4(op.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done9) => fromEffect4(op.f(succeed4(done9))),
                onRight: (elem) => zipRight4(write(elem), go2(single2(op.f)))
              })
            }));
          }
          return match9(exit3, {
            onFailure: (cause3) => onDecision(done8(failCause4(cause3))),
            onSuccess: match({
              onLeft: (z) => onDecision(done8(succeed4(z))),
              onRight: (elem) => succeed8(flatMap13(write(elem), () => flatMap13(fromEffect4(forkIn2(interruptible4(pull), scope4)), (leftFiber) => go2(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      function go2(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join3(state.left));
            const rightJoin = interruptible4(join3(state.right));
            return unwrap(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight3(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))),
              onOtherDone: (rightExit, lf) => zipRight3(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap(map17(exit2(pullR), match9({
              onFailure: (cause3) => fromEffect4(state.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed4(done8))),
                onRight: (elem) => flatMap13(write(elem), () => go2(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap(map17(exit2(pullL), match9({
              onFailure: (cause3) => fromEffect4(state.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed4(done8))),
                onRight: (elem) => flatMap13(write(elem), () => go2(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect4(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope4));
        const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope4));
        return zipWith7(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap13(go2), embedInput(input));
    });
  }
  return unwrapScopedWith(merge9);
});
var orDieWith3 = /* @__PURE__ */ dual(2, (self2, f) => catchAll4(self2, (e) => failCauseSync4(() => die4(f(e)))));
var orElse7 = /* @__PURE__ */ dual(2, (self2, that) => catchAll4(self2, that));
var pipeToOrFail = /* @__PURE__ */ dual(2, (self2, that) => suspend4(() => {
  let channelException = undefined;
  const reader = readWith({
    onInput: (outElem) => flatMap13(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause9(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap13(() => writer)),
    onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail11(cause3.defect.error) : failCause9(cause3),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self2, reader), that), writer);
}));
var repeated = (self2) => flatMap13(self2, () => repeated(self2));
var run = (self2) => scopedWith2((scope4) => runIn(self2, scope4));
var runDrain = (self2) => run(drain(self2));
var runScoped = (self2) => scopeWith2((scope4) => runIn(self2, scope4));
var scoped4 = (effect3) => unwrap(uninterruptibleMask3((restore) => map17(make39(), (scope4) => acquireReleaseOut(tapErrorCause2(restore(extend3(effect3, scope4)), (cause3) => close(scope4, failCause4(cause3))), (_, exit3) => close(scope4, exit3)))));
var scopedWith3 = (f) => unwrapScoped2(map17(scope2, (scope4) => flatMap13(fromEffect4(f(scope4)), write)));
var splitLines = () => suspend4(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk2) => {
    const chunkBuilder = [];
    map6(chunk2, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf(`
`);
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf(`
`, from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf(`
`, from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf(`
`, from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop3 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop3 : flatMap13(write(out), () => loop3);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause9(cause3) : flatMap13(write(of2(stringBuilder)), () => failCause9(cause3)),
    onDone: (done8) => stringBuilder.length === 0 ? succeed11(done8) : flatMap13(write(of2(stringBuilder)), () => succeed11(done8))
  });
  return loop3;
});
var toPubSub = (pubsub) => toQueue(pubsub);
var toPull = (self2) => flatMap10(scope2, (scope4) => toPullIn(self2, scope4));
var toPullIn = /* @__PURE__ */ dual(2, (self2, scope4) => zip5(sync3(() => new ChannelExecutor(self2, undefined, identity)), runtime4()).pipe(tap2(([executor, runtime5]) => addFinalizerExit(scope4, (exit3) => {
  const finalizer = executor.close(exit3);
  return finalizer !== undefined ? provide2(finalizer, runtime5) : _void;
})), uninterruptible2, map17(([executor]) => suspend3(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match9(exec.getDone(), {
        onFailure: failCause7,
        onSuccess: (done8) => succeed8(left2(done8))
      });
    }
    case OP_EMIT2: {
      return succeed8(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap10(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause7(cause3));
    }
  }
};
var toQueue = (queue) => suspend4(() => toQueueInternal(queue));
var toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap13(fromEffect4(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect4(pipe(offer3(queue, left2(failCause4(cause3))))),
    onDone: (done8) => fromEffect4(pipe(offer3(queue, left2(succeed4(done8)))))
  });
};
var unwrap = (channel) => flatten10(fromEffect4(channel));
var unwrapScoped2 = (self2) => concatAllWith(scoped4(self2), (d, _) => d, (d, _) => d);
var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
var withSpan4 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire = all5([makeSpan2(name, options), context3(), clock2, get13(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self2 = arguments[0];
    return acquireUseRelease3(acquire, ([span3, context5]) => provideContext3(self2, add2(context5, spanTag, span3)), ([span3, , clock3, timingEnabled], exit3) => endSpan(span3, exit3, clock3, timingEnabled));
  }
  return (self2) => acquireUseRelease3(acquire, ([span3, context5]) => provideContext3(self2, add2(context5, spanTag, span3)), ([span3, , clock3, timingEnabled], exit3) => endSpan(span3, exit3, clock3, timingEnabled));
};
var writeAll = (...outs) => writeChunk(fromIterable2(outs));
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk2) => {
  return idx === len ? void_5 : pipe(write(pipe(chunk2, unsafeGet4(idx))), flatMap13(() => writeChunkWriter(idx + 1, len, chunk2)));
};
var zip6 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? mergeWith2(self2, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend3(() => zip3(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend3(() => zip3(exit1, exit22)))
}) : flatMap13(self2, (a) => map20(that, (b) => [a, b])));
var zipLeft3 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map20(zip6(self2, that, {
  concurrent: true
}), (tuple3) => tuple3[0]) : flatMap13(self2, (z) => as4(that, z)));
var zipRight4 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map20(zip6(self2, that, {
  concurrent: true
}), (tuple3) => tuple3[1]) : flatMap13(self2, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error3) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error3
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  _A: (_) => _,
  _In: (_) => _,
  _L: (_) => _,
  _E: (_) => _,
  _R: (_) => _
};

class SinkImpl {
  channel;
  [SinkTypeId2] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isSink = (u) => hasProperty(u, SinkTypeId2);
var suspend5 = (evaluate2) => new SinkImpl(suspend4(() => toChannel(evaluate2())));
var collectAll = () => new SinkImpl(collectAllLoop(empty6()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk2) => collectAllLoop(pipe(acc, appendAll2(chunk2))),
  onFailure: failCause9,
  onDone: () => succeed11(acc)
});
var collectAllN = (n) => suspend5(() => fromChannel(collectAllNLoop(n, empty6())));
var collectAllNLoop = (n, acc) => readWithCause({
  onInput: (chunk2) => {
    const [collected, leftovers] = splitAt2(chunk2, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed11(appendAll2(acc, collected));
    }
    return flatMap13(write(leftovers), () => succeed11(appendAll2(acc, collected)));
  },
  onFailure: failCause9,
  onDone: () => succeed11(acc)
});
var collectLeftover = (self2) => new SinkImpl(pipe(collectElements(toChannel(self2)), map20(([chunks, z]) => [z, flatten2(chunks)])));
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var fail12 = (e) => new SinkImpl(fail11(e));
var fold = (s, contFn, f) => suspend5(() => new SinkImpl(foldReader(s, contFn, f)));
var foldReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (isNonEmpty(leftovers)) {
        return pipe(write(leftovers), as4(nextS));
      }
      return foldReader(nextS, contFn, f);
    },
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplit = (s, chunk2, contFn, f, index, length4) => {
  if (index === length4) {
    return [s, empty6()];
  }
  const s1 = f(s, pipe(chunk2, unsafeGet4(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk2, contFn, f, index + 1, length4);
  }
  return [s1, pipe(chunk2, drop2(index + 1))];
};
var foldSink = /* @__PURE__ */ dual(2, (self2, options) => {
  const newChannel = pipe(toChannel(self2), collectElements, foldChannel({
    onFailure: (error3) => toChannel(options.onFailure(error3)),
    onSuccess: ([leftovers, z]) => suspend4(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter3(isNonEmpty))
      };
      const refReader = pipe(sync4(() => {
        const ref = leftoversRef.ref;
        leftoversRef.ref = empty6();
        return ref;
      }), flatMap13((chunk2) => writeChunk(chunk2)));
      const passthrough3 = identityChannel();
      const continuationSink = pipe(refReader, zipRight4(passthrough3), pipeTo(toChannel(options.onSuccess(z))));
      return flatMap13(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed11(leftoversRef.ref), flatMap13(writeChunk), zipRight4(writeChunk(newLeftovers)), as4(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = (s, contFn, f) => suspend5(() => new SinkImpl(foldChunksReader(s, contFn, f)));
var foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldEffect = (s, contFn, f) => suspend5(() => new SinkImpl(foldEffectReader(s, contFn, f)));
var foldEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect4(foldChunkSplitEffect(s, input, contFn, f)), flatMap13(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f),
      onSome: (leftover) => pipe(write(leftover), as4(nextS))
    })))),
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplitEffect = (s, chunk2, contFn, f) => foldChunkSplitEffectInternal(s, chunk2, 0, chunk2.length, contFn, f);
var foldChunkSplitEffectInternal = (s, chunk2, index, length4, contFn, f) => {
  if (index === length4) {
    return succeed8([s, none2()]);
  }
  return pipe(f(s, pipe(chunk2, unsafeGet4(index))), flatMap10((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk2, index + 1, length4, contFn, f) : succeed8([s1, some2(pipe(chunk2, drop2(index + 1)))])));
};
var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
var flatMap14 = /* @__PURE__ */ dual(2, (self2, f) => foldSink(self2, {
  onFailure: fail12,
  onSuccess: f
}));
var forEach10 = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect4(forEach9(input, (v) => f(v), {
      discard: true
    })), flatMap13(() => process2)),
    onFailure: failCause9,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachChunk = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect4(f(input)), flatMap13(() => process2)),
    onFailure: failCause9,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachWhile = (f) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
    onFailure: failCause9,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachWhileReader = (f, input, index, length4, cont) => {
  if (index === length4) {
    return cont;
  }
  return pipe(fromEffect4(f(pipe(input, unsafeGet4(index)))), flatMap13((bool) => bool ? forEachWhileReader(f, input, index + 1, length4, cont) : write(pipe(input, drop2(index)))), catchAll4((error3) => pipe(write(pipe(input, drop2(index))), zipRight4(fail11(error3)))));
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect6 = (effect3) => new SinkImpl(fromEffect4(effect3));
var head5 = () => fold(none2(), isNone2, (option3, input) => match2(option3, {
  onNone: () => some2(input),
  onSome: () => option3
}));
var last4 = () => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s));
var map21 = /* @__PURE__ */ dual(2, (self2, f) => {
  return new SinkImpl(pipe(toChannel(self2), map20(f)));
});
var raceWith3 = /* @__PURE__ */ dual(2, (self2, options) => {
  function race3(scope4) {
    return gen2(function* () {
      const pubsub = yield* bounded4(options?.capacity ?? 16);
      const subscription1 = yield* extend3(subscribe2(pubsub), scope4);
      const subscription2 = yield* extend3(subscribe2(pubsub), scope4);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self2)), zipLeft3(fromEffect4(shutdown4(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft3(fromEffect4(shutdown4(subscription2)))),
        onSelfDone: options.onSelfDone,
        onOtherDone: options.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: () => Await(identity),
        onOtherDone: (exit3) => Done3(exit3)
      });
      return new SinkImpl(racedChannel);
    });
  }
  return unwrapScopedWith2(race3);
});
var sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + reduce2(chunk2, 0, (s, a) => s + a));
var toChannel = (self2) => isEffect2(self2) ? toChannel(fromEffect6(self2)) : self2.channel;
var unwrapScoped3 = (effect3) => new SinkImpl(unwrapScoped2(effect3.pipe(map17((sink) => toChannel(sink)))));
var unwrapScopedWith2 = (f) => new SinkImpl(unwrapScopedWith((scope4) => f(scope4).pipe(map17((sink) => toChannel(sink)))));
var zipRight5 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, options) => zipWith8(self2, that, (_, z2) => z2, options));
var zipWith8 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, f, options) => options?.concurrent ? raceWith3(self2, {
  other: that,
  onSelfDone: match9({
    onFailure: (cause3) => Done3(failCause7(cause3)),
    onSuccess: (leftZ) => Await(match9({
      onFailure: failCause7,
      onSuccess: (rightZ) => succeed8(f(leftZ, rightZ))
    }))
  }),
  onOtherDone: match9({
    onFailure: (cause3) => Done3(failCause7(cause3)),
    onSuccess: (rightZ) => Await(match9({
      onFailure: failCause7,
      onSuccess: (leftZ) => succeed8(f(leftZ, rightZ))
    }))
  })
}) : flatMap14(self2, (z) => map21(that, (z2) => f(z, z2))));
var count3 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + chunk2.length);
var mkString = /* @__PURE__ */ suspend5(() => {
  const strings = [];
  return pipe(foldLeftChunks(undefined, (_, elems) => map6(elems, (elem) => {
    strings.push(String(elem));
  })), map21(() => strings.join("")));
});

// node_modules/effect/dist/esm/MergeDecision.js
var Done4 = Done3;
var Await2 = Await;

// node_modules/effect/dist/esm/internal/rcRef.js
var TypeId20 = /* @__PURE__ */ Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance8 = {
  _A: identity,
  _E: identity
};

class RcRefImpl extends Class {
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId20] = variance8;
  [TypeId10] = TypeId10;
  state = stateEmpty2;
  semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  constructor(acquire, context5, scope4, idleTimeToLive) {
    super();
    this.acquire = acquire;
    this.context = context5;
    this.scope = scope4;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get14(this);
  }
  get;
  commit() {
    return this.get;
  }
}
var make45 = (options) => withFiberRuntime((fiber) => {
  const context5 = fiber.getFiberRef(currentContext);
  const scope4 = get3(context5, scopeTag);
  const ref = new RcRefImpl(options.acquire, context5, scope4, options.idleTimeToLive ? decode(options.idleTimeToLive) : undefined);
  return as(scope4.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_;
    ref.state = stateClosed;
    return close2;
  }))), ref);
});
var get14 = (self_) => {
  const self2 = self_;
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self2.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self2.state.refCount++;
        return self2.state.fiber ? as(interruptFiber(self2.state.fiber), self2.state) : succeed(self2.state);
      }
      case "Empty": {
        return scopeMake().pipe(bindTo3("scope"), bind3("value", ({
          scope: scope4
        }) => restore(fiberRefLocally(self2.acquire, currentContext, add2(self2.context, scopeTag, scope4)))), map12(({
          scope: scope4,
          value
        }) => {
          const state = {
            _tag: "Acquired",
            value,
            scope: scope4,
            fiber: undefined,
            refCount: 1
          };
          self2.state = state;
          return state;
        }));
      }
    }
  })).pipe(self2.semaphore.withPermits(1), bindTo3("state"), bind3("scope", () => scopeTag), tap(({
    scope: scope4,
    state
  }) => scope4.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0) {
      return void_;
    }
    if (self2.idleTimeToLive === undefined) {
      self2.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self2.idleTimeToLive).pipe(interruptible2, zipRight(suspend(() => {
      if (self2.state._tag === "Acquired" && self2.state.refCount === 0) {
        self2.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_;
    })), ensuring(sync(() => {
      state.fiber = undefined;
    })), forkIn(self2.scope), tap((fiber) => {
      state.fiber = fiber;
    }), self2.semaphore.withPermits(1));
  }))), map12(({
    state
  }) => state.value));
};

// node_modules/effect/dist/esm/RcRef.js
var make46 = make45;
var get15 = get14;

// node_modules/effect/dist/esm/Runtime.js
var runFork3 = unsafeFork2;
var runPromiseExit2 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;
var make47 = make40;
var updateContext3 = updateContext2;

// node_modules/effect/dist/esm/Schedule.js
var driver2 = driver;
var exponential3 = exponential2;
var forever4 = forever2;
var spaced2 = spaced;
var union10 = union9;
var CurrentIterationMetadata2 = CurrentIterationMetadata;

// node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either = {
  _tag: OP_EITHER
};
var fromInput2 = (input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};

// node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2 = Both;

// node_modules/effect/dist/esm/internal/stm/versioned.js
class Versioned {
  value;
  constructor(value) {
    this.value = value;
  }
}

// node_modules/effect/dist/esm/internal/stm/entry.js
var make48 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet7 = (self2) => {
  return self2.newValue;
};
var unsafeSet = (self2, value) => {
  self2.isChanged = true;
  self2.newValue = value;
};
var commit = (self2) => {
  self2.ref.versioned = new Versioned(self2.newValue);
};
var isInvalid = (self2) => {
  return self2.ref.versioned !== self2.expected;
};
var isChanged = (self2) => {
  return self2.isChanged;
};

// node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var collectTodos = (journal) => {
  const allTodos = new Map;
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = new Map;
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning3 = (self2) => {
  return self2._tag === OP_RUNNING2;
};
var isDone6 = (self2) => {
  return self2._tag === OP_DONE6;
};
var done8 = (exit3) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit3,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
    }
  };
};
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted2 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done8(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done8(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done8(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done8(succeed4(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance9 = {
  _A: (_) => _,
  _E: (_) => _
};
var isExit2 = (u) => hasProperty(u, TExitTypeId);
var isSuccess4 = (self2) => {
  return self2._tag === OP_SUCCEED3;
};
var isRetry = (self2) => {
  return self2._tag === OP_RETRY2;
};
var fail13 = (error3) => ({
  [TExitTypeId]: variance9,
  _tag: OP_FAIL5,
  error: error3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error3, that.error);
  }
});
var die7 = (defect) => ({
  [TExitTypeId]: variance9,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt8 = (fiberId3) => ({
  [TExitTypeId]: variance9,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
});
var succeed13 = (value) => ({
  [TExitTypeId]: variance9,
  _tag: OP_SUCCEED3,
  value,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
  }
});
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry3 = {
  [TExitTypeId]: variance9,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit2(that) && isRetry(that);
  }
};

// node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done9 = (exit3) => {
  return {
    _tag: OP_DONE5,
    exit: exit3
  };
};
var suspend6 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make49 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};

class STMPrimitive {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  [EffectTypeId3];
  [StreamTypeId];
  [SinkTypeId2];
  [ChannelTypeId2];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var unsafeAtomically = (self2, onDone, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self2, env, scheduler, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make49();
      const state2 = {
        value: running3
      };
      const effect3 = async((k) => tryCommitAsync(fiberId3, self2, txnId, state2, env, scheduler, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect3), catchAllCause2((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted2;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause7(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId3, stm, state, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed4(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend6(journal);
    }
  }
};
var tryCommitSync = (fiberId3, stm, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed4(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause4(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend6(journal);
    }
  }
};
var tryCommitAsync = (fiberId3, self2, txnId, state, context5, scheduler, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId3, self2, state, context5, scheduler, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self2, txnId, state, context5, scheduler, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit3, journal, scheduler, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => execTodos(todos), priority);
  }
  return done9(exit3);
};
var completeTryCommit = (exit3, k) => {
  k(exit3);
};
class STMDriver {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self2, journal, fiberId3, r0) {
    this.self = self2;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current = this.popStack();
    }
    return current;
  }
  nextFailure() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current = this.popStack();
    }
    return current;
  }
  nextRetry() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_RETRY) {
      current = this.popStack();
    }
    return current;
  }
  run() {
    let curr = this.self;
    let exit3 = undefined;
    while (exit3 === undefined && curr !== undefined) {
      try {
        const current = curr;
        if (current) {
          switch (current._op) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet3(env, current));
              break;
            }
            case "Left": {
              curr = fail14(current.left);
              break;
            }
            case "None": {
              curr = fail14(new NoSuchElementException2);
              break;
            }
            case "Right": {
              curr = succeed14(current.right);
              break;
            }
            case "Some": {
              curr = succeed14(current.value);
              break;
            }
            case "Commit": {
              switch (current.effect_instruction_i0) {
                case OP_DIE2: {
                  exit3 = die7(internalCall(() => current.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === undefined) {
                    exit3 = fail13(internalCall(() => current.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === undefined) {
                    exit3 = retry3;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit3 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current);
                  curr = current.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current.effect_instruction_i2(env));
                  curr = pipe(current.effect_instruction_i1, ensuring5(sync6(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value = current.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed13(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value = internalCall(() => current.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed13(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die8(e);
      }
    }
    return exit3;
  }
}
var catchAll5 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die8 = (defect) => dieSync4(() => defect);
var dieSync4 = (evaluate2) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var effect3 = (f) => withSTMRuntime((_) => succeed14(f(_.journal, _.fiberId, _.getEnv())));
var ensuring5 = /* @__PURE__ */ dual(2, (self2, finalizer) => matchSTM(self2, {
  onFailure: (e) => zipRight7(finalizer, fail14(e)),
  onSuccess: (a) => zipRight7(finalizer, succeed14(a))
}));
var fail14 = (error3) => failSync5(() => error3);
var failSync5 = (evaluate2) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var flatMap15 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => pipe(self2, map22(right2), catchAll5((e) => pipe(onFailure(e), map22(left2))), flatMap15((either5) => {
  switch (either5._tag) {
    case "Left": {
      return succeed14(either5.left);
    }
    case "Right": {
      return onSuccess(either5.right);
    }
  }
})));
var withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
var interruptAs2 = (fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
};
var map22 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap15((a) => sync6(() => f(a)))));
var retry4 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed14 = (value) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value;
  return stm;
};
var sync6 = (evaluate2) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var zipRight7 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap15(() => that)));
var zipWith10 = /* @__PURE__ */ dual(3, (self2, that, f) => pipe(self2, flatMap15((a) => pipe(that, map22((b) => f(a, b))))));

// node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// node_modules/effect/dist/esm/internal/stm/stm.js
var as6 = /* @__PURE__ */ dual(2, (self2, value) => pipe(self2, map22(() => value)));
var flatten11 = (self2) => flatMap15(self2, identity);
var forEach11 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
  if (options?.discard) {
    return pipe(sync6(() => iterable[Symbol.iterator]()), flatMap15((iterator) => {
      const loop3 = suspend7(() => {
        const next4 = iterator.next();
        if (next4.done) {
          return void_6;
        }
        return pipe(f(next4.value), flatMap15(() => loop3));
      });
      return loop3;
    }));
  }
  return suspend7(() => fromIterable(iterable).reduce((acc, curr) => zipWith10(acc, f(curr), (array4, elem) => {
    array4.push(elem);
    return array4;
  }), succeed14([])));
});
var all6 = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach11(input, identity, options);
  } else if (options?.discard) {
    return forEach11(Object.values(input), identity, options);
  }
  return map22(forEach11(Object.entries(input), ([_, e]) => map22(e, (a) => [_, a])), (values3) => {
    const res = {};
    for (const [k, v] of values3) {
      res[k] = v;
    }
    return res;
  });
};
var suspend7 = (evaluate2) => flatten11(sync6(evaluate2));
var tap4 = /* @__PURE__ */ dual(2, (self2, f) => flatMap15(self2, (a) => as6(f(a), a)));
var void_6 = /* @__PURE__ */ succeed14(undefined);

// node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  _A: (_) => _
};

class TRefImpl {
  [TRefTypeId] = tRefVariance;
  todos;
  versioned;
  constructor(value) {
    this.versioned = new Versioned(value);
    this.todos = new Map;
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet7(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make50 = (value) => effect3((journal) => {
  const ref = new TRefImpl(value);
  journal.set(ref, make48(ref, true));
  return ref;
});
var get16 = (self2) => self2.modify((a) => [a, a]);
var set8 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [undefined, value]));
var getOrMakeEntry = (self2, journal) => {
  if (journal.has(self2)) {
    return journal.get(self2);
  }
  const entry = make48(self2, false);
  journal.set(self2, entry);
  return entry;
};
var unsafeGet8 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet7(getOrMakeEntry(self2, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value, journal) => {
  const entry = getOrMakeEntry(self2, journal);
  unsafeSet(entry, value);
  return;
});

// node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var tDequeueVariance = {
  _Out: (_) => _
};
var tEnqueueVariance = {
  _In: (_) => _
};

class TQueueImpl {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed14(queue.length);
  });
  isFull = /* @__PURE__ */ map22(this.size, (size14) => size14 === this.requestedCapacity);
  isEmpty = /* @__PURE__ */ map22(this.size, (size14) => size14 === 0);
  shutdown = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    unsafeSet2(this.ref, undefined, runtime5.journal);
    return void_6;
  });
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const queue = unsafeGet8(this.ref, journal);
    return queue === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown4) => isShutdown4 ? void_6 : retry4);
  offer(value) {
    return withSTMRuntime((runtime5) => {
      const queue = pipe(this.ref, unsafeGet8(runtime5.journal));
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value);
        unsafeSet2(this.ref, queue, runtime5.journal);
        return succeed14(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed14(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed14(true);
          }
          queue.shift();
          queue.push(value);
          unsafeSet2(this.ref, queue, runtime5.journal);
          return succeed14(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime5) => {
      const as7 = Array.from(iterable);
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length + as7.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as7], runtime5.journal);
        return succeed14(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as7.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime5.journal);
          return succeed14(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as7.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime5.journal);
          return succeed14(true);
        }
      }
    });
  }
  peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry4;
    }
    return succeed14(queue[0]);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed14(fromNullable(queue[0]));
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry4;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime5.journal);
    return succeed14(dequeued);
  });
  takeAll = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    unsafeSet2(this.ref, [], runtime5.journal);
    return succeed14(queue);
  });
  takeUpTo(max7) {
    return withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max7);
      unsafeSet2(this.ref, Array.from(remaining), runtime5.journal);
      return succeed14(Array.from(toTake));
    });
  }
}
var isShutdown4 = (self2) => self2.isShutdown;
var shutdown5 = (self2) => self2.shutdown;
var take5 = (self2) => self2.take;

// node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head6, subscribers, tail2) => ({
  head: head6,
  subscribers,
  tail: tail2
});

class TPubSubImpl {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: (_) => _
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    return currentPublisherTail === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown5) => isShutdown5 ? void_6 : retry4);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
    if (currentPublisherTail === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed14(unsafeGet8(this.pubsubSize, runtime5.journal));
  });
  isEmpty = /* @__PURE__ */ map22(this.size, (size14) => size14 === 0);
  isFull = /* @__PURE__ */ map22(this.size, (size14) => size14 === this.capacity());
  offer(value) {
    return withSTMRuntime((runtime5) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
      if (currentPublisherTail === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, runtime5.journal);
      if (currentSubscriberCount === 0) {
        return succeed14(true);
      }
      const currentPubSubSize = unsafeGet8(this.pubsubSize, runtime5.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(undefined);
        const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime5.journal);
        return succeed14(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry4;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed14(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet8(this.publisherHead, runtime5.journal);
            let loop3 = true;
            while (loop3) {
              const node = unsafeGet8(currentPublisherHead, runtime5.journal);
              if (node === undefined) {
                return retry4;
              }
              const head6 = node.head;
              const tail2 = node.tail;
              if (head6 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime5.journal);
                unsafeSet2(this.publisherHead, tail2, runtime5.journal);
                loop3 = false;
              } else {
                currentPublisherHead = tail2;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(undefined);
          const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
          return succeed14(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map22(forEach11(iterable, (a) => this.offer(a)), every(identity));
  }
  shutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    if (currentPublisherTail !== undefined) {
      unsafeSet2(this.publisherTail, undefined, journal);
      const currentSubscribers = unsafeGet8(this.subscribers, journal);
      forEach4(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, undefined, journal);
      });
      unsafeSet2(this.subscribers, empty9(), journal);
    }
  });
}

class TPubSubSubscriptionImpl {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    return currentSubscriberHead === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown5) => isShutdown5 ? void_6 : retry4);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let loop3 = true;
    let size14 = 0;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        loop3 = false;
      } else {
        const head6 = node.head;
        const tail2 = node.tail;
        if (head6 !== AbsentValue2) {
          size14 = size14 + 1;
          if (size14 >= Number.MAX_SAFE_INTEGER) {
            loop3 = false;
          }
        }
        currentSubscriberHead = tail2;
      }
    }
    return succeed14(size14);
  });
  isEmpty = /* @__PURE__ */ map22(this.size, (size14) => size14 === 0);
  isFull = /* @__PURE__ */ map22(this.size, (size14) => size14 === this.capacity());
  peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        return retry4;
      }
      const head6 = node.head;
      const tail2 = node.tail;
      if (head6 !== AbsentValue2) {
        value = head6;
        loop3 = false;
      } else {
        currentSubscriberHead = tail2;
      }
    }
    return succeed14(value);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = none2();
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        value = none2();
        loop3 = false;
      } else {
        const head6 = node.head;
        const tail2 = node.tail;
        if (head6 !== AbsentValue2) {
          value = some2(head6);
          loop3 = false;
        } else {
          currentSubscriberHead = tail2;
        }
      }
    }
    return succeed14(value);
  });
  shutdown = /* @__PURE__ */ effect3((journal) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    if (currentSubscriberHead !== undefined) {
      unsafeSet2(this.subscriberHead, undefined, journal);
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, journal);
        if (node === undefined) {
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail2 = node.tail;
          if (head6 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size14 = unsafeGet8(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail2, journal);
              unsafeSet2(this.pubsubSize, size14 - 1, journal);
            } else {
              const updatedNode = makeNode2(head6, subscribers - 1, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail2;
        }
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove4(unsafeGet8(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        return retry4;
      }
      const head6 = node.head;
      const tail2 = node.tail;
      if (head6 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size14 = unsafeGet8(this.pubsubSize, runtime5.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail2);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherHead, tail2, runtime5.journal);
          unsafeSet2(this.pubsubSize, size14 - 1, runtime5.journal);
        } else {
          const updatedNode = makeNode2(head6, subscribers - 1, tail2);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
        }
        unsafeSet2(this.subscriberHead, tail2, runtime5.journal);
        value = head6;
        loop3 = false;
      } else {
        currentSubscriberHead = tail2;
      }
    }
    return succeed14(value);
  });
  takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max7) {
    return withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max7) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === undefined) {
          n = max7;
        } else {
          const head6 = node.head;
          const tail2 = node.tail;
          if (head6 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size14 = unsafeGet8(this.pubsubSize, runtime5.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
              unsafeSet2(this.publisherHead, tail2, runtime5.journal);
              unsafeSet2(this.pubsubSize, size14 - 1, runtime5.journal);
            } else {
              const updatedNode = makeNode2(head6, subscribers - 1, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            }
            builder.push(head6);
            n = n + 1;
          }
          currentSubscriberHead = tail2;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime5.journal);
      return succeed14(builder);
    });
  }
}
var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get16(publisherTail), flatMap15((currentPublisherTail) => pipe(all6([make50(currentPublisherTail), get16(subscriberCount), get16(subscribers)]), tap4(([_, currentSubscriberCount]) => pipe(subscriberCount, set8(currentSubscriberCount + 1))), tap4(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set8(pipe(currentSubscribers, add4(subscriberHead))))), map22(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
var subscribe3 = (self2) => makeSubscription2(self2.pubsubSize, self2.publisherHead, self2.publisherTail, self2.requestedCapacity, self2.subscriberCount, self2.subscribers);
var subscribeScoped = (self2) => acquireRelease2(subscribe3(self2), (dequeue) => shutdown5(dequeue));

// node_modules/effect/dist/esm/TPubSub.js
var subscribeScoped2 = subscribeScoped;

// node_modules/effect/dist/esm/TQueue.js
var isShutdown6 = isShutdown4;
var take6 = take5;

// node_modules/effect/dist/esm/internal/ringBuffer.js
class RingBuffer {
  capacity;
  array;
  size = 0;
  current = 0;
  constructor(capacity7) {
    this.capacity = capacity7;
    this.array = Array.from({
      length: capacity7
    }, constUndefined);
  }
  head() {
    return fromNullable(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index] ?? undefined;
  }
  put(value) {
    this.array[this.current] = value;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = undefined;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable2(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
}

// node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
});
var current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});

// node_modules/effect/dist/esm/internal/stream/emit.js
var make51 = (emit) => {
  const ops = {
    chunk(as7) {
      return this(succeed8(as7));
    },
    die(defect) {
      return this(die5(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit3) {
      return this(suspend3(() => mapBoth3(exit3, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail8(none2()));
    },
    fail(e) {
      return this(fail8(some2(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth4(effect4, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError2(some2)));
    },
    halt(cause3) {
      return this(failCause7(pipe(cause3, map14(some2))));
    },
    single(value) {
      return this(succeed8(of2(value)));
    }
  };
  return Object.assign(emit, ops);
};
var makePush = (queue, scheduler) => {
  let finished = false;
  let buffer = [];
  let running4 = false;
  function array4(items) {
    if (finished)
      return false;
    if (items.length <= 50000) {
      buffer.push.apply(buffer, items);
    } else {
      for (let i = 0;i < items.length; i++) {
        buffer.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler.scheduleTask(flush, 0);
    }
    return true;
  }
  function flush() {
    running4 = false;
    if (buffer.length > 0) {
      queue.unsafeOffer(buffer);
      buffer = [];
    }
  }
  function done10(exit3) {
    if (finished)
      return;
    finished = true;
    if (exit3._tag === "Success") {
      buffer.push(exit3.value);
    }
    flush();
    queue.unsafeOffer(exit3._tag === "Success" ? void_3 : exit3);
  }
  return {
    single(value) {
      if (finished)
        return false;
      buffer.push(value);
      if (!running4) {
        running4 = true;
        scheduler.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array4,
    chunk(chunk2) {
      return array4(toReadonlyArray(chunk2));
    },
    done: done10,
    end() {
      if (finished)
        return;
      finished = true;
      flush();
      queue.unsafeOffer(void_3);
    },
    halt(cause3) {
      return done10(failCause4(cause3));
    },
    fail(error3) {
      return done10(fail4(error3));
    },
    die(defect) {
      return done10(die3(defect));
    },
    dieMessage(message) {
      return done10(die3(new Error(message)));
    }
  };
};

// node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
var handoffStateFull = (value, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value,
  notifyProducer
});
var handoffStateMatch = (onEmpty, onFull) => {
  return (self2) => {
    switch (self2._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self2.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self2.value, self2.notifyProducer);
      }
    }
  };
};
var handoffVariance = {
  _A: (_) => _
};
var make52 = () => pipe(make24(), flatMap10((deferred) => make26(handoffStateEmpty(deferred))), map17((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
var offer5 = /* @__PURE__ */ dual(2, (self2, value) => {
  return flatMap10(make24(), (deferred) => flatten7(modify4(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight3(succeed2(notifyConsumer, undefined), _await(deferred)), handoffStateFull(value, deferred)], (_, notifyProducer) => [flatMap10(_await(notifyProducer), () => pipe(self2, offer5(value))), state])))));
});
var take7 = (self2) => flatMap10(make24(), (deferred) => flatten7(modify4(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap10(_await(notifyConsumer), () => take7(self2)), state], (value, notifyProducer) => [as3(succeed2(notifyProducer, undefined), value), handoffStateEmpty(deferred)])))));

// node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
});
var halt = (cause3) => ({
  _tag: OP_HALT,
  cause: cause3
});
var end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  _A: (_) => _,
  _E: (_) => _
};

class TakeImpl {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit3) {
    this.exit = exit3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var chunk2 = (chunk3) => new TakeImpl(succeed4(chunk3));
var done10 = (self2) => suspend3(() => self2.exit);
var end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
var failCause10 = (cause3) => new TakeImpl(failCause4(pipe(cause3, map14(some2))));
var fromPull = (pull) => matchCause2(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause10
  }),
  onSuccess: chunk2
});
var match17 = /* @__PURE__ */ dual(2, (self2, {
  onEnd,
  onFailure,
  onSuccess
}) => match9(self2.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd,
    onSome: onFailure
  }),
  onSuccess
}));
var of5 = (value) => new TakeImpl(succeed4(of2(value)));

// node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail8(none2());
var failCause11 = (cause3) => mapError2(failCause7(cause3), some2);

// node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
var PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});

// node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
});
var PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});

// node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};

class StreamImpl {
  channel;
  [StreamTypeId2] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
var DefaultChunkSize = 4096;
var accumulate = (self2) => chunks(accumulateChunks(self2));
var accumulateChunks = (self2) => {
  const accumulator = (s) => readWith({
    onInput: (input) => {
      const next4 = appendAll2(s, input);
      return flatMap13(write(next4), () => accumulator(next4));
    },
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipeTo(toChannel2(self2), accumulator(empty6())));
};
var acquireRelease3 = (acquire, release) => scoped5(acquireRelease2(acquire, release));
var aggregate = /* @__PURE__ */ dual(2, (self2, sink) => aggregateWithin(self2, sink, forever4));
var aggregateWithin = /* @__PURE__ */ dual(3, (self2, sink, schedule2) => filterMap7(aggregateWithinEither(self2, sink, schedule2), (_) => match(_, {
  onLeft: none2,
  onRight: some2
})));
var aggregateWithinEither = /* @__PURE__ */ dual(3, (self2, sink, schedule2) => {
  const layer = all5([make52(), make26(ScheduleEnd), make26(empty6()), driver2(schedule2), make26(false), make26(false)]);
  return fromEffect7(layer).pipe(flatMap16(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input) => flatMap13(fromEffect4(pipe(handoff, offer5(emit(input)), when2(() => isNonEmpty(input)))), () => handoffProducer),
      onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet3(sinkLeftovers, empty6()), flatMap10((leftovers) => {
      if (isNonEmpty(leftovers)) {
        return pipe(set6(consumed, true), zipRight3(succeed8(pipe(write(leftovers), flatMap13(() => handoffConsumer)))));
      }
      return pipe(take7(handoff), map17((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect4(set6(consumed, true)), zipRight4(write(signal.elements)), zipRight4(fromEffect4(get11(endAfterEmit))), flatMap13((bool) => bool ? void_5 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause9(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get11(consumed), map17((bool) => bool ? fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight3(set6(endAfterEmit, true)))) : pipe(fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight3(set6(endAfterEmit, true)))), flatMap13(() => handoffConsumer))), unwrap);
            }
            return pipe(set6(sinkEndReason, signal.reason), zipRight3(set6(endAfterEmit, true)), fromEffect4);
          }
        }
      }));
    }), unwrap);
    const timeout3 = (lastB) => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope4) => {
      const forkSink = pipe(set6(consumed, false), zipRight3(set6(endAfterEmit, false)), zipRight3(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run, forkIn2(scope4))));
      const handleSide = (leftovers, b, c) => pipe(set6(sinkLeftovers, flatten2(leftovers)), zipRight3(map17(get11(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all5([get11(consumed), forkSink, pipe(timeout3(some2(b)), forkIn2(scope4))]), map17(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of2(right2(b)),
                onSome: (c2) => make7(right2(b), left2(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap13(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope4)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope4);
            }), unwrap);
          }
          case OP_UPSTREAM_END: {
            return pipe(get11(consumed), map17((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_5), unwrap);
          }
        }
      })), unwrap);
      return unwrap(raceWith2(join3(sinkFiber), join3(scheduleFiber), {
        onSelfDone: (sinkExit, _) => pipe(interrupt6(scheduleFiber), zipRight3(pipe(suspend3(() => sinkExit), map17(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
        onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend3(() => scheduleExit), {
          onFailure: (cause3) => match(failureOrCause2(cause3), {
            onLeft: () => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map17(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
            onRight: (cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map17(([leftovers, b]) => handleSide(leftovers, b, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map17(([leftovers, b]) => handleSide(leftovers, b, some2(c))))))
        })
      }));
    };
    return unwrapScopedWith3((scope4) => pipeTo(toChannel2(self2), handoffProducer).pipe(run, forkIn2(scope4), zipRight3(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run, forkIn2(scope4), flatMap10((sinkFiber) => timeout3(none2()).pipe(forkIn2(scope4), map17((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope4)))))))));
  }));
});
var as7 = /* @__PURE__ */ dual(2, (self2, value) => map23(self2, () => value));
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded5();
  } else if (typeof bufferSize === "number" || bufferSize === undefined) {
    return bounded5(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping4(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding4(bufferSize.bufferSize ?? 16);
    default:
      return bounded5(bufferSize.bufferSize ?? 16);
  }
};
var _async = (register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap10((output) => runtime4().pipe(flatMap10((runtime5) => sync3(() => {
  const runPromiseExit3 = runPromiseExit2(runtime5);
  const canceler = register(make51((resume2) => fromPull(resume2).pipe(flatMap10((take8) => offer3(output, take8)), asVoid4, runPromiseExit3).then((exit3) => {
    if (isFailure2(exit3)) {
      if (!isInterrupted3(exit3.cause)) {
        throw squash(exit3.cause);
      }
    }
  })));
  return canceler;
})), map17((value) => {
  const loop3 = take4(output).pipe(flatMap10((take8) => done10(take8)), match12({
    onFailure: (maybeError) => fromEffect4(shutdown4(output)).pipe(zipRight4(match2(maybeError, {
      onNone: () => void_5,
      onSome: (error3) => fail11(error3)
    }))),
    onSuccess: (chunk3) => write(chunk3).pipe(flatMap13(() => loop3))
  }), unwrap);
  return fromChannel2(loop3).pipe(ensuring6(value ?? _void));
}))), unwrapScoped4);
var asyncEffect3 = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap10((output) => pipe(runtime4(), flatMap10((runtime5) => pipe(register(make51((k) => pipe(fromPull(k), flatMap10((take8) => offer3(output, take8)), asVoid4, runPromiseExit2(runtime5)).then((exit3) => {
  if (isFailure2(exit3)) {
    if (!isInterrupted3(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), map17(() => {
  const loop3 = pipe(take4(output), flatMap10(done10), match12({
    onFailure: (maybeError) => pipe(fromEffect4(shutdown4(output)), zipRight4(match2(maybeError, {
      onNone: () => void_5,
      onSome: fail11
    }))),
    onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => loop3))
  }), unwrap);
  return loop3;
}))))), unwrapScoped2, fromChannel2);
var queueFromBufferOptionsPush = (options) => {
  if (options?.bufferSize === "unbounded" || options?.bufferSize === undefined && options?.strategy === undefined) {
    return unbounded5();
  }
  switch (options?.strategy) {
    case "sliding":
      return sliding4(options.bufferSize ?? 16);
    default:
      return dropping4(options?.bufferSize ?? 16);
  }
};
var asyncPush = (register, options) => acquireRelease2(queueFromBufferOptionsPush(options), shutdown4).pipe(tap2((queue) => getWith(currentScheduler2, (scheduler) => register(makePush(queue, scheduler)))), map17((queue) => {
  const loop3 = flatMap13(take4(queue), (item) => isExit(item) ? isSuccess2(item) ? void_5 : failCause9(item.cause) : zipRight4(write(unsafeFromArray(item)), loop3));
  return loop3;
}), unwrapScoped2, fromChannel2);
var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap10((output) => pipe(runtime4(), flatMap10((runtime5) => pipe(register(make51((k) => pipe(fromPull(k), flatMap10((take8) => offer3(output, take8)), asVoid4, runPromiseExit2(runtime5)).then((exit3) => {
  if (isFailure2(exit3)) {
    if (!isInterrupted3(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), zipRight3(make26(false)), flatMap10((ref) => pipe(get11(ref), map17((isDone7) => isDone7 ? end5() : pipe(take4(output), flatMap10(done10), onError2(() => pipe(set6(ref, true), zipRight3(shutdown4(output)))))))))))), scoped5, flatMap16(repeatEffectChunkOption));
var branchAfter = /* @__PURE__ */ dual(3, (self2, n, f) => suspend8(() => {
  const buffering = (acc) => readWith({
    onInput: (input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll2(b1)), b2);
      }
      return buffering(pipe(acc, appendAll2(input)));
    },
    onFailure: fail11,
    onDone: () => running4(acc, empty6())
  });
  const running4 = (prefix, leftover) => pipeTo(zipRight4(write(leftover), identityChannel()), toChannel2(f(prefix)));
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(buffering(empty6()))));
}));
var broadcast = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => pipe(self2, broadcastedQueues(n, maximumLag), map17((tuple3) => tuple3.map((queue) => flattenTake(fromQueue2(queue, {
  shutdown: true
}))))));
var broadcastDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map17(toPubSub2(self2, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
var share = /* @__PURE__ */ dual(2, (self2, options) => map17(make46({
  acquire: broadcastDynamic(self2, options),
  idleTimeToLive: options.idleTimeToLive
}), (rcRef) => unwrapScoped4(get15(rcRef))));
var broadcastedQueues = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => flatMap10(pubsubFromOptions(maximumLag), (pubsub) => pipe(all5(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap2(() => forkScoped2(runIntoPubSubScoped(self2, pubsub))))));
var broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map17(toPubSub2(self2, maximumLag), subscribe2));
var buffer = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self2);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self2, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self2, options.capacity);
  }
  const queue = toQueueOfElements(self2, options);
  return new StreamImpl(unwrapScoped2(map17(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take4(queue2)), flatMap13(match9({
      onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: () => void_5,
        onSome: failCause9
      })),
      onSuccess: (value) => flatMap13(write(of2(value)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self2, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self2, options.capacity);
  }
  const queue = toQueue2(self2, options);
  return new StreamImpl(unwrapScoped2(map17(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take4(queue2)), flatMap13(match17({
      onEnd: () => void_5,
      onFailure: failCause9,
      onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self2))));
});
var bufferSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self2, rechunk(1)))));
});
var bufferUnbounded = (self2) => {
  const queue = toQueue2(self2, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped2(map17(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take4(queue2)), flatMap13(match17({
      onEnd: () => void_5,
      onFailure: failCause9,
      onSuccess: (value) => flatMap13(write(value), () => process2)
    })));
    return process2;
  })));
};
var bufferSignal = (scoped5, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take8) => pipe(get11(ref), tap2(_await), zipRight3(make24()), flatMap10((deferred) => pipe(offer3(queue, [take8, deferred]), zipRight3(set6(ref, deferred)), zipRight3(_await(deferred)))), asVoid4, fromEffect4);
    return readWithCause({
      onInput: (input) => pipe(make24(), flatMap10((deferred) => pipe(offer3(queue, [chunk2(input), deferred]), flatMap10((added) => pipe(set6(ref, deferred), when2(() => added))))), asVoid4, fromEffect4, flatMap13(() => producer(queue, ref))),
      onFailure: (error3) => terminate(failCause10(error3)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect4(take4(queue)), flatMap13(([take8, deferred]) => zipRight4(fromEffect4(succeed2(deferred, undefined)), match17(take8, {
      onEnd: () => void_5,
      onFailure: failCause9,
      onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped2(pipe(scoped5, flatMap10((queue) => pipe(make24(), tap2((start3) => succeed2(start3, undefined)), flatMap10((start3) => pipe(make26(start3), flatMap10((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as3(consumer(queue))))))));
};
var catchAll6 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause12
})));
var catchAllCause5 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), catchAllCause4((cause3) => toChannel2(f(cause3))))));
var catchSome3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAll6((error3) => pipe(pf(error3), getOrElse(() => fail15(error3))))));
var catchSomeCause3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAllCause5((cause3) => pipe(pf(cause3), getOrElse(() => failCause12(cause3))))));
var catchTag3 = /* @__PURE__ */ dual(3, (self2, k, f) => catchAll6(self2, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail15(e);
}));
var catchTags3 = /* @__PURE__ */ dual(2, (self2, cases) => catchAll6(self2, (e) => {
  const keys6 = Object.keys(cases);
  if ("_tag" in e && keys6.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail15(e);
}));
var changes = (self2) => pipe(self2, changesWith((x, y) => equals(y)(x)));
var changesWith = /* @__PURE__ */ dual(2, (self2, f) => {
  const writer = (last5) => readWithCause({
    onInput: (input) => {
      const [newLast, newChunk] = reduce2(input, [last5, empty6()], ([option3, outputs], output) => {
        if (isSome2(option3) && f(option3.value, output)) {
          return [some2(output), outputs];
        }
        return [some2(output), pipe(outputs, append2(output))];
      });
      return flatMap13(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause9,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var changesWithEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const writer = (last5) => readWithCause({
    onInput: (input) => pipe(input, reduce13([last5, empty6()], ([option3, outputs], output) => {
      if (isSome2(option3)) {
        return pipe(f(option3.value, output), map17((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append2(output))]));
      }
      return succeed8([some2(output), pipe(outputs, append2(output))]);
    }), fromEffect4, flatMap13(([newLast, newChunk]) => pipe(write(newChunk), flatMap13(() => writer(newLast))))),
    onFailure: failCause9,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var chunks = (self2) => pipe(self2, mapChunks(of2));
var chunksWith = /* @__PURE__ */ dual(2, (self2, f) => flattenChunks(f(chunks(self2))));
var unsome = (effect4) => catchAll2(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail8(o.value));
var combine12 = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
  function producer(handoff, latch) {
    return fromEffect4(take7(latch)).pipe(zipRight4(readWithCause({
      onInput: (input) => flatMap13(fromEffect4(offer5(handoff, succeed4(input))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect4(offer5(handoff, failCause4(pipe(cause3, map14(some2))))),
      onDone: () => flatMap13(fromEffect4(offer5(handoff, fail4(none2()))), () => producer(handoff, latch))
    })));
  }
  return new StreamImpl(unwrapScopedWith((scope4) => all5([make52(), make52(), make52(), make52()]).pipe(tap2(([left3, _, latchL]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope4), forkIn2(scope4))), tap2(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope4), forkIn2(scope4))), map17(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, undefined).pipe(zipRight3(take7(left3).pipe(flatMap10(identity))));
    const pullRight = offer5(latchR, undefined).pipe(zipRight3(take7(right3).pipe(flatMap10(identity))));
    return toChannel2(unfoldEffect(s, (s2) => flatMap10(f(s2, pullLeft, pullRight), unsome)));
  }))));
});
var combineChunks = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
  const producer = (handoff, latch) => zipRight4(fromEffect4(take7(latch)), readWithCause({
    onInput: (input) => flatMap13(fromEffect4(pipe(handoff, offer5(chunk2(input)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect4(offer5(handoff, failCause10(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end4))
  }));
  return new StreamImpl(unwrapScopedWith((scope4) => all5([make52(), make52(), make52(), make52()]).pipe(tap2(([left3, _, latchL]) => pipeTo(toChannel2(self2), producer(left3, latchL)).pipe(runIn(scope4), forkIn2(scope4))), tap2(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope4), forkIn2(scope4))), map17(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, undefined).pipe(zipRight3(take7(left3).pipe(flatMap10(done10))));
    const pullRight = offer5(latchR, undefined).pipe(zipRight3(take7(right3).pipe(flatMap10(done10))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap10(f(s2, pullLeft, pullRight), unsome)));
  }))));
});
var concat2 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), zipRight4(toChannel2(that)))));
var concatAll2 = (streams) => suspend8(() => pipe(streams, reduce2(empty36, (x, y) => concat2(y)(x))));
var cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
var crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
var crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap16(left3, () => right3));
var crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap16((a) => pipe(right3, map23((b) => f(a, b))))));
var debounce = /* @__PURE__ */ dual(2, (self2, duration2) => unwrapScopedWith3((scope4) => gen2(function* () {
  const handoff = yield* make52();
  function enqueue(last5) {
    return sleep2(duration2).pipe(as3(last5), forkIn2(scope4), map17((fiber) => consumer(previous(fiber))));
  }
  const producer = readWithCause({
    onInput: (input) => match2(last2(input), {
      onNone: () => producer,
      onSome: (elem) => fromEffect4(offer5(handoff, emit(of2(elem)))).pipe(flatMap13(() => producer))
    }),
    onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return unwrap(take7(handoff).pipe(map17((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause9(signal.cause);
            }
            case OP_END: {
              return void_5;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap(take7(handoff).pipe(forkIn2(scope4), flatMap10((handoffFiber) => raceWith2(join3(state.fiber), join3(handoffFiber), {
          onSelfDone: (leftExit, current2) => match9(leftExit, {
            onFailure: (cause3) => interrupt6(current2).pipe(as3(failCause9(cause3))),
            onSuccess: (chunk3) => interrupt6(current2).pipe(zipRight3(succeed8(write(chunk3).pipe(flatMap13(() => consumer(current(handoffFiber)))))))
          }),
          onOtherDone: (rightExit, previous2) => match9(rightExit, {
            onFailure: (cause3) => interrupt6(previous2).pipe(as3(failCause9(cause3))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt6(previous2).pipe(zipRight3(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt6(previous2).pipe(as3(failCause9(signal.cause)));
                }
                case OP_END: {
                  return join3(previous2).pipe(map17((chunk3) => write(chunk3).pipe(zipRight4(void_5))));
                }
              }
            }
          })
        }))));
      }
      case OP_CURRENT: {
        return unwrap(join3(state.fiber).pipe(map17((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause9(signal.cause);
            }
            case OP_END: {
              return void_5;
            }
          }
        })));
      }
    }
  }
  return scopedWith4((scope5) => pipeTo(toChannel2(self2), producer).pipe(runIn(scope5), forkIn2(scope5))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die9 = (defect) => fromEffect7(die5(defect));
var dieSync5 = (evaluate2) => fromEffect7(dieSync2(evaluate2));
var dieMessage4 = (message) => fromEffect7(dieMessage2(message));
var distributedWith = /* @__PURE__ */ dual(2, (self2, options) => pipe(make24(), flatMap10((deferred) => pipe(self2, distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: (a) => flatMap10(_await(deferred), (f) => f(a))
}), flatMap10((next4) => pipe(all5(map6(range2(0, options.size - 1), (id2) => map17(next4, ([key, queue]) => [[key, id2], queue]))), map17(unsafeFromArray), flatMap10((entries2) => {
  const [mappings, queues] = reduceRight2(entries2, [new Map, empty6()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
  return pipe(succeed2(deferred, (a) => map17(options.decide(a), (f) => (key) => pipe(f(mappings.get(key))))), as3(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
};
var distributedWithDynamic = /* @__PURE__ */ dual(2, (self2, options) => distributedWithDynamicCallback(self2, options.maximumLag, options.decide, () => _void));
var distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self2, maximumLag, decide, done11) => pipe(acquireRelease2(make26(new Map), (ref, _) => pipe(get11(ref), flatMap10((queues) => pipe(queues.values(), forEach9(shutdown4))))), flatMap10((queuesRef) => gen2(function* () {
  const offer6 = (a) => pipe(decide(a), flatMap10((shouldProcess) => pipe(get11(queuesRef), flatMap10((queues) => pipe(queues.entries(), reduce13(empty6(), (acc, [id2, queue]) => {
    if (shouldProcess(id2)) {
      return pipe(offer3(queue, succeed4(a)), matchCauseEffect3({
        onFailure: (cause3) => isInterrupted3(cause3) ? succeed8(pipe(acc, prepend2(id2))) : failCause7(cause3),
        onSuccess: () => succeed8(acc)
      }));
    }
    return succeed8(acc);
  }), flatMap10((ids3) => {
    if (isNonEmpty(ids3)) {
      return pipe(update4(queuesRef, (map23) => {
        for (const id2 of ids3) {
          map23.delete(id2);
        }
        return map23;
      }));
    }
    return _void;
  }))))), asVoid4);
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make26(pipe(bounded5(maximumLag), flatMap10((queue) => {
    const id2 = newDistributedWithDynamicId();
    return pipe(update4(queuesRef, (map23) => map23.set(id2, queue)), as3([id2, queue]));
  })));
  const finalize = (endTake) => queuesLock.withPermits(1)(pipe(set6(newQueue, pipe(bounded5(1), tap2((queue) => offer3(queue, endTake)), flatMap10((queue) => {
    const id2 = newDistributedWithDynamicId();
    return pipe(update4(queuesRef, (map23) => map23.set(id2, queue)), as3(make3(id2, queue)));
  }))), zipRight3(pipe(get11(queuesRef), flatMap10((map23) => pipe(fromIterable2(map23.values()), forEach9((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted3(cause3) ? some2(_void) : none2()))))))), zipRight3(done11(endTake)), asVoid4));
  yield* pipe(self2, runForEachScoped(offer6), matchCauseEffect3({
    onFailure: (cause3) => finalize(failCause4(pipe(cause3, map14(some2)))),
    onSuccess: () => finalize(fail4(none2()))
  }), forkScoped2);
  return queuesLock.withPermits(1)(flatten7(get11(newQueue)));
}))));
var drain3 = (self2) => new StreamImpl(drain(toChannel2(self2)));
var drainFork = /* @__PURE__ */ dual(2, (self2, that) => fromEffect7(make24()).pipe(flatMap16((backgroundDied) => scopedWith4((scope4) => toChannel2(that).pipe(drain, runIn(scope4), catchAllCause2((cause3) => failCause2(backgroundDied, cause3)), forkIn2(scope4))).pipe(crossRight(interruptWhenDeferred2(self2, backgroundDied))))));
var drop3 = /* @__PURE__ */ dual(2, (self2, n) => {
  const loop3 = (r) => readWith({
    onInput: (input) => {
      const dropped = pipe(input, drop2(r));
      const leftover = Math.max(0, r - input.length);
      const more = isEmpty(input) || leftover > 0;
      if (more) {
        return loop3(leftover);
      }
      return pipe(write(dropped), zipRight4(identityChannel()));
    },
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(n))));
});
var dropRight2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend8(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: (input) => {
        const outputs = pipe(input, filterMap3((elem) => {
          const head6 = queue.head();
          queue.put(elem);
          return head6;
        }));
        return pipe(write(outputs), flatMap13(() => reader));
      },
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(reader)));
  });
});
var dropUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => drop3(dropWhile5(self2, (a) => !predicate(a)), 1));
var dropUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropUntil2(input, predicate), map17(unsafeFromArray), map17((leftover) => {
      const more = isEmpty(leftover);
      if (more) {
        return suspend4(() => loop3);
      }
      return pipe(write(leftover), zipRight4(identityChannel()));
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var dropWhile5 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const output = dropWhile2(input, predicate);
      if (isEmpty(output)) {
        return suspend4(() => loop3);
      }
      return zipRight4(write(output), identityChannel());
    },
    onFailure: fail11,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
});
var dropWhileEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropWhile4(input, predicate), map17(unsafeFromArray), map17((leftover) => {
      const more = isEmpty(leftover);
      if (more) {
        return suspend4(() => loop3);
      }
      return zipRight4(write(leftover), identityChannel());
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
});
var either5 = (self2) => pipe(self2, map23(right2), catchAll6((error3) => make53(left2(error3))));
var empty36 = /* @__PURE__ */ new StreamImpl(void_5);
var ensuring6 = /* @__PURE__ */ dual(2, (self2, finalizer) => new StreamImpl(pipe(toChannel2(self2), ensuring3(finalizer))));
var ensuringWith2 = /* @__PURE__ */ dual(2, (self2, finalizer) => new StreamImpl(ensuringWith(toChannel2(self2), finalizer)));
var context5 = () => fromEffect7(context3());
var contextWith3 = (f) => pipe(context5(), map23(f));
var contextWithEffect3 = (f) => pipe(context5(), mapEffectSequential(f));
var contextWithStream = (f) => pipe(context5(), flatMap16(f));
var execute = (effect4) => drain3(fromEffect7(effect4));
var fail15 = (error3) => fromEffectOption(fail8(some2(error3)));
var failSync6 = (evaluate2) => fromEffectOption(failSync2(() => some2(evaluate2())));
var failCause12 = (cause3) => fromEffect7(failCause7(cause3));
var failCauseSync5 = (evaluate2) => fromEffect7(failCauseSync2(evaluate2));
var filter9 = /* @__PURE__ */ dual(2, (self2, predicate) => mapChunks(self2, filter3(predicate)));
var filterEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed11
      });
    } else {
      return pipe(f(next4.value), map17((bool) => bool ? pipe(write(of2(next4.value)), flatMap13(() => loop3(iterator))) : loop3(iterator)), unwrap);
    }
  };
  return new StreamImpl(suspend4(() => pipe(toChannel2(self2), pipeTo(loop3(empty6()[Symbol.iterator]())))));
});
var filterMap7 = /* @__PURE__ */ dual(2, (self2, pf) => mapChunks(self2, filterMap3(pf)));
var filterMapEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend8(() => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed11
      });
    } else {
      return pipe(pf(next4.value), match2({
        onNone: () => sync3(() => loop3(iterator)),
        onSome: map17((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
      }), unwrap);
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty6()[Symbol.iterator]()))));
}));
var filterMapWhile3 = /* @__PURE__ */ dual(2, (self2, pf) => {
  const loop3 = readWith({
    onInput: (input) => {
      const mapped = filterMapWhile2(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap13(() => loop3));
      }
      return write(mapped);
    },
    onFailure: fail11,
    onDone: succeed11
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var filterMapWhileEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend8(() => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed11
      });
    } else {
      return unwrap(match2(pf(next4.value), {
        onNone: () => succeed8(void_5),
        onSome: map17((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
      }));
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(empty6()[Symbol.iterator]()))));
}));
var finalizer = (finalizer2) => acquireRelease3(_void, () => finalizer2);
var find2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => match2(findFirst3(input, predicate), {
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    }),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var findEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(findFirst7(input, predicate), map17(match2({
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    })), unwrap),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var flatMap16 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options) => {
  const bufferSize = options?.bufferSize ?? 16;
  if (options?.switch) {
    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self2, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self2, n, bufferSize, f));
  }
  return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self2), (as8) => pipe(as8, map6((a) => toChannel2(f(a))), reduce2(void_5, (left3, right3) => pipe(left3, zipRight4(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
});
var matchConcurrency = (concurrency, sequential5, bounded8) => {
  switch (concurrency) {
    case undefined:
      return sequential5();
    case "unbounded":
      return bounded8(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential5();
  }
};
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self2, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten12 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => flatMap16(self2, identity, options));
var flattenChunks = (self2) => {
  const flatten13 = readWithCause({
    onInput: (chunks2) => flatMap13(writeChunk(chunks2), () => flatten13),
    onFailure: failCause9,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(flatten13)));
};
var flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => options?.unordered ? flatMap16(self2, (a) => fromEffect7(a), {
  concurrency: options.concurrency
}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, identity), (n) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
var flattenExitOption = (self2) => {
  const processChunk = (chunk3, cont) => {
    const [toEmit, rest] = pipe(chunk3, splitWhere2((exit3) => !isSuccess2(exit3)));
    const next4 = pipe(head2(rest), match2({
      onNone: () => cont,
      onSome: match9({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_5,
          onSome: failCause9
        }),
        onSuccess: () => void_5
      })
    }));
    return pipe(write(pipe(toEmit, filterMap3((exit3) => isSuccess2(exit3) ? some2(exit3.value) : none2()))), flatMap13(() => next4));
  };
  const process2 = readWithCause({
    onInput: (chunk3) => processChunk(chunk3, process2),
    onFailure: (cause3) => failCause9(cause3),
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
};
var flattenIterables = (self2) => pipe(self2, map23(fromIterable2), flattenChunks);
var flattenTake = (self2) => flattenChunks(flattenExitOption(pipe(self2, map23((take8) => take8.exit))));
var forever5 = (self2) => new StreamImpl(repeated(toChannel2(self2)));
var fromAsyncIterable = (iterable, onError3) => pipe(acquireRelease2(sync3(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map17((iterator) => repeatEffectOption(pipe(tryPromise2({
  try: async () => iterator.next(),
  catch: (reason) => some2(onError3(reason))
}), flatMap10((result) => result.done ? fail8(none2()) : succeed8(result.value))))), unwrapScoped4);
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream) => {
  if ("channel" in stream) {
    return stream.channel;
  } else if (isEffect2(stream)) {
    return toChannel2(fromEffect7(stream));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromChunk = (chunk3) => new StreamImpl(isEmpty(chunk3) ? void_5 : write(chunk3));
var fromChunkPubSub = (pubsub, options) => {
  if (options?.scoped) {
    const effect4 = map17(subscribe2(pubsub), fromChunkQueue);
    return options.shutdown ? map17(effect4, ensuring6(shutdown3(pubsub))) : effect4;
  }
  const stream = flatMap16(scoped5(subscribe2(pubsub)), fromChunkQueue);
  return options?.shutdown ? ensuring6(stream, shutdown3(pubsub)) : stream;
};
var fromChunkQueue = (queue, options) => pipe(take4(queue), catchAllCause2((cause3) => pipe(isShutdown3(queue), flatMap10((isShutdown7) => isShutdown7 && isInterrupted3(cause3) ? end5() : failCause11(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown4(queue)) : identity);
var fromChunks = (...chunks2) => pipe(fromIterable11(chunks2), flatMap16(fromChunk));
var fromEffect7 = (effect4) => pipe(effect4, mapError2(some2), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap(match12(effect4, {
  onFailure: match2({
    onNone: () => void_5,
    onSome: fail11
  }),
  onSuccess: (a) => write(of2(a))
})));
var fromPubSub = (pubsub, options) => {
  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
  if (options?.scoped) {
    const effect4 = map17(subscribe2(pubsub), (queue) => fromQueue2(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map17(effect4, ensuring6(shutdown3(pubsub))) : effect4;
  }
  const stream = flatMap16(scoped5(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
    maxChunkSize
  }));
  return options?.shutdown ? ensuring6(stream, shutdown3(pubsub)) : stream;
};
var fromTPubSub = (pubsub) => {
  return unwrapScoped4(map17(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
};
var fromIterable11 = (iterable) => suspend8(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
var fromIterableEffect = (effect4) => pipe(effect4, map17(fromIterable11), unwrap2);
var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync3(() => {
    let builder = [];
    const loop3 = (iterator2) => pipe(sync3(() => {
      let next4 = iterator2.next();
      if (maxChunkSize === 1) {
        if (next4.done) {
          return void_5;
        }
        return pipe(write(of2(next4.value)), flatMap13(() => loop3(iterator2)));
      }
      builder = [];
      let count5 = 0;
      while (next4.done === false) {
        builder.push(next4.value);
        count5 = count5 + 1;
        if (count5 >= maxChunkSize) {
          break;
        }
        next4 = iterator2.next();
      }
      if (count5 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap13(() => loop3(iterator2)));
      }
      return void_5;
    }), unwrap);
    return new StreamImpl(loop3(iterator));
  }), unwrap2);
};
var fromPull2 = (effect4) => pipe(effect4, map17(repeatEffectChunkOption), unwrapScoped4);
var fromQueue2 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause2((cause3) => pipe(isShutdown3(queue), flatMap10((isShutdown7) => isShutdown7 && isInterrupted3(cause3) ? end5() : failCause11(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown4(queue)) : identity);
var fromTQueue = (queue) => pipe(take6(queue), map17(of2), catchAllCause2((cause3) => pipe(isShutdown6(queue), flatMap10((isShutdown7) => isShutdown7 && isInterrupted3(cause3) ? end5() : failCause11(cause3)))), repeatEffectChunkOption);
var fromSchedule = (schedule2) => pipe(driver2(schedule2), map17((driver3) => repeatEffectOption(driver3.next(undefined))), unwrap2);
var fromReadableStream = (...args2) => {
  const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map17(acquireRelease2(sync3(() => evaluate2().getReader()), (reader) => releaseLockOnEnd ? sync3(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap10(tryPromise2({
    try: () => reader.read(),
    catch: (reason) => some2(onError3(reason))
  }), ({
    done: done11,
    value
  }) => done11 ? fail8(none2()) : succeed8(value)))));
};
var fromReadableStreamByob = (...args2) => {
  const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map17(acquireRelease2(sync3(() => evaluate2().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync3(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll6(forever5(readChunkStreamByobReader(reader, onError3, allocSize)), (error3) => error3 === EOF ? empty36 : fail15(error3))));
};
var EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
var readChunkStreamByobReader = (reader, onError3, size16) => {
  const buffer2 = new ArrayBuffer(size16);
  return paginateEffect(0, (offset) => flatMap10(tryPromise2({
    try: () => reader.read(new Uint8Array(buffer2, offset, buffer2.byteLength - offset)),
    catch: (reason) => onError3(reason)
  }), ({
    done: done11,
    value
  }) => {
    if (done11) {
      return fail8(EOF);
    }
    const newOffset = offset + value.byteLength;
    return succeed8([value, newOffset >= buffer2.byteLength ? none2() : some2(newOffset)]);
  }));
};
var groupAdjacentBy = /* @__PURE__ */ dual(2, (self2, f) => {
  const groupAdjacentByChunk = (state, chunk3) => {
    if (isEmpty(chunk3)) {
      return [state, empty6()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = undefined;
    let previousChunk = empty6();
    switch (state._tag) {
      case "Some": {
        const tuple3 = state.value;
        key = tuple3[0];
        let loop3 = true;
        while (loop3 && until < chunk3.length) {
          const input = unsafeGet4(chunk3, until);
          const updatedKey = f(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple3[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk3).slice(from, until));
            const group4 = appendAll2(previousChunk2, additionalChunk);
            builder.push([key, group4]);
            key = updatedKey;
            from = until;
            loop3 = false;
          }
          until = until + 1;
        }
        if (loop3) {
          previousChunk = tuple3[1];
        }
        break;
      }
      case "None": {
        key = f(unsafeGet4(chunk3, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk3.length) {
      const input = unsafeGet4(chunk3, until);
      const updatedKey = f(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk3).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk3).slice(from, until)));
    const output = unsafeFromArray(builder);
    return [some2([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = (state) => readWithCause({
    onInput: (input) => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return isEmpty(output) ? groupAdjacent(updatedState) : flatMap13(write(output), () => groupAdjacent(updatedState));
    },
    onFailure: (cause3) => match2(state, {
      onNone: () => failCause9(cause3),
      onSome: (output) => flatMap13(write(of2(output)), () => failCause9(cause3))
    }),
    onDone: (done11) => match2(state, {
      onNone: () => succeedNow(done11),
      onSome: (output) => flatMap13(write(of2(output)), () => succeedNow(done11))
    })
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), groupAdjacent(none2())));
});
var grouped = /* @__PURE__ */ dual(2, (self2, chunkSize) => pipe(self2, rechunk(chunkSize), chunks));
var groupedWithin = /* @__PURE__ */ dual(3, (self2, chunkSize, duration2) => aggregateWithin(self2, collectAllN(chunkSize), spaced2(duration2)));
var haltWhen = /* @__PURE__ */ dual(2, (self2, effect4) => {
  const writer = (fiber) => pipe(poll3(fiber), map17(match2({
    onNone: () => readWith({
      onInput: (input) => flatMap13(write(input), () => writer(fiber)),
      onFailure: fail11,
      onDone: () => void_5
    }),
    onSome: match9({
      onFailure: failCause9,
      onSuccess: () => void_5
    })
  })), unwrap);
  return new StreamImpl(unwrapScopedWith((scope4) => effect4.pipe(forkIn2(scope4), map17((fiber) => toChannel2(self2).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(self2, haltWhen(sleep2(duration2))));
var haltWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => {
  const writer = pipe(poll(deferred), map17(match2({
    onNone: () => readWith({
      onInput: (input) => pipe(write(input), flatMap13(() => writer)),
      onFailure: fail11,
      onDone: () => void_5
    }),
    onSome: (effect4) => unwrap(match12(effect4, {
      onFailure: fail11,
      onSuccess: () => void_5
    }))
  })), unwrap);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var identityStream = () => new StreamImpl(identityChannel());
var interleave = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, interleaveWith(that, forever5(make53(true, false)))));
var interleaveWith = /* @__PURE__ */ dual(3, (self2, that, decider) => {
  const producer = (handoff) => readWithCause({
    onInput: (value) => flatMap13(fromEffect4(offer5(handoff, of5(value))), () => producer(handoff)),
    onFailure: (cause3) => fromEffect4(offer5(handoff, failCause10(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end4))
  });
  return new StreamImpl(unwrapScopedWith((scope4) => pipe(make52(), zip5(make52()), tap2(([left3]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope4), forkIn2(scope4))), tap2(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope4), forkIn2(scope4))), map17(([left3, right3]) => {
    const process2 = (leftDone, rightDone) => readWithCause({
      onInput: (bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect4(take7(left3)), flatMap13(match17({
            onEnd: () => rightDone ? void_5 : process2(true, rightDone),
            onFailure: failCause9,
            onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect4(take7(right3)), flatMap13(match17({
            onEnd: () => leftDone ? void_5 : process2(leftDone, true),
            onFailure: failCause9,
            onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause9,
      onDone: () => void_5
    });
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse2 = /* @__PURE__ */ dual(2, (self2, element) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(suspend4(() => {
  const writer = (isFirst) => readWithCause({
    onInput: (chunk3) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk3) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap13(() => writer(flagResult)));
    },
    onFailure: failCause9,
    onDone: () => void_5
  });
  return writer(true);
})))));
var intersperseAffixes = /* @__PURE__ */ dual(2, (self2, {
  end: end6,
  middle,
  start: start3
}) => pipe(make53(start3), concat2(pipe(self2, intersperse2(middle))), concat2(make53(end6))));
var interruptAfter = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(self2, interruptWhen2(sleep2(duration2))));
var interruptWhen2 = /* @__PURE__ */ dual(2, (self2, effect4) => new StreamImpl(pipe(toChannel2(self2), interruptWhen(effect4))));
var interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self2, deferred) => new StreamImpl(pipe(toChannel2(self2), interruptWhenDeferred(deferred))));
var iterate3 = (value, next4) => unfold3(value, (a) => some2([a, next4(a)]));
var make53 = (...as8) => fromIterable11(as8);
var map23 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(map6(f)))));
var mapAccum5 = /* @__PURE__ */ dual(3, (self2, s, f) => {
  const accumulator = (s2) => readWith({
    onInput: (input) => {
      const [nextS, chunk3] = mapAccum2(input, s2, f);
      return flatMap13(write(chunk3), () => accumulator(nextS));
    },
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(accumulator(s))));
});
var mapAccumEffect = /* @__PURE__ */ dual(3, (self2, s, f) => suspend8(() => {
  const accumulator = (s2) => readWith({
    onInput: (input) => pipe(suspend3(() => {
      const outputs = [];
      const emit2 = (output) => sync3(() => {
        outputs.push(output);
      });
      return pipe(input, reduce13(s2, (s3, a) => pipe(f(s3, a), flatMap10(([s4, a2]) => pipe(emit2(a2), as3(s4))))), match12({
        onFailure: (error3) => {
          if (outputs.length !== 0) {
            return zipRight4(write(unsafeFromArray(outputs)), fail11(error3));
          }
          return fail11(error3);
        },
        onSuccess: (s3) => flatMap13(write(unsafeFromArray(outputs)), () => accumulator(s3))
      }));
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(accumulator(s))));
}));
var mapBoth7 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, mapError6(options.onFailure), map23(options.onSuccess)));
var mapChunks = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(f))));
var mapChunksEffect = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOutEffect(f))));
var mapConcat = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapConcatChunk((a) => fromIterable2(f(a)))));
var mapConcatChunk = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapChunks(flatMap3(f))));
var mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential(f), mapConcatChunk(identity)));
var mapConcatEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential((a) => pipe(f(a), map17(fromIterable2))), mapConcatChunk(identity)));
var mapEffectSequential = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed11
      });
    } else {
      const value = next4.value;
      return unwrap(map17(f(value), (a2) => flatMap13(write(of2(a2)), () => loop3(iterator))));
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(suspend4(() => loop3(empty6()[Symbol.iterator]())))));
});
var mapEffectPar = /* @__PURE__ */ dual(3, (self2, n, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
var mapError6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapError5(f))));
var mapErrorCause4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapErrorCause3(f))));
var merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self2, that, options) => mergeWith3(self2, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options?.haltStrategy
}));
var mergeAll7 = /* @__PURE__ */ dual((args2) => (Symbol.iterator in args2[0]), (streams, options) => flatten12(fromIterable11(streams), options));
var mergeWithTag = /* @__PURE__ */ dual(2, (streams, options) => {
  const keys6 = Object.keys(streams);
  const values3 = keys6.map((key) => streams[key].pipe(map23((value) => ({
    _tag: key,
    value
  }))));
  return mergeAll7(values3, options);
});
var mergeEither = /* @__PURE__ */ dual(2, (self2, that) => mergeWith3(self2, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
var mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
var mergeWith3 = /* @__PURE__ */ dual(3, (self2, other, options) => {
  const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
  const handler = (terminate) => (exit3) => terminate || !isSuccess2(exit3) ? Done4(suspend3(() => exit3)) : Await2((exit4) => suspend3(() => exit4));
  return new StreamImpl(mergeWith2(toChannel2(map23(self2, options.onSelf)), {
    other: toChannel2(map23(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = (self2) => run3(self2, mkString);
var never4 = /* @__PURE__ */ fromEffect7(never3);
var onEnd = /* @__PURE__ */ dual(2, (self2, effect4) => concat2(self2, drain3(fromEffect7(effect4))));
var onError3 = /* @__PURE__ */ dual(2, (self2, cleanup) => pipe(self2, catchAllCause5((cause3) => fromEffect7(pipe(cleanup(cause3), zipRight3(failCause7(cause3)))))));
var onDone = /* @__PURE__ */ dual(2, (self2, cleanup) => new StreamImpl(pipe(toChannel2(self2), ensuringWith((exit3) => isSuccess2(exit3) ? cleanup() : _void))));
var onStart = /* @__PURE__ */ dual(2, (self2, effect4) => unwrap2(as3(effect4, self2)));
var orDie4 = (self2) => pipe(self2, orDieWith4(identity));
var orDieWith4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), orDieWith3(f))));
var orElse8 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), orElse7(() => toChannel2(that())))));
var orElseEither3 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, map23(left2), orElse8(() => pipe(that(), map23(right2)))));
var orElseFail3 = /* @__PURE__ */ dual(2, (self2, error3) => pipe(self2, orElse8(() => failSync6(error3))));
var orElseIfEmpty = /* @__PURE__ */ dual(2, (self2, element) => pipe(self2, orElseIfEmptyChunk(() => of2(element()))));
var orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self2, chunk3) => pipe(self2, orElseIfEmptyStream(() => new StreamImpl(write(chunk3())))));
var orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self2, stream) => {
  const writer = readWith({
    onInput: (input) => {
      if (isEmpty(input)) {
        return suspend4(() => writer);
      }
      return pipe(write(input), zipRight4(identityChannel()));
    },
    onFailure: fail11,
    onDone: () => suspend4(() => toChannel2(stream()))
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var orElseSucceed3 = /* @__PURE__ */ dual(2, (self2, value) => pipe(self2, orElse8(() => sync7(value))));
var paginate = (s, f) => paginateChunk(s, (s2) => {
  const page = f(s2);
  return [of2(page[0]), page[1]];
});
var paginateChunk = (s, f) => {
  const loop3 = (s2) => {
    const page = f(s2);
    return match2(page[1], {
      onNone: () => zipRight4(write(page[0]), void_5),
      onSome: (s3) => flatMap13(write(page[0]), () => loop3(s3))
    });
  };
  return new StreamImpl(suspend4(() => loop3(s)));
};
var paginateChunkEffect = (s, f) => {
  const loop3 = (s2) => unwrap(map17(f(s2), ([chunk3, option3]) => match2(option3, {
    onNone: () => zipRight4(write(chunk3), void_5),
    onSome: (s3) => flatMap13(write(chunk3), () => loop3(s3))
  })));
  return new StreamImpl(suspend4(() => loop3(s)));
};
var paginateEffect = (s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map17(([a, s3]) => [of2(a), s3])));
var peel = /* @__PURE__ */ dual(2, (self2, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make24(), flatMap10((deferred) => pipe(make52(), map17((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error3) => zipRight5(fromEffect6(fail3(deferred, error3)), fail12(error3)),
      onSuccess: ([z, leftovers]) => {
        const loop3 = readWithCause({
          onInput: (elements) => flatMap13(fromEffect4(offer5(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop3),
          onFailure: (cause3) => zipRight4(fromEffect4(offer5(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause9(cause3)),
          onDone: (_) => zipRight4(fromEffect4(offer5(handoff, {
            _tag: OP_END2
          })), void_5)
        });
        return fromChannel(pipe(fromEffect4(succeed2(deferred, z)), zipRight4(fromEffect4(pipe(handoff, offer5({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight4(loop3)));
      }
    });
    const producer = pipe(take7(handoff), map17((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap13(() => producer));
        }
        case OP_HALT2: {
          return failCause9(signal.cause);
        }
        case OP_END2: {
          return void_5;
        }
      }
    }), unwrap);
    return pipe(self2, tapErrorCause4((cause3) => failCause2(deferred, cause3)), run3(consumer), forkScoped2, zipRight3(_await(deferred)), map17((z) => [z, new StreamImpl(producer)]));
  }))), flatten7);
});
var partition5 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => partitionEither(self2, (a) => succeed8(predicate(a) ? right2(a) : left2(a)), options));
var partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => pipe(mapEffectSequential(self2, predicate), distributedWith({
  size: 2,
  maximumLag: options?.bufferSize ?? 16,
  decide: match({
    onLeft: () => succeed8((n) => n === 0),
    onRight: () => succeed8((n) => n === 1)
  })
}), flatMap10(([queue1, queue2]) => succeed8([filterMap7(flattenExitOption(fromQueue2(queue1, {
  shutdown: true
})), (_) => match(_, {
  onLeft: some2,
  onRight: none2
})), filterMap7(flattenExitOption(fromQueue2(queue2, {
  shutdown: true
})), (_) => match(_, {
  onLeft: none2,
  onRight: some2
}))]))));
var pipeThrough = /* @__PURE__ */ dual(2, (self2, sink) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self2, channel) => new StreamImpl(pipeTo(toChannel2(self2), channel)));
var pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self2, chan) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(chan))));
var prepend4 = /* @__PURE__ */ dual(2, (self2, values3) => new StreamImpl(zipRight4(write(values3), toChannel2(self2))));
var provideContext5 = /* @__PURE__ */ dual(2, (self2, context6) => new StreamImpl(pipe(toChannel2(self2), provideContext3(context6))));
var provideSomeContext2 = /* @__PURE__ */ dual(2, (self2, context6) => mapInputContext5(self2, merge3(context6)));
var provideLayer = /* @__PURE__ */ dual(2, (self2, layer) => new StreamImpl(unwrapScopedWith((scope4) => buildWithScope2(layer, scope4).pipe(map17((env) => pipe(toChannel2(self2), provideContext3(env)))))));
var provideService5 = /* @__PURE__ */ dual(3, (self2, tag, resource) => provideServiceEffect3(self2, tag, succeed8(resource)));
var provideServiceEffect3 = /* @__PURE__ */ dual(3, (self2, tag, effect4) => provideServiceStream(self2, tag, fromEffect7(effect4)));
var provideServiceStream = /* @__PURE__ */ dual(3, (self2, tag, stream) => contextWithStream((env) => flatMap16(stream, (service2) => pipe(self2, provideContext5(add2(env, tag, service2))))));
var mapInputContext5 = /* @__PURE__ */ dual(2, (self2, f) => contextWithStream((env) => pipe(self2, provideContext5(f(env)))));
var provideSomeLayer2 = /* @__PURE__ */ dual(2, (self2, layer) => pipe(self2, provideLayer(pipe(context4(), merge8(layer)))));
var range3 = (min5, max7, chunkSize = DefaultChunkSize) => suspend8(() => {
  if (min5 > max7) {
    return empty36;
  }
  const go2 = (min6, max8, chunkSize2) => {
    const remaining = max8 - min6 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range2(min6, min6 + chunkSize2 - 1)), flatMap13(() => go2(min6 + chunkSize2, max8, chunkSize2)));
    }
    return write(range2(min6, min6 + remaining - 1));
  };
  return new StreamImpl(go2(min5, max7, chunkSize));
});
var race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
var raceAll3 = (...streams) => make24().pipe(map17((halt2) => {
  let winner = null;
  return mergeAll7(streams.map((stream, index) => stream.pipe(takeWhile5(() => {
    if (winner === null) {
      winner = index;
      unsafeDone(halt2, void_3);
      return true;
    }
    return winner === index;
  }), interruptWhen2(_await(halt2).pipe(flatMap10(() => winner === index ? never3 : _void))))), {
    concurrency: streams.length
  });
}), unwrap2);
var rechunk = /* @__PURE__ */ dual(2, (self2, n) => suspend8(() => {
  const target = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
}));
var rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk3) => {
    if (chunk3.length === target && rechunker.isEmpty()) {
      return flatMap13(write(chunk3), () => rechunkProcess(rechunker, target));
    }
    if (chunk3.length > 0) {
      const chunks2 = [];
      let result = undefined;
      let index = 0;
      while (index < chunk3.length) {
        while (index < chunk3.length && result === undefined) {
          result = rechunker.write(pipe(chunk3, unsafeGet4(index)));
          index = index + 1;
        }
        if (result !== undefined) {
          chunks2.push(result);
          result = undefined;
        }
      }
      return flatMap13(writeAll(...chunks2), () => rechunkProcess(rechunker, target));
    }
    return suspend4(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause3) => zipRight4(rechunker.emitIfNotEmpty(), failCause9(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
});

class StreamRechunker {
  n;
  builder = [];
  pos = 0;
  constructor(n) {
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_5;
  }
}
var refineOrDie = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, refineOrDieWith(pf, identity)));
var refineOrDieWith = /* @__PURE__ */ dual(3, (self2, pf, f) => new StreamImpl(catchAll4(toChannel2(self2), (error3) => match2(pf(error3), {
  onNone: () => failCause9(die4(f(error3))),
  onSome: fail11
}))));
var repeat2 = /* @__PURE__ */ dual(2, (self2, schedule2) => filterMap7(repeatEither(self2, schedule2), (_) => match(_, {
  onLeft: none2,
  onRight: some2
})));
var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError2(some2)));
var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError2(some2)));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map17(effect5, (chunk3) => some2([chunk3, effect5])), catchAll2(match2({
  onNone: () => succeed8(none2()),
  onSome: fail8
}))));
var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map17(of2)));
var repeatEither = /* @__PURE__ */ dual(2, (self2, schedule2) => repeatWith(self2, schedule2, {
  onElement: (a) => right2(a),
  onSchedule: left2
}));
var repeatElements = /* @__PURE__ */ dual(2, (self2, schedule2) => filterMap7(repeatElementsWith(self2, schedule2, {
  onElement: (a) => some2(a),
  onSchedule: none2
}), identity));
var repeatElementsWith = /* @__PURE__ */ dual(3, (self2, schedule2, options) => {
  const driver3 = pipe(driver2(schedule2), map17((driver4) => {
    const feed = (input) => match2(head2(input), {
      onNone: () => loop3,
      onSome: (a) => zipRight4(write(of2(options.onElement(a))), step4(pipe(input, drop2(1)), a))
    });
    const step4 = (input, a) => {
      const advance = pipe(driver4.next(a), as3(pipe(write(of2(options.onElement(a))), flatMap13(() => step4(input, a)))));
      const reset = pipe(driver4.last, orDie2, flatMap10((b) => pipe(driver4.reset, map17(() => pipe(write(of2(options.onSchedule(b))), zipRight4(feed(input)))))));
      return pipe(advance, orElse4(() => reset), unwrap);
    };
    const loop3 = readWith({
      onInput: feed,
      onFailure: fail11,
      onDone: () => void_5
    });
    return loop3;
  }), unwrap);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(driver3)));
});
var repeatValue = (value) => new StreamImpl(repeated(write(of2(value))));
var repeatWith = /* @__PURE__ */ dual(3, (self2, schedule2, options) => {
  return pipe(driver2(schedule2), map17((driver3) => {
    const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get11(driver3.iterationMeta));
    const scheduleOutput = pipe(driver3.last, orDie2, map17(options.onSchedule));
    const process2 = pipe(self2, provideLastIterationInfo, map23(options.onElement), toChannel2);
    const loop3 = unwrap(match12(driver3.next(undefined), {
      onFailure: () => void_5,
      onSuccess: () => pipe(process2, zipRight4(pipe(scheduleOutput, map17((c) => pipe(write(of2(c)), flatMap13(() => loop3))), unwrap)))
    }));
    return new StreamImpl(pipe(process2, zipRight4(loop3)));
  }), unwrap2);
});
var repeatWithSchedule = (value, schedule2) => repeatEffectWithSchedule(succeed8(value), schedule2);
var repeatEffectWithSchedule = (effect4, schedule2) => flatMap16(fromEffect7(zip5(effect4, driver2(schedule2))), ([a, driver3]) => {
  const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get11(driver3.iterationMeta));
  return concat2(succeed15(a), unfoldEffect(a, (s) => matchEffect2(driver3.next(s), {
    onFailure: succeed8,
    onSuccess: () => map17(provideLastIterationInfo(effect4), (nextA) => some2([nextA, nextA]))
  })));
});
var retry5 = /* @__PURE__ */ dual(2, (self2, policy) => driver2(policy).pipe(map17((driver3) => {
  const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get11(driver3.iterationMeta));
  const loop3 = toChannel2(provideLastIterationInfo(self2)).pipe(mapOutEffect((out) => as3(driver3.reset, out)), catchAll4((error3) => driver3.next(error3).pipe(match12({
    onFailure: () => fail11(error3),
    onSuccess: () => loop3
  }), unwrap)));
  return loop3;
}), unwrap, fromChannel2));
var withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, policy, options) => suspend8(() => {
  const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
  let i = 0;
  let lastError = none2();
  const loop3 = suspend8(() => {
    const step4 = policy.steps[i++];
    if (!step4) {
      return fail15(getOrThrow2(lastError));
    }
    let nextStream = isContext2(step4.provide) ? provideSomeContext2(self2, step4.provide) : provideSomeLayer2(self2, step4.provide);
    let receivedElements = false;
    if (isSome2(lastError)) {
      const error3 = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      nextStream = suspend8(() => {
        if (attempted)
          return wrapped;
        attempted = true;
        return fail15(error3);
      });
      nextStream = scheduleDefectRefail2(retry5(nextStream, scheduleFromStep(step4, false)));
    } else {
      const schedule2 = scheduleFromStep(step4, true);
      nextStream = schedule2 ? scheduleDefectRefail2(retry5(nextStream, schedule2)) : nextStream;
    }
    return catchAll6(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk3) => {
      receivedElements = true;
      return chunk3;
    }) : nextStream, (error3) => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail15(error3);
      }
      lastError = some2(error3);
      return loop3;
    });
  });
  return loop3;
}));
var scheduleDefectRefail2 = (self2) => catchAllCause5(self2, (cause3) => failCause12(scheduleDefectRefailCause(cause3)));
var run3 = /* @__PURE__ */ dual(2, (self2, sink) => toChannel2(self2).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = (self2) => run3(self2, collectAll());
var runCount = (self2) => run3(self2, count3);
var runDrain2 = (self2) => run3(self2, drain2);
var runFold = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhile(self2, s, constTrue, f));
var runFoldEffect = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhileEffect(self2, s, constTrue, f));
var runFoldScoped = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScoped(s, constTrue, f)));
var runFoldScopedEffect = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScopedEffect(s, constTrue, f)));
var runFoldWhile = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run3(self2, fold(s, cont, f)));
var runFoldWhileEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run3(self2, foldEffect(s, cont, f)));
var runFoldWhileScoped = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(fold(s, cont, f))));
var runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(foldEffect(s, cont, f))));
var runForEach = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEach10(f)));
var runForEachChunk = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEachChunk(f)));
var runForEachChunkScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachChunk(f))));
var runForEachScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEach10(f))));
var runForEachWhile = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEachWhile(f)));
var runForEachWhileScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachWhile(f))));
var runHead = (self2) => run3(self2, head5());
var runIntoPubSub = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueue(pubsub)));
var runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueueScoped(pubsub)));
var runIntoQueue = /* @__PURE__ */ dual(2, (self2, queue) => pipe(self2, runIntoQueueScoped(queue), scoped2));
var runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap13(fromEffect4(offerAll3(queue, map6(input, succeed4))), () => writer),
    onFailure: (cause3) => fromEffect4(offer3(queue, failCause4(map14(cause3, some2)))),
    onDone: () => fromEffect4(offer3(queue, fail4(none2())))
  });
  return pipe(pipeTo(toChannel2(self2), writer), drain, runScoped, asVoid4);
});
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap13(write(chunk2(input)), () => writer),
    onFailure: (cause3) => write(failCause10(cause3)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self2), writer), mapOutEffect((take8) => offer3(queue, take8)), drain, runScoped, asVoid4);
});
var runLast = (self2) => run3(self2, last4());
var runScoped2 = /* @__PURE__ */ dual(2, (self2, sink) => pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = (self2) => run3(self2, sum2);
var scan2 = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, scanEffect(s, (s2, a) => succeed8(f(s2, a)))));
var scanReduce = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, scanReduceEffect((a2, a) => succeed8(f(a2, a)))));
var scanReduceEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapAccumEffect(none2(), (option3, a) => {
  switch (option3._tag) {
    case "None": {
      return succeed8([some2(a), a]);
    }
    case "Some": {
      return pipe(f(option3.value, a), map17((b) => [some2(b), b]));
    }
  }
})));
var schedule2 = /* @__PURE__ */ dual(2, (self2, schedule3) => filterMap7(scheduleWith(self2, schedule3, {
  onElement: some2,
  onSchedule: none2
}), identity));
var scheduleWith = /* @__PURE__ */ dual(3, (self2, schedule3, options) => {
  const loop3 = (driver3, iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (chunk3) => loop3(driver3, chunk3[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeedNow
      });
    }
    return unwrap(matchEffect2(driver3.next(next4.value), {
      onFailure: () => pipe(driver3.last, orDie2, map17((b) => pipe(write(make7(options.onElement(next4.value), options.onSchedule(b))), flatMap13(() => loop3(driver3, iterator)))), zipLeft2(driver3.reset)),
      onSuccess: () => succeed8(pipe(write(of2(options.onElement(next4.value))), flatMap13(() => loop3(driver3, iterator))))
    }));
  };
  return new StreamImpl(pipe(fromEffect4(driver2(schedule3)), flatMap13((driver3) => pipe(toChannel2(self2), pipeTo(loop3(driver3, empty6()[Symbol.iterator]()))))));
});
var scanEffect = /* @__PURE__ */ dual(3, (self2, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap13(() => toChannel2(pipe(self2, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map17((s3) => [s3, s3])))))))));
var scoped5 = (effect4) => new StreamImpl(ensuring3(scoped4(pipe(effect4, map17(of2))), _void));
var scopedWith4 = (f) => new StreamImpl(scopedWith3((scope4) => f(scope4).pipe(map17(of2))));
var some6 = (self2) => pipe(self2, mapError6(some2), someOrFail(() => none2()));
var someOrElse = /* @__PURE__ */ dual(2, (self2, fallback) => pipe(self2, map23(getOrElse(fallback))));
var someOrFail = /* @__PURE__ */ dual(2, (self2, error3) => mapEffectSequential(self2, match2({
  onNone: () => failSync2(error3),
  onSome: succeed8
})));
var sliding7 = /* @__PURE__ */ dual(2, (self2, chunkSize) => slidingSize(self2, chunkSize, 1));
var slidingSize = /* @__PURE__ */ dual(3, (self2, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die9(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend4(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty(items) ? empty6() : of2(items);
        return pipe(write(result2), flatMap13(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight2(leftovers));
      const result = isEmpty(lastItems) ? empty6() : of2(lastItems);
      return pipe(write(result), flatMap13(() => channelEnd));
    };
    const reader = (queueSize) => readWithCause({
      onInput: (input) => flatMap13(write(filterMap3(input, (element, index) => {
        queue.put(element);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some2(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause9(cause3)),
      onDone: () => emitOnStreamEnd(queueSize, void_5)
    });
    return pipe(toChannel2(self2), pipeTo(reader(0)));
  }));
});
var split2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const split3 = (leftovers, input) => {
    const [chunk3, remaining] = pipe(leftovers, appendAll2(input), splitWhere2(predicate));
    if (isEmpty(chunk3) || isEmpty(remaining)) {
      return loop3(pipe(chunk3, appendAll2(pipe(remaining, drop2(1)))));
    }
    return pipe(write(of2(chunk3)), flatMap13(() => split3(empty6(), pipe(remaining, drop2(1)))));
  };
  const loop3 = (leftovers) => readWith({
    onInput: (input) => split3(leftovers, input),
    onFailure: fail11,
    onDone: () => {
      if (isEmpty(leftovers)) {
        return void_5;
      }
      if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
        return zipRight4(write(of2(leftovers)), void_5);
      }
      return zipRight4(split3(empty6(), leftovers), void_5);
    }
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty6()))));
});
var splitOnChunk = /* @__PURE__ */ dual(2, (self2, delimiter) => {
  const next4 = (leftover, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer2;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover, getOrElse(() => empty6())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append2(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer2 === undefined) {
              buffer2 = [];
            }
            buffer2.push(pipe(concatenated, take2(concatenated.length - delimiter.length)));
            return [empty6(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
      }));
      const output = buffer2 === undefined ? empty6() : unsafeFromArray(buffer2);
      return flatMap13(write(output), () => next4(isNonEmpty(carry) ? some2(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause3) => match2(leftover, {
      onNone: () => failCause9(cause3),
      onSome: (chunk3) => zipRight4(write(of2(chunk3)), failCause9(cause3))
    }),
    onDone: (done11) => match2(leftover, {
      onNone: () => succeed11(done11),
      onSome: (chunk3) => zipRight4(write(of2(chunk3)), succeed11(done11))
    })
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(next4(none2(), 0))));
});
var splitLines2 = (self2) => pipeThroughChannel(self2, splitLines());
var succeed15 = (value) => fromChunk(of2(value));
var sync7 = (evaluate2) => suspend8(() => fromChunk(of2(evaluate2())));
var suspend8 = (stream) => new StreamImpl(suspend4(() => toChannel2(stream())));
var take8 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (!Number.isInteger(n)) {
    return die9(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop3 = (n2) => readWith({
    onInput: (input) => {
      const taken = pipe(input, take2(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover = Math.max(0, n2 - taken.length);
      const more = leftover > 0;
      if (more) {
        return pipe(write(taken), flatMap13(() => loop3(leftover)));
      }
      return write(taken);
    },
    onFailure: fail11,
    onDone: succeed11
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(0 < n ? loop3(n) : void_5)));
});
var takeRight3 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return empty36;
  }
  return new StreamImpl(pipe(succeed8(new RingBuffer(n)), map17((queue) => {
    const reader = readWith({
      onInput: (input) => {
        for (const element of input) {
          queue.put(element);
        }
        return reader;
      },
      onFailure: fail11,
      onDone: () => pipe(write(queue.toChunk()), zipRight4(void_5))
    });
    return pipe(toChannel2(self2), pipeTo(reader));
  }), unwrap));
});
var takeUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile2((a) => !predicate(a)));
      const last5 = pipe(input, drop2(taken.length), take2(1));
      if (isEmpty(last5)) {
        return pipe(write(taken), flatMap13(() => loop3));
      }
      return write(pipe(taken, appendAll2(last5)));
    },
    onFailure: fail11,
    onDone: succeed11
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var takeUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause9,
        onDone: succeed11
      });
    }
    return pipe(predicate(next4.value), map17((bool) => bool ? write(of2(next4.value)) : pipe(write(of2(next4.value)), flatMap13(() => loop3(iterator)))), unwrap);
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty6()[Symbol.iterator]()))));
});
var takeWhile5 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile2(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap13(() => loop3));
      }
      return write(taken);
    },
    onFailure: fail11,
    onDone: succeed11
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var tap5 = /* @__PURE__ */ dual(2, (self2, f) => mapEffectSequential(self2, (a) => as3(f(a), a)));
var tapBoth3 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, tapError4(options.onFailure), tap5(options.onSuccess)));
var tapError4 = /* @__PURE__ */ dual(2, (self2, f) => catchAll6(self2, (error3) => fromEffect7(zipRight3(f(error3), fail8(error3)))));
var tapErrorCause4 = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = readWithCause({
    onInput: (chunk3) => flatMap13(write(chunk3), () => loop3),
    onFailure: (cause3) => fromEffect4(zipRight3(f(cause3), failCause7(cause3))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var tapSink = /* @__PURE__ */ dual(2, (self2, sink) => pipe(fromEffect7(all5([bounded5(1), make24()])), flatMap16(([queue, deferred]) => {
  const right3 = flattenTake(fromQueue2(queue, {
    maxChunkSize: 1
  }));
  const loop3 = readWithCause({
    onInput: (chunk3) => pipe(fromEffect4(offer3(queue, chunk2(chunk3))), foldCauseChannel({
      onFailure: () => flatMap13(write(chunk3), () => identityChannel()),
      onSuccess: () => flatMap13(write(chunk3), () => loop3)
    })),
    onFailure: (cause3) => pipe(fromEffect4(offer3(queue, failCause10(cause3))), foldCauseChannel({
      onFailure: () => failCause9(cause3),
      onSuccess: () => failCause9(cause3)
    })),
    onDone: () => pipe(fromEffect4(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_5,
      onSuccess: () => void_5
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self2), loop3), ensuring3(zipRight3(forkDaemon2(offer3(queue, end4)), _await(deferred))))), merge9(execute(pipe(run3(right3, sink), ensuring2(zipRight3(shutdown4(queue), succeed2(deferred, undefined)))))));
})));
var throttle = /* @__PURE__ */ dual(2, (self2, options) => throttleEffect(self2, {
  ...options,
  cost: (chunk3) => succeed8(options.cost(chunk3))
}));
var throttleEffect = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
});
var throttleEnforceEffect = (self2, cost, units, duration2, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip5(currentTimeMillis2), map17(([weight, currentTimeMillis3]) => {
      const elapsed2 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration2);
      const sum3 = tokens + cycles * units;
      const max7 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max7 : Math.min(sum3, max7);
      if (weight <= available) {
        return pipe(write(input), flatMap13(() => loop3(available - weight, currentTimeMillis3)));
      }
      return loop3(tokens, timestampMillis);
    }), unwrap),
    onFailure: failCause9,
    onDone: () => void_5
  });
  const throttled = pipe(currentTimeMillis2, map17((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
};
var throttleShapeEffect = (self2, costFn, units, duration2, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip5(currentTimeMillis2), map17(([weight, currentTimeMillis3]) => {
      const elapsed2 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration2);
      const sum3 = tokens + cycles * units;
      const max7 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max7 : Math.min(sum3, max7);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay3 = millis(Math.max(0, waitCycles * toMillis(duration2)));
      if (greaterThan2(delay3, zero)) {
        return pipe(fromEffect4(sleep2(delay3)), zipRight4(write(input)), flatMap13(() => loop3(remaining, currentTimeMillis3)));
      }
      return flatMap13(write(input), () => loop3(remaining, currentTimeMillis3));
    }), unwrap),
    onFailure: failCause9,
    onDone: () => void_5
  });
  const throttled = pipe(currentTimeMillis2, map17((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
};
var tick = (interval) => repeatWithSchedule(undefined, spaced2(interval));
var timeout3 = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(toPull2(self2), map17(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration2
})), fromPull2));
var timeoutFail3 = /* @__PURE__ */ dual(3, (self2, error3, duration2) => pipe(self2, timeoutTo3(duration2, failSync6(error3))));
var timeoutFailCause3 = /* @__PURE__ */ dual(3, (self2, cause3, duration2) => pipe(toPull2(self2), map17(timeoutFailCause2({
  onTimeout: () => map14(cause3(), some2),
  duration: duration2
})), fromPull2));
var timeoutTo3 = /* @__PURE__ */ dual(3, (self2, duration2, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self2, timeoutFailCause3(() => die4(StreamTimeout), duration2), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== undefined && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
});
var pubsubFromOptions = (options) => {
  if (typeof options === "number") {
    return bounded4(options);
  } else if (options.capacity === "unbounded") {
    return unbounded4({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return dropping3(options);
    case "sliding":
      return sliding3(options);
    default:
      return bounded4(options);
  }
};
var toPubSub2 = /* @__PURE__ */ dual(2, (self2, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown3(pubsub)), tap2((pubsub) => pipe(self2, runIntoPubSubScoped(pubsub), forkScoped2))));
var toPull2 = (self2) => map17(toPull(toChannel2(self2)), (pull) => pipe(pull, mapError2(some2), flatMap10(match({
  onLeft: () => fail8(none2()),
  onRight: succeed8
}))));
var toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap2(acquireRelease2(options?.strategy === "unbounded" ? unbounded5() : options?.strategy === "dropping" ? dropping4(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding4(options.capacity ?? 2) : bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self2, queue))));
var toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap2(acquireRelease2(bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self2, queue))));
var toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => toReadableStreamRuntime(self2, defaultRuntime2, options));
var toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => map17(runtime4(), (runtime5) => toReadableStreamRuntime(self2, runtime5, options)));
var toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime5, options) => {
  const runFork4 = runFork3(runtime5);
  let currentResolve = undefined;
  let fiber = undefined;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self2, (chunk3) => latch.whenOpen(sync3(() => {
        latch.unsafeClose();
        for (const item of chunk3) {
          controller.enqueue(item);
        }
        currentResolve();
        currentResolve = undefined;
      }))));
      fiber.addObserver((exit3) => {
        if (exit3._tag === "Failure") {
          controller.error(squash(exit3.cause));
        } else {
          controller.close();
        }
      });
    },
    pull() {
      return new Promise((resolve) => {
        currentResolve = resolve;
        runSync(latch.open);
      });
    },
    cancel() {
      if (!fiber)
        return;
      return runPromise(asVoid4(interrupt6(fiber)));
    }
  }, options?.strategy);
});
var transduce = /* @__PURE__ */ dual(2, (self2, sink) => {
  const newChannel = suspend4(() => {
    const leftovers = {
      ref: empty6()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer2 = suspend4(() => {
      const leftover = leftovers.ref;
      if (isEmpty(leftover)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap13(() => buffer2)),
          onFailure: fail11,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty6();
      return pipe(writeChunk(leftover), flatMap13(() => buffer2));
    });
    const concatAndGet = (chunk3) => {
      const leftover = leftovers.ref;
      const concatenated = appendAll2(leftover, filter3(chunk3, (chunk4) => chunk4.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap13(write(input), () => upstreamMarker),
      onFailure: fail11,
      onDone: (done11) => zipRight4(sync4(() => {
        upstreamDone.ref = true;
      }), succeedNow(done11))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap13(([leftover, z]) => pipe(succeed11([upstreamDone.ref, concatAndGet(leftover)]), flatMap13(([done11, newLeftovers]) => {
      const nextChannel = done11 && isEmpty(newLeftovers) ? void_5 : transducer;
      return pipe(write(of2(z)), flatMap13(() => nextChannel));
    }))));
    return pipe(toChannel2(self2), pipeTo(upstreamMarker), pipeTo(buffer2), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime5) => {
  const runFork4 = runFork3(runtime5);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = undefined;
      let currentReject = undefined;
      let fiber = undefined;
      const latch = unsafeMakeLatch2(false);
      return {
        next() {
          if (!fiber) {
            fiber = runFork4(runForEach(self2, (value) => latch.whenOpen(sync3(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value
              });
              currentResolve = currentReject = undefined;
            }))));
            fiber.addObserver((exit3) => {
              fiber = runFork2(latch.whenOpen(sync3(() => {
                if (exit3._tag === "Failure") {
                  currentReject(squash(exit3.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: undefined
                  });
                }
                currentResolve = currentReject = undefined;
              })));
            });
          }
          return new Promise((resolve, reject) => {
            currentResolve = resolve;
            currentReject = reject;
            latch.unsafeOpen();
          });
        },
        return() {
          if (!fiber)
            return Promise.resolve({
              done: true,
              value: undefined
            });
          return runPromise(as3(interrupt6(fiber), {
            done: true,
            value: undefined
          }));
        }
      };
    }
  };
});
var toAsyncIterable = (self2) => toAsyncIterableRuntime(self2, defaultRuntime2);
var toAsyncIterableEffect = (self2) => map17(runtime4(), (runtime5) => toAsyncIterableRuntime(self2, runtime5));
var unfold3 = (s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3])));
var unfoldChunk = (s, f) => {
  const loop3 = (s2) => match2(f(s2), {
    onNone: () => void_5,
    onSome: ([chunk3, s3]) => flatMap13(write(chunk3), () => loop3(s3))
  });
  return new StreamImpl(suspend4(() => loop3(s)));
};
var unfoldChunkEffect = (s, f) => suspend8(() => {
  const loop3 = (s2) => unwrap(map17(f(s2), match2({
    onNone: () => void_5,
    onSome: ([chunk3, s3]) => flatMap13(write(chunk3), () => loop3(s3))
  })));
  return new StreamImpl(loop3(s));
});
var unfoldEffect = (s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map17(map2(([a, s3]) => [of2(a), s3]))));
var void_7 = /* @__PURE__ */ succeed15(undefined);
var unwrap2 = (effect4) => flatten12(fromEffect7(effect4));
var unwrapScoped4 = (effect4) => flatten12(scoped5(effect4));
var unwrapScopedWith3 = (f) => flatten12(scopedWith4((scope4) => f(scope4)));
var updateService3 = /* @__PURE__ */ dual(3, (self2, tag, f) => pipe(self2, mapInputContext5((context6) => pipe(context6, add2(tag, f(pipe(context6, unsafeGet3(tag))))))));
var when3 = /* @__PURE__ */ dual(2, (self2, test) => pipe(self2, whenEffect3(sync3(test))));
var whenCase = (evaluate2, pf) => whenCaseEffect(pf)(sync3(evaluate2));
var whenCaseEffect = /* @__PURE__ */ dual(2, (self2, pf) => pipe(fromEffect7(self2), flatMap16((a) => pipe(pf(a), getOrElse(() => empty36)))));
var whenEffect3 = /* @__PURE__ */ dual(2, (self2, effect4) => pipe(fromEffect7(effect4), flatMap16((bool) => bool ? self2 : empty36)));
var withSpan5 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return new StreamImpl(withSpan4(toChannel2(self2), name, options));
  }
  return (self2) => new StreamImpl(withSpan4(toChannel2(self2), name, options));
};
var zip7 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith11(that, (a, a2) => [a, a2])));
var zipFlatten = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith11(that, (a, a2) => [...a, a2])));
var zipAll = /* @__PURE__ */ dual(2, (self2, options) => zipAllWith(self2, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
var zipAllLeft = /* @__PURE__ */ dual(3, (self2, other, defaultSelf) => zipAllWith(self2, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a) => a
}));
var zipAllRight = /* @__PURE__ */ dual(3, (self2, other, defaultRight) => zipAllWith(self2, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_, a2) => a2
}));
var zipAllSortedByKey = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
var zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: (a) => a,
  order: options.order
}));
var zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_, a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self2, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match12({
          onFailure: fail4,
          onSuccess: (leftChunk) => succeed4([map6(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match12({
          onFailure: fail4,
          onSuccess: (rightChunk) => succeed4([map6(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error3) => succeed8(fail4(some2(error3))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed4(merge10(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed8(succeed4([pipe(leftOption.value, map6(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed8(succeed4([pipe(rightOption.value, map6(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: match2({
            onNone: () => succeed8(succeed4([pipe(state.rightChunk, map6(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
            onSome: (error3) => succeed8(fail4(some2(error3)))
          }),
          onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed8(succeed4(merge10(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: match2({
            onNone: () => succeed8(succeed4([map6(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
            onSome: (error3) => succeed8(fail4(some2(error3)))
          }),
          onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed8(succeed4(merge10(state.leftChunk, rightChunk)))
        });
      }
    }
  };
  const merge10 = (leftChunk, rightChunk) => {
    const hasNext = (chunk3, index) => index < chunk3.length - 1;
    const builder = [];
    let state = undefined;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop3 = true;
    while (loop3) {
      const compare2 = options.order(k1, k2);
      if (compare2 === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
          loop3 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
          loop3 = false;
        } else {
          state = PullBoth;
          loop3 = false;
        }
      } else if (compare2 < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop3 = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop3 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  };
  return combineChunks(self2, options.other, PullBoth, pull);
});
var zipAllWith = /* @__PURE__ */ dual(2, (self2, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: (error3) => succeed8(fail4(error3)),
          onSuccess: (leftChunk) => succeed8(succeed4([map6(leftChunk, options.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: (error3) => succeed8(fail4(error3)),
          onSuccess: (rightChunk) => succeed8(succeed4([map6(rightChunk, options.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error3) => succeed8(fail4(some2(error3))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed4(zip8(leftOption.value, rightOption.value, options.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed8(succeed4([map6(leftOption.value, options.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed8(succeed4([map6(rightOption.value, options.onOther), DrainRight]));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: match2({
            onNone: () => succeed8(succeed4([map6(state.rightChunk, options.onOther), DrainRight])),
            onSome: (error3) => succeed8(fail4(some2(error3)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed8(succeed4(zip8(leftChunk, state.rightChunk, options.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: match2({
            onNone: () => succeed8(succeed4([map6(state.leftChunk, options.onSelf), DrainLeft])),
            onSome: (error3) => succeed8(fail4(some2(error3)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed8(succeed4(zip8(state.leftChunk, rightChunk, options.onBoth)));
          }
        });
      }
    }
  };
  const zip8 = (leftChunk, rightChunk, f) => {
    const [output, either6] = zipChunks(leftChunk, rightChunk, f);
    switch (either6._tag) {
      case "Left": {
        if (isEmpty(either6.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either6.left)];
      }
      case "Right": {
        if (isEmpty(either6.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either6.right)];
      }
    }
  };
  return combineChunks(self2, options.other, PullBoth, pull);
});
var zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
var zipLatestAll = (...streams) => {
  if (streams.length === 0) {
    return empty36;
  } else if (streams.length === 1) {
    return map23(streams[0], (x) => [x]);
  }
  const [head6, ...tail2] = streams;
  return zipLatestWith(head6, zipLatestAll(...tail2), (first2, second) => [first2, ...second]);
};
var zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
  const pullNonEmpty = (pull) => pipe(pull, flatMap10((chunk3) => isEmpty(chunk3) ? pullNonEmpty(pull) : succeed8(chunk3)));
  return pipe(toPull2(left3), map17(pullNonEmpty), zip5(pipe(toPull2(right3), map17(pullNonEmpty))), flatMap10(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend3(() => leftDone), zipWith7(join3(rightFiber), (l, r) => [l, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend3(() => rightDone), zipWith7(join3(leftFiber), (l, r) => [r, l, false]))
  })), flatMap16(([l, r, leftFirst]) => pipe(fromEffect7(make26([unsafeLast(l), unsafeLast(r)])), flatMap16((latest) => pipe(fromChunk(leftFirst ? pipe(r, map6((a2) => f(unsafeLast(l), a2))) : pipe(l, map6((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: (leftChunk) => pipe(modify4(latest, ([_, rightLatest]) => [pipe(leftChunk, map6((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]])),
    onRight: (rightChunk) => pipe(modify4(latest, ([leftLatest, _]) => [pipe(rightChunk, map6((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]))
  })), flatMap16(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft5 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take2(right4.length)), left2(pipe(left4, take2(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop2(left4.length)))];
})));
var zipRight8 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take2(right4.length)))];
  }
  return [pipe(right4, take2(left4.length)), right2(pipe(right4, drop2(left4.length)))];
})));
var zipWith11 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
var zipWithChunks = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error3) => succeed8(fail4(some2(error3))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed4(zip8(leftOption.value, rightOption.value)));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect2(pullLeft, {
          onFailure: (error3) => succeed8(fail4(error3)),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed8(succeed4(zip8(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect2(pullRight, {
          onFailure: (error3) => succeed8(fail4(error3)),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed8(succeed4(zip8(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  };
  const zip8 = (leftChunk, rightChunk) => {
    const [output, either6] = f(leftChunk, rightChunk);
    switch (either6._tag) {
      case "Left": {
        if (isEmpty(either6.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either6.left)];
      }
      case "Right": {
        if (isEmpty(either6.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either6.right)];
      }
    }
  };
  return pipe(self2, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = (self2) => pipe(self2, mapAccum5(0, (index, a) => [index + 1, [a, index]]));
var zipWithNext = (self2) => {
  const process2 = (last5) => readWithCause({
    onInput: (input) => {
      const [newLast, chunk3] = mapAccum2(input, last5, (prev, curr) => [some2(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output = filterMap3(chunk3, (option3) => isSome2(option3) ? some2([option3.value[0], some2(option3.value[1])]) : none2());
      return flatMap13(write(output), () => process2(newLast));
    },
    onFailure: failCause9,
    onDone: () => match2(last5, {
      onNone: () => void_5,
      onSome: (value) => zipRight4(write(of2([value, none2()])), void_5)
    })
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(process2(none2()))));
};
var zipWithPrevious = (self2) => pipe(self2, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]]));
var zipWithPreviousAndNext = (self2) => pipe(zipWithNext(zipWithPrevious(self2)), map23(([[prev, curr], next4]) => [prev, curr, pipe(next4, map2((tuple3) => tuple3[1]))]));
var zipChunks = (left3, right3, f) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take2(right3.length), zipWith2(right3, f)), left2(pipe(left3, drop2(right3.length)))];
  }
  return [pipe(left3, zipWith2(pipe(right3, take2(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
};
var Do4 = /* @__PURE__ */ succeed15({});
var bind5 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag, f, options) => flatMap16(self2, (k) => map23(f(k), (a) => ({
  ...k,
  [tag]: a
})), options));
var bindTo5 = /* @__PURE__ */ bindTo(map23);
var let_5 = /* @__PURE__ */ let_(map23);
var decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, encoding = "utf-8") => suspend8(() => {
  const decoder = new TextDecoder(encoding);
  return map23(self2, (s) => decoder.decode(s));
}));
var encodeText = (self2) => suspend8(() => {
  const encoder = new TextEncoder;
  return map23(self2, (s) => encoder.encode(s));
});
var fromEventListener = (target, type, options) => asyncPush((emit2) => acquireRelease2(sync3(() => target.addEventListener(type, emit2.single, options)), () => sync3(() => target.removeEventListener(type, emit2.single, options))), {
  bufferSize: typeof options === "object" ? options.bufferSize : undefined
});

// node_modules/effect/dist/esm/Channel.js
var acquireUseRelease4 = acquireUseRelease3;
var embedInput2 = embedInput;
var flatMap17 = flatMap13;
var suspend9 = suspend4;
var void_8 = void_5;
var write2 = write;
var zipRight9 = zipRight4;

// node_modules/effect/dist/esm/Sink.js
var drain4 = drain2;
var foldLeftChunks2 = foldLeftChunks;
var forEach12 = forEach10;
var fromChannel3 = fromChannel;
var unwrapScoped5 = unwrapScoped3;

// node_modules/effect/dist/esm/Stream.js
var exports_Stream = {};
__export(exports_Stream, {
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithNext: () => zipWithNext2,
  zipWithIndex: () => zipWithIndex2,
  zipWithChunks: () => zipWithChunks2,
  zipWith: () => zipWith12,
  zipRight: () => zipRight10,
  zipLeft: () => zipLeft7,
  zipLatestWith: () => zipLatestWith2,
  zipLatestAll: () => zipLatestAll2,
  zipLatest: () => zipLatest2,
  zipFlatten: () => zipFlatten2,
  zipAllWith: () => zipAllWith2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllRight: () => zipAllRight2,
  zipAllLeft: () => zipAllLeft2,
  zipAll: () => zipAll2,
  zip: () => zip9,
  withSpan: () => withSpan6,
  withExecutionPlan: () => withExecutionPlan4,
  whenEffect: () => whenEffect4,
  whenCaseEffect: () => whenCaseEffect2,
  whenCase: () => whenCase2,
  when: () => when4,
  void: () => void_9,
  updateService: () => updateService5,
  unwrapScopedWith: () => unwrapScopedWith4,
  unwrapScoped: () => unwrapScoped6,
  unwrap: () => unwrap4,
  unfoldEffect: () => unfoldEffect2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldChunk: () => unfoldChunk2,
  unfold: () => unfold4,
  transduce: () => transduce2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStream: () => toReadableStream2,
  toQueueOfElements: () => toQueueOfElements2,
  toQueue: () => toQueue3,
  toPull: () => toPull3,
  toPubSub: () => toPubSub3,
  toChannel: () => toChannel3,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterable: () => toAsyncIterable2,
  timeoutTo: () => timeoutTo4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutFail: () => timeoutFail4,
  timeout: () => timeout4,
  tick: () => tick2,
  throttleEffect: () => throttleEffect2,
  throttle: () => throttle2,
  tapSink: () => tapSink2,
  tapErrorCause: () => tapErrorCause5,
  tapError: () => tapError5,
  tapBoth: () => tapBoth4,
  tap: () => tap6,
  takeWhile: () => takeWhile6,
  takeUntilEffect: () => takeUntilEffect2,
  takeUntil: () => takeUntil4,
  takeRight: () => takeRight4,
  take: () => take10,
  sync: () => sync9,
  suspend: () => suspend10,
  succeed: () => succeed17,
  splitOnChunk: () => splitOnChunk2,
  splitLines: () => splitLines3,
  split: () => split3,
  someOrFail: () => someOrFail2,
  someOrElse: () => someOrElse2,
  some: () => some8,
  slidingSize: () => slidingSize2,
  sliding: () => sliding8,
  share: () => share2,
  scopedWith: () => scopedWith5,
  scoped: () => scoped6,
  scheduleWith: () => scheduleWith2,
  schedule: () => schedule3,
  scanReduceEffect: () => scanReduceEffect2,
  scanReduce: () => scanReduce2,
  scanEffect: () => scanEffect2,
  scan: () => scan3,
  runSum: () => runSum2,
  runScoped: () => runScoped3,
  runLast: () => runLast2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoPubSub: () => runIntoPubSub2,
  runHead: () => runHead2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachScoped: () => runForEachScoped2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachChunk: () => runForEachChunk2,
  runForEach: () => runForEach2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldEffect: () => runFoldEffect2,
  runFold: () => runFold2,
  runDrain: () => runDrain3,
  runCount: () => runCount2,
  runCollect: () => runCollect3,
  run: () => run4,
  retry: () => retry6,
  repeatWith: () => repeatWith2,
  repeatValue: () => repeatValue2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatElements: () => repeatElements2,
  repeatEither: () => repeatEither2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffect: () => repeatEffect2,
  repeat: () => repeat3,
  refineOrDieWith: () => refineOrDieWith3,
  refineOrDie: () => refineOrDie3,
  rechunk: () => rechunk2,
  range: () => range4,
  raceAll: () => raceAll4,
  race: () => race5,
  provideSomeLayer: () => provideSomeLayer4,
  provideServiceStream: () => provideServiceStream2,
  provideServiceEffect: () => provideServiceEffect4,
  provideService: () => provideService7,
  provideLayer: () => provideLayer3,
  provideContext: () => provideContext7,
  prepend: () => prepend5,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThrough: () => pipeThrough2,
  peel: () => peel2,
  partitionEither: () => partitionEither2,
  partition: () => partition6,
  paginateEffect: () => paginateEffect2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateChunk: () => paginateChunk2,
  paginate: () => paginate2,
  orElseSucceed: () => orElseSucceed4,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseFail: () => orElseFail4,
  orElseEither: () => orElseEither4,
  orElse: () => orElse10,
  orDieWith: () => orDieWith5,
  orDie: () => orDie6,
  onStart: () => onStart2,
  onError: () => onError4,
  onEnd: () => onEnd2,
  onDone: () => onDone2,
  never: () => never7,
  mkString: () => mkString3,
  mergeWithTag: () => mergeWithTag2,
  mergeWith: () => mergeWith4,
  mergeRight: () => mergeRight2,
  mergeLeft: () => mergeLeft2,
  mergeEither: () => mergeEither2,
  mergeAll: () => mergeAll8,
  merge: () => merge10,
  mapInputContext: () => mapInputContext7,
  mapErrorCause: () => mapErrorCause5,
  mapError: () => mapError8,
  mapEffect: () => mapEffect5,
  mapConcatEffect: () => mapConcatEffect2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcat: () => mapConcat2,
  mapChunksEffect: () => mapChunksEffect2,
  mapChunks: () => mapChunks2,
  mapBoth: () => mapBoth8,
  mapAccumEffect: () => mapAccumEffect2,
  mapAccum: () => mapAccum6,
  map: () => map24,
  make: () => make55,
  let: () => let_6,
  iterate: () => iterate4,
  intersperseAffixes: () => intersperseAffixes2,
  intersperse: () => intersperse3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  interruptWhen: () => interruptWhen3,
  interruptAfter: () => interruptAfter2,
  interleaveWith: () => interleaveWith2,
  interleave: () => interleave2,
  identity: () => identity3,
  haltWhenDeferred: () => haltWhenDeferred2,
  haltWhen: () => haltWhen2,
  haltAfter: () => haltAfter2,
  groupedWithin: () => groupedWithin2,
  grouped: () => grouped2,
  groupByKey: () => groupByKey2,
  groupBy: () => groupBy3,
  groupAdjacentBy: () => groupAdjacentBy2,
  fromTQueue: () => fromTQueue2,
  fromTPubSub: () => fromTPubSub2,
  fromSchedule: () => fromSchedule2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromReadableStream: () => fromReadableStream2,
  fromQueue: () => fromQueue4,
  fromPull: () => fromPull3,
  fromPubSub: () => fromPubSub4,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromIterableEffect: () => fromIterableEffect2,
  fromIterable: () => fromIterable12,
  fromEventListener: () => fromEventListener2,
  fromEffectOption: () => fromEffectOption2,
  fromEffect: () => fromEffect8,
  fromChunks: () => fromChunks2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunk: () => fromChunk2,
  fromChannel: () => fromChannel4,
  fromAsyncIterable: () => fromAsyncIterable2,
  forever: () => forever6,
  flattenTake: () => flattenTake2,
  flattenIterables: () => flattenIterables2,
  flattenExitOption: () => flattenExitOption2,
  flattenEffect: () => flattenEffect2,
  flattenChunks: () => flattenChunks2,
  flatten: () => flatten13,
  flatMap: () => flatMap18,
  findEffect: () => findEffect3,
  find: () => find3,
  finalizer: () => finalizer2,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapEffect: () => filterMapEffect2,
  filterMap: () => filterMap8,
  filterEffect: () => filterEffect2,
  filter: () => filter10,
  failSync: () => failSync8,
  failCauseSync: () => failCauseSync7,
  failCause: () => failCause14,
  fail: () => fail16,
  execute: () => execute2,
  ensuringWith: () => ensuringWith4,
  ensuring: () => ensuring8,
  encodeText: () => encodeText2,
  empty: () => empty37,
  either: () => either6,
  dropWhileEffect: () => dropWhileEffect3,
  dropWhile: () => dropWhile7,
  dropUntilEffect: () => dropUntilEffect3,
  dropUntil: () => dropUntil5,
  dropRight: () => dropRight3,
  drop: () => drop5,
  drainFork: () => drainFork2,
  drain: () => drain5,
  distributedWithDynamic: () => distributedWithDynamic2,
  distributedWith: () => distributedWith2,
  dieSync: () => dieSync7,
  dieMessage: () => dieMessage6,
  die: () => die11,
  decodeText: () => decodeText2,
  debounce: () => debounce2,
  crossWith: () => crossWith2,
  crossRight: () => crossRight2,
  crossLeft: () => crossLeft2,
  cross: () => cross2,
  contextWithStream: () => contextWithStream2,
  contextWithEffect: () => contextWithEffect6,
  contextWith: () => contextWith6,
  context: () => context8,
  concatAll: () => concatAll3,
  concat: () => concat3,
  combineChunks: () => combineChunks2,
  combine: () => combine13,
  chunksWith: () => chunksWith2,
  chunks: () => chunks2,
  changesWithEffect: () => changesWithEffect2,
  changesWith: () => changesWith2,
  changes: () => changes2,
  catchTags: () => catchTags4,
  catchTag: () => catchTag4,
  catchSomeCause: () => catchSomeCause4,
  catchSome: () => catchSome4,
  catchAllCause: () => catchAllCause6,
  catchAll: () => catchAll7,
  bufferChunks: () => bufferChunks2,
  buffer: () => buffer3,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcast: () => broadcast2,
  branchAfter: () => branchAfter2,
  bindTo: () => bindTo6,
  bindEffect: () => bindEffect2,
  bind: () => bind6,
  asyncScoped: () => asyncScoped2,
  asyncPush: () => asyncPush2,
  asyncEffect: () => asyncEffect4,
  async: () => _async2,
  as: () => as9,
  aggregateWithinEither: () => aggregateWithinEither2,
  aggregateWithin: () => aggregateWithin2,
  aggregate: () => aggregate2,
  acquireRelease: () => acquireRelease4,
  accumulateChunks: () => accumulateChunks2,
  accumulate: () => accumulate2,
  StreamTypeId: () => StreamTypeId3,
  Do: () => Do5,
  DefaultChunkSize: () => DefaultChunkSize2
});

// node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _K: (_) => _,
  _V: (_) => _
};
var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
var evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self2, f, options) => flatMap16(self2.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: options?.bufferSize ?? 16
}));
var make54 = (grouped2) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped2
});
var groupBy2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options) => make54(unwrapScoped4(gen2(function* () {
  const decider = yield* make24();
  const output = yield* acquireRelease2(bounded5(options?.bufferSize ?? 16), (queue) => shutdown4(queue));
  const ref = yield* make26(new Map);
  const add6 = yield* pipe(mapEffectSequential(self2, f), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value]) => flatMap10(_await(decider), (f2) => f2(key, value)), (exit3) => offer3(output, exit3)));
  yield* succeed2(decider, (key, _) => pipe(get11(ref), map17((map24) => fromNullable(map24.get(key))), flatMap10(match2({
    onNone: () => flatMap10(add6, ([index, queue]) => zipRight3(update4(ref, (map24) => map24.set(key, index)), pipe(offer3(output, succeed4([key, mapDequeue(queue, (exit3) => new TakeImpl(pipe(exit3, map13((tuple3) => of2(tuple3[1])))))])), as3((n) => n === index)))),
    onSome: (index) => succeed8((n) => n === index)
  }))));
  return flattenExitOption(fromQueue2(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options) => {
  if (options?.key) {
    return evaluate2(groupByKey(self2, options.key, {
      bufferSize: options.bufferSize
    }), (_, s) => mapEffectSequential(s, f));
  }
  return matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, f), (n) => options?.unordered ? flatMap16(self2, (a) => fromEffect7(f(a)), {
    concurrency: n
  }) : mapEffectPar(self2, n, f));
});
var bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag, f, options) => mapEffectOptions(self2, (k) => map17(f(k), (a) => ({
  ...k,
  [tag]: a
})), options));
var mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);

class MapDequeue extends Class {
  dequeue;
  f;
  [DequeueTypeId2] = {
    _Out: (_) => _
  };
  constructor(dequeue, f) {
    super();
    this.dequeue = dequeue;
    this.f = f;
  }
  capacity() {
    return capacity4(this.dequeue);
  }
  get size() {
    return size13(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown3(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown3(this.dequeue);
  }
  get shutdown() {
    return shutdown4(this.dequeue);
  }
  get isFull() {
    return isFull3(this.dequeue);
  }
  get isEmpty() {
    return isEmpty12(this.dequeue);
  }
  get take() {
    return pipe(take4(this.dequeue), map17((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map17(map6((a) => this.f(a))));
  }
  takeUpTo(max7) {
    return pipe(takeUpTo2(this.dequeue, max7), map17(map6((a) => this.f(a))));
  }
  takeBetween(min5, max7) {
    return pipe(takeBetween2(this.dequeue, min5, max7), map17(map6((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map17(map6((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map17(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
}
var groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options) => {
  const loop3 = (map24, outerQueue) => readWithCause({
    onInput: (input) => flatMap13(fromEffect4(forEach9(groupByIterable(input, f), ([key, values3]) => {
      const innerQueue = map24.get(key);
      if (innerQueue === undefined) {
        return pipe(bounded5(options?.bufferSize ?? 16), flatMap10((innerQueue2) => pipe(sync3(() => {
          map24.set(key, innerQueue2);
        }), zipRight3(offer3(outerQueue, of5([key, innerQueue2]))), zipRight3(pipe(offer3(innerQueue2, chunk2(values3)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk2(values3)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
    }, {
      discard: true
    })), () => loop3(map24, outerQueue)),
    onFailure: (cause3) => fromEffect4(offer3(outerQueue, failCause10(cause3))),
    onDone: () => pipe(fromEffect4(pipe(forEach9(map24.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
      discard: true
    }), zipRight3(offer3(outerQueue, end4)))))
  });
  return make54(unwrapScopedWith3((scope4) => gen2(function* () {
    const map24 = new Map;
    const queue = yield* unbounded5();
    yield* addFinalizer2(scope4, shutdown4(queue));
    return yield* toChannel2(self2).pipe(pipeTo(loop3(map24, queue)), drain, runIn(scope4), forkIn2(scope4), as3(flattenTake(fromQueue2(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map24 = new Map;
  let next4;
  while ((next4 = iterator.next()) && !next4.done) {
    const value = next4.value;
    const key = f(value);
    if (map24.has(key)) {
      const innerBuilder = map24.get(key);
      innerBuilder.push(value);
    } else {
      const innerBuilder = [value];
      builder.push([key, innerBuilder]);
      map24.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple3) => [tuple3[0], unsafeFromArray(tuple3[1])]));
});

// node_modules/effect/dist/esm/Stream.js
var StreamTypeId3 = StreamTypeId2;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease4 = acquireRelease3;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as9 = as7;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncPush2 = asyncPush;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var share2 = share;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer3 = buffer;
var bufferChunks2 = bufferChunks;
var catchAll7 = catchAll6;
var catchAllCause6 = catchAllCause5;
var catchSome4 = catchSome3;
var catchTag4 = catchTag3;
var catchTags4 = catchTags3;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine13 = combine12;
var combineChunks2 = combineChunks;
var concat3 = concat2;
var concatAll3 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die11 = die9;
var dieSync7 = dieSync5;
var dieMessage6 = dieMessage4;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain5 = drain3;
var drainFork2 = drainFork;
var drop5 = drop3;
var dropRight3 = dropRight2;
var dropUntil5 = dropUntil3;
var dropUntilEffect3 = dropUntilEffect;
var dropWhile7 = dropWhile5;
var dropWhileEffect3 = dropWhileEffect;
var either6 = either5;
var empty37 = empty36;
var ensuring8 = ensuring6;
var ensuringWith4 = ensuringWith2;
var context8 = context5;
var contextWith6 = contextWith3;
var contextWithEffect6 = contextWithEffect3;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail16 = fail15;
var failSync8 = failSync6;
var failCause14 = failCause12;
var failCauseSync7 = failCauseSync5;
var filter10 = filter9;
var filterEffect2 = filterEffect;
var filterMap8 = filterMap7;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile4 = filterMapWhile3;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find3 = find2;
var findEffect3 = findEffect;
var flatMap18 = flatMap16;
var flatten13 = flatten12;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever6 = forever5;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel4 = fromChannel2;
var toChannel3 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect8 = fromEffect7;
var fromEffectOption2 = fromEffectOption;
var fromPubSub4 = fromPubSub;
var fromTPubSub2 = fromTPubSub;
var fromIterable12 = fromIterable11;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue4 = fromQueue2;
var fromTQueue2 = fromTQueue;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy3 = groupBy2;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity3 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse3 = intersperse2;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter2 = interruptAfter;
var interruptWhen3 = interruptWhen2;
var interruptWhenDeferred3 = interruptWhenDeferred2;
var iterate4 = iterate3;
var make55 = make53;
var map24 = map23;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth8 = mapBoth7;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect5 = mapEffectOptions;
var mapError8 = mapError6;
var mapErrorCause5 = mapErrorCause4;
var merge10 = merge9;
var mergeAll8 = mergeAll7;
var mergeWithTag2 = mergeWithTag;
var mergeWith4 = mergeWith3;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString3 = mkString2;
var never7 = never4;
var onEnd2 = onEnd;
var onError4 = onError3;
var onDone2 = onDone;
var onStart2 = onStart;
var orDie6 = orDie4;
var orDieWith5 = orDieWith4;
var orElse10 = orElse8;
var orElseEither4 = orElseEither3;
var orElseFail4 = orElseFail3;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed4 = orElseSucceed3;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition6 = partition5;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend5 = prepend4;
var provideContext7 = provideContext5;
var provideLayer3 = provideLayer;
var provideService7 = provideService5;
var provideServiceEffect4 = provideServiceEffect3;
var provideServiceStream2 = provideServiceStream;
var mapInputContext7 = mapInputContext5;
var provideSomeLayer4 = provideSomeLayer2;
var race5 = race3;
var raceAll4 = raceAll3;
var range4 = range3;
var rechunk2 = rechunk;
var refineOrDie3 = refineOrDie;
var refineOrDieWith3 = refineOrDieWith;
var repeat3 = repeat2;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry6 = retry5;
var withExecutionPlan4 = withExecutionPlan3;
var run4 = run3;
var runCollect3 = runCollect;
var runCount2 = runCount;
var runDrain3 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped3 = runScoped2;
var runSum2 = runSum;
var scan3 = scan2;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped6 = scoped5;
var scopedWith5 = scopedWith4;
var sliding8 = sliding7;
var slidingSize2 = slidingSize;
var some8 = some6;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split3 = split2;
var splitOnChunk2 = splitOnChunk;
var splitLines3 = splitLines2;
var succeed17 = succeed15;
var sync9 = sync7;
var suspend10 = suspend8;
var take10 = take8;
var takeRight4 = takeRight3;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile6 = takeWhile5;
var tap6 = tap5;
var tapBoth4 = tapBoth3;
var tapError5 = tapError4;
var tapErrorCause5 = tapErrorCause4;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout4 = timeout3;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub3 = toPubSub2;
var toPull3 = toPull2;
var toQueue3 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var toReadableStreamEffect2 = toReadableStreamEffect;
var toReadableStreamRuntime2 = toReadableStreamRuntime;
var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
var toAsyncIterableEffect2 = toAsyncIterableEffect;
var toAsyncIterable2 = toAsyncIterable;
var transduce2 = transduce;
var unfold4 = unfold3;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_9 = void_7;
var unwrap4 = unwrap2;
var unwrapScoped6 = unwrapScoped4;
var unwrapScopedWith4 = unwrapScopedWith3;
var updateService5 = updateService3;
var when4 = when3;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan6 = withSpan5;
var zip9 = zip7;
var zipFlatten2 = zipFlatten;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestAll2 = zipLatestAll;
var zipLatestWith2 = zipLatestWith;
var zipLeft7 = zipLeft5;
var zipRight10 = zipRight8;
var zipWith12 = zipWith11;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do5 = Do4;
var bind6 = bind5;
var bindEffect2 = bindEffect;
var bindTo6 = bindTo5;
var let_6 = let_5;
var decodeText2 = decodeText;
var encodeText2 = encodeText;
var fromEventListener2 = fromEventListener;

// node_modules/@effect/platform/dist/esm/Error.js
var exports_Error = {};
__export(exports_Error, {
  isPlatformError: () => isPlatformError,
  TypeIdError: () => TypeIdError,
  SystemError: () => SystemError,
  PlatformErrorTypeId: () => PlatformErrorTypeId2,
  BadArgument: () => BadArgument
});

// node_modules/@effect/platform/dist/esm/internal/error.js
var PlatformErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Error/PlatformErrorTypeId");
var make56 = (tag) => (props) => struct2({
  [PlatformErrorTypeId]: PlatformErrorTypeId,
  _tag: tag,
  ...props
});
var badArgument = /* @__PURE__ */ make56("BadArgument");
var systemError = /* @__PURE__ */ make56("SystemError");

// node_modules/@effect/platform/dist/esm/Error.js
var PlatformErrorTypeId2 = PlatformErrorTypeId;
var isPlatformError = (u) => hasProperty(u, PlatformErrorTypeId2);
var TypeIdError = (typeId, tag) => {

  class Base3 extends Error3 {
    _tag = tag;
  }
  Base3.prototype[typeId] = typeId;
  Base3.prototype.name = tag;
  return Base3;
};
var BadArgument = badArgument;
var SystemError = systemError;

// node_modules/@effect/platform/dist/esm/internal/fileSystem.js
var tag = /* @__PURE__ */ GenericTag("@effect/platform/FileSystem");
var Size = (bytes) => typeof bytes === "bigint" ? bytes : BigInt(bytes);
var bigint1024 = /* @__PURE__ */ BigInt(1024);
var bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;
var make57 = (impl) => {
  return tag.of({
    ...impl,
    exists: (path) => pipe(impl.access(path), as3(true), catchTag2("SystemError", (e) => e.reason === "NotFound" ? succeed8(false) : fail8(e))),
    readFileString: (path, encoding) => tryMap2(impl.readFile(path), {
      try: (_) => new TextDecoder(encoding).decode(_),
      catch: () => BadArgument({
        module: "FileSystem",
        method: "readFileString",
        message: "invalid encoding"
      })
    }),
    stream: (path, options) => pipe(impl.open(path, {
      flag: "r"
    }), options?.offset ? tap2((file) => file.seek(options.offset, "start")) : identity, map17((file) => stream(file, options)), unwrapScoped6),
    sink: (path, options) => pipe(impl.open(path, {
      flag: "w",
      ...options
    }), map17((file) => forEach12((_) => file.writeAll(_))), unwrapScoped5),
    writeFileString: (path, data, options) => flatMap10(try_2({
      try: () => new TextEncoder().encode(data),
      catch: () => BadArgument({
        module: "FileSystem",
        method: "writeFileString",
        message: "could not encode string"
      })
    }), (_) => impl.writeFile(path, _, options))
  });
};
var stream = (file, {
  bufferSize = 16,
  bytesToRead: bytesToRead_,
  chunkSize: chunkSize_ = Size(64 * 1024)
} = {}) => {
  const bytesToRead = bytesToRead_ !== undefined ? Size(bytesToRead_) : undefined;
  const chunkSize = Size(chunkSize_);
  function loop3(totalBytesRead) {
    if (bytesToRead !== undefined && bytesToRead <= totalBytesRead) {
      return void_8;
    }
    const toRead = bytesToRead !== undefined && bytesToRead - totalBytesRead < chunkSize ? bytesToRead - totalBytesRead : chunkSize;
    return flatMap17(file.readAlloc(toRead), match2({
      onNone: () => void_8,
      onSome: (buf) => flatMap17(write2(of2(buf)), (_) => loop3(totalBytesRead + BigInt(buf.length)))
    }));
  }
  return bufferChunks2(fromChannel4(loop3(BigInt(0))), {
    capacity: bufferSize
  });
};

// node_modules/@effect/platform/dist/esm/FileSystem.js
var Size2 = Size;
var FileSystem = tag;
var make58 = make57;
var FileTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/FileSystem/File");
var FileDescriptor = /* @__PURE__ */ nominal();
var WatchEventCreate = /* @__PURE__ */ tagged2("Create");
var WatchEventUpdate = /* @__PURE__ */ tagged2("Update");
var WatchEventRemove = /* @__PURE__ */ tagged2("Remove");

class WatchBackend extends (/* @__PURE__ */ Tag2("@effect/platform/FileSystem/WatchBackend")()) {
}

// node_modules/@effect/cli/dist/esm/internal/files.js
var Ini = __toESM(require_ini(), 1);
var Toml = __toESM(require_toml(), 1);

// node_modules/yaml/dist/index.js
var composer = require_composer();
var Document = require_Document();
var Schema = require_Schema();
var errors = require_errors();
var Alias = require_Alias();
var identity4 = require_identity();
var Pair = require_Pair();
var Scalar = require_Scalar();
var YAMLMap = require_YAMLMap();
var YAMLSeq = require_YAMLSeq();
var cst = require_cst();
var lexer = require_lexer();
var lineCounter = require_line_counter();
var parser = require_parser2();
var publicApi = require_public_api();
var visit = require_visit();
var $Composer = composer.Composer;
var $Document = Document.Document;
var $Schema = Schema.Schema;
var $YAMLError = errors.YAMLError;
var $YAMLParseError = errors.YAMLParseError;
var $YAMLWarning = errors.YAMLWarning;
var $Alias = Alias.Alias;
var $isAlias = identity4.isAlias;
var $isCollection = identity4.isCollection;
var $isDocument = identity4.isDocument;
var $isMap = identity4.isMap;
var $isNode = identity4.isNode;
var $isPair = identity4.isPair;
var $isScalar = identity4.isScalar;
var $isSeq = identity4.isSeq;
var $Pair = Pair.Pair;
var $Scalar = Scalar.Scalar;
var $YAMLMap = YAMLMap.YAMLMap;
var $YAMLSeq = YAMLSeq.YAMLSeq;
var $Lexer = lexer.Lexer;
var $LineCounter = lineCounter.LineCounter;
var $Parser = parser.Parser;
var $parse = publicApi.parse;
var $parseAllDocuments = publicApi.parseAllDocuments;
var $parseDocument = publicApi.parseDocument;
var $stringify = publicApi.stringify;
var $visit = visit.visit;
var $visitAsync = visit.visitAsync;

// node_modules/@effect/cli/dist/esm/internal/files.js
var fileParsers = {
  json: (content) => JSON.parse(content),
  yaml: (content) => $parse(content),
  yml: (content) => $parse(content),
  ini: (content) => Ini.parse(content),
  toml: (content) => Toml.parse(content),
  tml: (content) => Toml.parse(content)
};
var read2 = (path) => flatMap10(FileSystem, (fs) => matchEffect2(fs.readFile(path), {
  onFailure: (error3) => fail8(`Could not read file (${path}): ${error3}`),
  onSuccess: (content) => succeed8([path, content])
}));
var readString = (path) => flatMap10(FileSystem, (fs) => matchEffect2(fs.readFileString(path), {
  onFailure: (error3) => fail8(`Could not read file (${path}): ${error3}`),
  onSuccess: (content) => succeed8([path, content])
}));
var parse5 = (path, content, format4) => {
  const parser2 = fileParsers[format4 ?? path.split(".").pop()];
  if (parser2 === undefined) {
    return fail8(`Unsupported file format: ${format4}`);
  }
  return try_2({
    try: () => parser2(content),
    catch: (e) => `Could not parse ${format4} file (${path}): ${e}`
  });
};

// node_modules/@effect/typeclass/dist/esm/internal/Iterable.js
function reduce15(b, f) {
  return function(iterable) {
    if (Array.isArray(iterable)) {
      return iterable.reduce(f, b);
    }
    let result = b;
    for (const n of iterable) {
      result = f(result, n);
    }
    return result;
  };
}
function map25(f) {
  return function(iterable) {
    if (Array.isArray(iterable)) {
      return iterable.map(f);
    }
    return function* () {
      for (const n of iterable) {
        yield f(n);
      }
    }();
  };
}

// node_modules/@effect/typeclass/dist/esm/Product.js
var struct3 = (F) => (fields) => {
  const keys6 = Object.keys(fields);
  return F.imap(F.productAll(keys6.map((k) => fields[k])), (values3) => {
    const out = {};
    for (let i = 0;i < values3.length; i++) {
      out[keys6[i]] = values3[i];
    }
    return out;
  }, (r) => keys6.map((k) => r[k]));
};

// node_modules/@effect/typeclass/dist/esm/Semigroup.js
var make59 = (combine14, combineMany2 = (self2, collection) => reduce15(self2, combine14)(collection)) => ({
  combine: combine14,
  combineMany: combineMany2
});
var constant2 = (a) => make59(() => a, () => a);
var first2 = () => make59((a) => a, (a) => a);
var imap = /* @__PURE__ */ dual(3, (S, to, from) => make59((self2, that) => to(S.combine(from(self2), from(that))), (self2, collection) => to(S.combineMany(from(self2), map25(from)(collection)))));
var product = (self2, that) => make59(([xa, xb], [ya, yb]) => [self2.combine(xa, ya), that.combine(xb, yb)]);
var productAll = (collection) => {
  return make59((x, y) => {
    const len = Math.min(x.length, y.length);
    const out = [];
    let collectionLength = 0;
    for (const s of collection) {
      if (collectionLength >= len) {
        break;
      }
      out.push(s.combine(x[collectionLength], y[collectionLength]));
      collectionLength++;
    }
    return out;
  });
};
var productMany = (self2, collection) => {
  const semigroup = productAll(collection);
  return make59((x, y) => [self2.combine(x[0], y[0]), ...semigroup.combine(x.slice(1), y.slice(1))]);
};
var of6 = constant2;
var Product = {
  of: of6,
  imap,
  product,
  productMany,
  productAll
};
var array4 = () => make59((self2, that) => self2.concat(that));
var struct4 = /* @__PURE__ */ struct3(Product);

// node_modules/@effect/typeclass/dist/esm/Monoid.js
var fromSemigroup = (S, empty38) => ({
  combine: S.combine,
  combineMany: S.combineMany,
  empty: empty38,
  combineAll: (collection) => S.combineMany(empty38, collection)
});
var array5 = () => fromSemigroup(array4(), []);
var struct5 = (fields) => {
  const empty38 = {};
  for (const k in fields) {
    if (Object.prototype.hasOwnProperty.call(fields, k)) {
      empty38[k] = fields[k].empty;
    }
  }
  return fromSemigroup(struct4(fields), empty38);
};

// node_modules/@effect/printer-ansi/dist/esm/internal/color.js
var black = {
  _tag: "Black"
};
var red = {
  _tag: "Red"
};
var green = {
  _tag: "Green"
};
var magenta = {
  _tag: "Magenta"
};
var cyan = {
  _tag: "Cyan"
};
var white = {
  _tag: "White"
};
var toCode = (color) => {
  switch (color._tag) {
    case "Black": {
      return 0;
    }
    case "Red": {
      return 1;
    }
    case "Green": {
      return 2;
    }
    case "Yellow": {
      return 3;
    }
    case "Blue": {
      return 4;
    }
    case "Magenta": {
      return 5;
    }
    case "Cyan": {
      return 6;
    }
    case "White": {
      return 7;
    }
  }
};

// node_modules/@effect/printer-ansi/dist/esm/internal/sgr.js
var reset = {
  _tag: "Reset"
};
var setBold = (bold) => ({
  _tag: "SetBold",
  bold
});
var setColor = (color, vivid, layer) => ({
  _tag: "SetColor",
  color,
  vivid,
  layer
});
var setItalicized = (italicized) => ({
  _tag: "SetItalicized",
  italicized
});
var setStrikethrough = (strikethrough) => ({
  _tag: "SetStrikethrough",
  strikethrough
});
var setUnderlined = (underlined) => ({
  _tag: "SetUnderlined",
  underlined
});
var toCode2 = (self2) => {
  switch (self2._tag) {
    case "Reset": {
      return 0;
    }
    case "SetBold": {
      return self2.bold ? 1 : 22;
    }
    case "SetColor": {
      switch (self2.layer) {
        case "foreground": {
          return self2.vivid ? 90 + toCode(self2.color) : 30 + toCode(self2.color);
        }
        case "background": {
          return self2.vivid ? 100 + toCode(self2.color) : 40 + toCode(self2.color);
        }
      }
    }
    case "SetItalicized": {
      return self2.italicized ? 3 : 23;
    }
    case "SetStrikethrough": {
      return self2.strikethrough ? 9 : 29;
    }
    case "SetUnderlined": {
      return self2.underlined ? 4 : 24;
    }
  }
};
var toEscapeSequence = (sgrs) => csi("m", sgrs);
var csi = (controlFunction, sgrs) => {
  const params = Array.from(sgrs).map((sgr) => `${toCode2(sgr)}`).join(";");
  return `\x1B[${params}${controlFunction}`;
};

// node_modules/@effect/printer-ansi/dist/esm/internal/ansi.js
var AnsiSymbolKey = "@effect/printer-ansi/Ansi";
var AnsiTypeId = /* @__PURE__ */ Symbol.for(AnsiSymbolKey);
var make60 = (params) => ({
  ...AnsiMonoid.empty,
  ...params
});
var typeIdSemigroup = /* @__PURE__ */ first2();
var getFirstSomeSemigroup = /* @__PURE__ */ make59((self2, that) => isSome2(self2) ? self2 : that);
var AnsiSemigroup = /* @__PURE__ */ struct4({
  [AnsiTypeId]: typeIdSemigroup,
  commands: /* @__PURE__ */ array4(),
  foreground: getFirstSomeSemigroup,
  background: getFirstSomeSemigroup,
  bold: getFirstSomeSemigroup,
  italicized: getFirstSomeSemigroup,
  strikethrough: getFirstSomeSemigroup,
  underlined: getFirstSomeSemigroup
});
var typeIdMonoid = /* @__PURE__ */ fromSemigroup(typeIdSemigroup, AnsiTypeId);
var monoidOrElse = /* @__PURE__ */ fromSemigroup(getFirstSomeSemigroup, /* @__PURE__ */ none2());
var AnsiMonoid = /* @__PURE__ */ struct5({
  [AnsiTypeId]: typeIdMonoid,
  commands: /* @__PURE__ */ array5(),
  foreground: monoidOrElse,
  background: monoidOrElse,
  bold: monoidOrElse,
  italicized: monoidOrElse,
  strikethrough: monoidOrElse,
  underlined: monoidOrElse
});
var none10 = AnsiMonoid.empty;
var ESC = "\x1B[";
var BEL = "\x07";
var SEP = ";";
var bold = /* @__PURE__ */ make60({
  bold: /* @__PURE__ */ some2(/* @__PURE__ */ setBold(true))
});
var italicized = /* @__PURE__ */ make60({
  italicized: /* @__PURE__ */ some2(/* @__PURE__ */ setItalicized(true))
});
var strikethrough = /* @__PURE__ */ make60({
  strikethrough: /* @__PURE__ */ some2(/* @__PURE__ */ setStrikethrough(true))
});
var underlined = /* @__PURE__ */ make60({
  underlined: /* @__PURE__ */ some2(/* @__PURE__ */ setUnderlined(true))
});
var brightColor = (color) => make60({
  foreground: some2(setColor(color, true, "foreground"))
});
var color = (color2) => make60({
  foreground: some2(setColor(color2, false, "foreground"))
});
var black2 = /* @__PURE__ */ color(black);
var red2 = /* @__PURE__ */ color(red);
var green2 = /* @__PURE__ */ color(green);
var white2 = /* @__PURE__ */ color(white);
var blackBright = /* @__PURE__ */ brightColor(black);
var cyanBright = /* @__PURE__ */ brightColor(cyan);
var beep = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(BEL)
});
var cursorTo = (column, row) => {
  if (row === undefined) {
    const command2 = `${ESC}${Math.max(column + 1, 0)}G`;
    return make60({
      commands: of(command2)
    });
  }
  const command = `${ESC}${row + 1}${SEP}${Math.max(column + 1, 0)}H`;
  return make60({
    commands: of(command)
  });
};
var cursorMove = (column, row = 0) => {
  let command = "";
  if (row < 0) {
    command += `${ESC}${-row}A`;
  }
  if (row > 0) {
    command += `${ESC}${row}B`;
  }
  if (column > 0) {
    command += `${ESC}${column}C`;
  }
  if (column < 0) {
    command += `${ESC}${-column}D`;
  }
  return make60({
    commands: of(command)
  });
};
var cursorDown = (lines = 1) => {
  const command = `${ESC}${lines}B`;
  return make60({
    commands: of(command)
  });
};
var cursorLeft = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}G`)
});
var cursorSavePosition = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}s`)
});
var cursorRestorePosition = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}u`)
});
var cursorHide = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}?25l`)
});
var cursorShow = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}?25h`)
});
var eraseLines = (rows) => {
  let command = "";
  for (let i = 0;i < rows; i++) {
    command += `${ESC}2K` + (i < rows - 1 ? `${ESC}1A` : "");
  }
  if (rows > 0) {
    command += `${ESC}G`;
  }
  return make60({
    commands: of(command)
  });
};
var eraseEndLine = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}K`)
});
var eraseStartLine = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}1K`)
});
var eraseLine = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}2K`)
});
var eraseDown = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}J`)
});
var eraseUp = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}1J`)
});
var eraseScreen = /* @__PURE__ */ make60({
  commands: /* @__PURE__ */ of(`${ESC}2J`)
});
var stringify = (self2) => stringifyInternal(self2);
var combine14 = /* @__PURE__ */ dual(2, (self2, that) => combineInternal(self2, that));
var combineInternal = (self2, that) => AnsiSemigroup.combine(self2, that);
var stringifyInternal = (self2) => {
  const displaySequence = toEscapeSequence(getSomes([some2(reset), self2.foreground, self2.background, self2.bold, self2.italicized, self2.strikethrough, self2.underlined]));
  const commandSequence = join(self2.commands, "");
  return `${displaySequence}${commandSequence}`;
};

// node_modules/@effect/printer-ansi/dist/esm/Ansi.js
var bold2 = bold;
var italicized2 = italicized;
var strikethrough2 = strikethrough;
var underlined2 = underlined;
var color2 = color;
var black3 = black2;
var red3 = red2;
var green3 = green2;
var white3 = white2;
var blackBright2 = blackBright;
var cyanBright2 = cyanBright;
var combine15 = combine14;

// node_modules/@effect/printer/dist/esm/internal/flatten.js
var FlattenSymbolKey = "@effect/printer/Flatten";
var FlattenTypeId = /* @__PURE__ */ Symbol.for(FlattenSymbolKey);
var protoHash = {
  Flattened: (self2) => combine(hash(self2.value))(string2(FlattenSymbolKey)),
  AlreadyFlat: (_) => combine(string2("@effect/printer/Flattened/AlreadyFlat"))(string2(FlattenSymbolKey)),
  NeverFlat: (_) => combine(string2("@effect/printer/Flattened/NeverFlat"))(string2(FlattenSymbolKey))
};
var protoEqual = {
  Flattened: (self2, that) => isFlatten(that) && that._tag === "Flattened" && equals(self2.value, that.value),
  AlreadyFlat: (_, that) => isFlatten(that) && that._tag === "AlreadyFlat",
  NeverFlat: (_, that) => isFlatten(that) && that._tag === "NeverFlat"
};
var proto12 = {
  [FlattenTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual[this._tag](this, that);
  }
};
var isFlatten = (u) => typeof u === "object" && u != null && (FlattenTypeId in u);
var isFlattened = (self2) => self2._tag === "Flattened";
var isAlreadyFlat = (self2) => self2._tag === "AlreadyFlat";
var isNeverFlat = (self2) => self2._tag === "NeverFlat";
var flattened = (value) => (() => {
  const op = Object.create(proto12);
  op._tag = "Flattened";
  op.value = value;
  return op;
})();
var alreadyFlat = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto12);
  op._tag = "AlreadyFlat";
  return op;
})();
var neverFlat = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto12);
  op._tag = "NeverFlat";
  return op;
})();
var map26 = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case "Flattened": {
      return flattened(f(self2.value));
    }
    case "AlreadyFlat": {
      return alreadyFlat;
    }
    case "NeverFlat": {
      return neverFlat;
    }
  }
});

// node_modules/@effect/printer/dist/esm/internal/doc.js
var DocSymbolKey = "@effect/printer/Doc";
var DocTypeId = /* @__PURE__ */ Symbol.for(DocSymbolKey);
var protoHash2 = {
  Fail: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Fail")),
  Empty: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Empty")),
  Char: (self2) => combine(hash(DocSymbolKey))(string2(self2.char)),
  Text: (self2) => combine(hash(DocSymbolKey))(string2(self2.text)),
  Line: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Line")),
  FlatAlt: (self2) => combine(hash(DocSymbolKey))(combine(hash(self2.left))(hash(self2.right))),
  Cat: (self2) => combine(hash(DocSymbolKey))(combine(hash(self2.left))(hash(self2.right))),
  Nest: (self2) => combine(hash(DocSymbolKey))(combine(hash(self2.indent))(hash(self2.doc))),
  Union: (self2) => combine(hash(DocSymbolKey))(combine(hash(self2.left))(hash(self2.right))),
  Column: (self2) => combine(hash(DocSymbolKey))(hash(self2.react)),
  WithPageWidth: (self2) => combine(hash(DocSymbolKey))(hash(self2.react)),
  Nesting: (self2) => combine(hash(DocSymbolKey))(hash(self2.react)),
  Annotated: (self2) => combine(hash(DocSymbolKey))(combine(hash(self2.annotation))(hash(self2.doc)))
};
var protoEqual2 = {
  Fail: (_, that) => isDoc(that) && that._tag === "Fail",
  Empty: (_, that) => isDoc(that) && that._tag === "Empty",
  Char: (self2, that) => isDoc(that) && that._tag === "Char" && self2.char === that.char,
  Text: (self2, that) => isDoc(that) && that._tag === "Text" && self2.text === that.text,
  Line: (_, that) => isDoc(that) && that._tag === "Line",
  FlatAlt: (self2, that) => isDoc(that) && that._tag === "FlatAlt" && equals(that.left)(self2.left) && equals(that.right)(self2.right),
  Cat: (self2, that) => isDoc(that) && that._tag === "Cat" && equals(that.left)(self2.left) && equals(that.right)(self2.right),
  Nest: (self2, that) => isDoc(that) && that._tag === "Nest" && self2.indent === that.indent && equals(that.doc)(self2.doc),
  Union: (self2, that) => isDoc(that) && that._tag === "Union" && equals(that.left)(self2.left) && equals(that.right)(self2.right),
  Column: (self2, that) => isDoc(that) && that._tag === "Column" && equals(that.react)(self2.react),
  WithPageWidth: (self2, that) => isDoc(that) && that._tag === "WithPageWidth" && equals(that.react)(self2.react),
  Nesting: (self2, that) => isDoc(that) && that._tag === "Nesting" && equals(that.react)(self2.react),
  Annotated: (self2, that) => isDoc(that) && that._tag === "Annotated" && equals(that.annotation)(self2.annotation) && equals(that.doc)(self2.doc)
};
var proto13 = {
  [DocTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash2[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual2[this._tag](this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isDoc = (u) => typeof u === "object" && u != null && (DocTypeId in u);
var isEmpty15 = (self2) => self2._tag === "Empty";
var isChar = (self2) => self2._tag === "Char";
var isText = (self2) => self2._tag === "Text";
var isCat = (self2) => self2._tag === "Cat";
var isNest = (self2) => self2._tag === "Nest";
var char = (char2) => {
  const op = Object.create(proto13);
  op._tag = "Char";
  op.char = char2;
  return op;
};
var text = (text2) => {
  const op = Object.create(proto13);
  op._tag = "Text";
  op.text = text2;
  return op;
};
var flatAlt = /* @__PURE__ */ dual(2, (self2, that) => {
  const op = Object.create(proto13);
  op._tag = "FlatAlt";
  op.left = self2;
  op.right = that;
  return op;
});
var union11 = /* @__PURE__ */ dual(2, (self2, that) => {
  const op = Object.create(proto13);
  op._tag = "Union";
  op.left = self2;
  op.right = that;
  return op;
});
var cat = /* @__PURE__ */ dual(2, (self2, that) => {
  const op = Object.create(proto13);
  op._tag = "Cat";
  op.left = self2;
  op.right = that;
  return op;
});
var empty38 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto13);
  op._tag = "Empty";
  return op;
})();
var fail18 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto13);
  op._tag = "Fail";
  return op;
})();
var hardLine = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto13);
  op._tag = "Line";
  return op;
})();
var line = /* @__PURE__ */ flatAlt(hardLine, /* @__PURE__ */ char(" "));
var lineBreak = /* @__PURE__ */ flatAlt(hardLine, empty38);
var space = /* @__PURE__ */ char(" ");
var cats = (docs) => group4(vcat(docs));
var catWithLine = /* @__PURE__ */ dual(2, (self2, that) => cat(self2, cat(line, that)));
var catWithLineBreak = /* @__PURE__ */ dual(2, (self2, that) => cat(self2, cat(lineBreak, that)));
var catWithSpace = /* @__PURE__ */ dual(2, (self2, that) => cat(self2, cat(space, that)));
var concatWith = /* @__PURE__ */ dual(2, (docs, f) => matchRight(fromIterable(docs), {
  onEmpty: () => empty38,
  onNonEmpty: (init2, last5) => reduceRight(init2, last5, (curr, acc) => f(acc, curr))
}));
var vcat = (docs) => concatWith(docs, (left3, right3) => catWithLineBreak(left3, right3));
var hsep = (docs) => concatWith(docs, (left3, right3) => catWithSpace(left3, right3));
var vsep = (docs) => concatWith(docs, (left3, right3) => catWithLine(left3, right3));
var group4 = (self2) => {
  switch (self2._tag) {
    case "FlatAlt": {
      const flattened2 = changesUponFlattening(self2.right);
      switch (flattened2._tag) {
        case "Flattened": {
          return union11(flattened2.value, self2.left);
        }
        case "AlreadyFlat": {
          return union11(self2.right, self2.left);
        }
        case "NeverFlat": {
          return self2.left;
        }
      }
    }
    case "Union": {
      return self2;
    }
    default: {
      const flattened2 = changesUponFlattening(self2);
      return isFlattened(flattened2) ? union11(flattened2.value, self2) : self2;
    }
  }
};
var column = (react) => {
  const op = Object.create(proto13);
  op._tag = "Column";
  op.react = react;
  return op;
};
var nesting = (react) => {
  const op = Object.create(proto13);
  op._tag = "Nesting";
  op.react = react;
  return op;
};
var pageWidth = (react) => {
  const op = Object.create(proto13);
  op._tag = "WithPageWidth";
  op.react = react;
  return op;
};
var nest = /* @__PURE__ */ dual(2, (self2, indent) => indent === 0 ? self2 : (() => {
  const op = Object.create(proto13);
  op._tag = "Nest";
  op.indent = indent;
  op.doc = self2;
  return op;
})());
var align = (self2) => column((position) => nesting((level) => nest(self2, position - level)));
var hang = /* @__PURE__ */ dual(2, (self2, indent) => align(nest(self2, indent)));
var indent = /* @__PURE__ */ dual(2, (self2, indent2) => hang(cat(spaces(indent2), self2), indent2));
var flatten14 = (self2) => runSync(flattenSafe(self2));
var flattenSafe = (self2) => gen2(function* () {
  switch (self2._tag) {
    case "Fail": {
      return self2;
    }
    case "Empty": {
      return self2;
    }
    case "Char": {
      return self2;
    }
    case "Text": {
      return self2;
    }
    case "Line": {
      return fail18;
    }
    case "FlatAlt": {
      return yield* flattenSafe(self2.right);
    }
    case "Cat": {
      const left3 = yield* flattenSafe(self2.left);
      const right3 = yield* flattenSafe(self2.right);
      return cat(left3, right3);
    }
    case "Nest": {
      const doc = yield* flattenSafe(self2.doc);
      return nest(doc, self2.indent);
    }
    case "Union": {
      return yield* flattenSafe(self2.left);
    }
    case "Column": {
      return column((position) => flatten14(self2.react(position)));
    }
    case "WithPageWidth": {
      return pageWidth((pageWidth2) => flatten14(self2.react(pageWidth2)));
    }
    case "Nesting": {
      return nesting((level) => flatten14(self2.react(level)));
    }
    case "Annotated": {
      const doc = yield* flattenSafe(self2.doc);
      return annotate(doc, self2.annotation);
    }
  }
});
var changesUponFlattening = (self2) => runSync(changesUponFlatteningSafe(self2));
var changesUponFlatteningSafe = (self2) => gen2(function* () {
  switch (self2._tag) {
    case "Fail":
    case "Line": {
      return neverFlat;
    }
    case "Empty":
    case "Char":
    case "Text": {
      return alreadyFlat;
    }
    case "FlatAlt": {
      const doc = yield* flattenSafe(self2.right);
      return flattened(doc);
    }
    case "Cat": {
      const left3 = yield* changesUponFlatteningSafe(self2.left);
      const right3 = yield* changesUponFlatteningSafe(self2.right);
      if (isNeverFlat(left3) || isNeverFlat(right3)) {
        return neverFlat;
      }
      if (isFlattened(left3) && isFlattened(right3)) {
        return flattened(cat(left3.value, right3.value));
      }
      if (isFlattened(left3) && isAlreadyFlat(right3)) {
        return flattened(cat(left3.value, self2.right));
      }
      if (isAlreadyFlat(left3) && isFlattened(right3)) {
        return flattened(cat(self2.left, right3.value));
      }
      if (isAlreadyFlat(left3) && isAlreadyFlat(right3)) {
        return alreadyFlat;
      }
      throw new Error("[BUG]: Doc.changesUponFlattening - unable to flatten a Cat document " + "- please open an issue at https://github.com/IMax153/contentlayer/issues/new");
    }
    case "Nest": {
      return yield* pipe(changesUponFlatteningSafe(self2.doc), map17(map26((doc) => nest(doc, self2.indent))));
    }
    case "Union": {
      return flattened(self2.left);
    }
    case "Column": {
      const doc = column((position) => runSync(flattenSafe(self2.react(position))));
      return flattened(doc);
    }
    case "WithPageWidth": {
      const doc = pageWidth((pageWidth2) => runSync(flattenSafe(self2.react(pageWidth2))));
      return flattened(doc);
    }
    case "Nesting": {
      const doc = nesting((level) => runSync(flattenSafe(self2.react(level))));
      return flattened(doc);
    }
    case "Annotated": {
      return yield* pipe(changesUponFlatteningSafe(self2.doc), map17(map26((doc) => annotate(doc, self2.annotation))));
    }
  }
});
var annotate = /* @__PURE__ */ dual(2, (self2, annotation) => {
  const op = Object.create(proto13);
  op._tag = "Annotated";
  op.doc = self2;
  op.annotation = annotation;
  return op;
});
var spaces = (n) => {
  if (n <= 0) {
    return empty38;
  }
  if (n === 1) {
    return char(" ");
  }
  return text(textSpaces(n));
};
var textSpaces = (n) => {
  let s = "";
  for (let i = 0;i < n; i++) {
    s = s += " ";
  }
  return s;
};

// node_modules/@effect/printer/dist/esm/internal/docStream.js
var DocStreamSymbolKey = "@effect/printer/DocStream";
var DocStreamTypeId = /* @__PURE__ */ Symbol.for(DocStreamSymbolKey);
var protoHash3 = {
  FailedStream: (_) => pipe(string2("@effect/printer/DocStream/FailedStream"), combine(string2(DocStreamSymbolKey))),
  EmptyStream: (_) => pipe(string2("@effect/printer/DocStream/EmptyStream"), combine(string2(DocStreamSymbolKey))),
  CharStream: (self2) => pipe(hash("@effect/printer/DocStream/CharStream"), combine(string2(DocStreamSymbolKey)), combine(string2(self2.char)), combine(hash(self2.stream))),
  TextStream: (self2) => pipe(string2("@effect/printer/DocStream/TextStream"), combine(string2(DocStreamSymbolKey)), combine(string2(self2.text)), combine(hash(self2.stream))),
  LineStream: (self2) => pipe(string2("@effect/printer/DocStream/LineStream"), combine(string2(DocStreamSymbolKey)), combine(hash(self2.stream))),
  PushAnnotationStream: (self2) => pipe(string2("@effect/printer/DocStream/PopAnnotationStream"), combine(string2(DocStreamSymbolKey)), combine(hash(self2.annotation)), combine(hash(self2.stream))),
  PopAnnotationStream: (self2) => pipe(string2("@effect/printer/DocStream/PopAnnotationStream"), combine(string2(DocStreamSymbolKey)), combine(hash(self2.stream)))
};
var protoEqual3 = {
  FailedStream: (self2, that) => isDocStream(that) && that._tag === "FailedStream",
  EmptyStream: (self2, that) => isDocStream(that) && that._tag === "EmptyStream",
  CharStream: (self2, that) => isDocStream(that) && that._tag === "CharStream" && self2.char === that.char && equals(self2.stream, that.stream),
  TextStream: (self2, that) => isDocStream(that) && that._tag === "TextStream" && self2.text === that.text && equals(self2.stream, that.stream),
  LineStream: (self2, that) => isDocStream(that) && that._tag === "LineStream" && equals(self2.stream, that.stream),
  PushAnnotationStream: (self2, that) => isDocStream(that) && that._tag === "PushAnnotationStream" && equals(self2.annotation, that.annotation) && equals(self2.stream, that.stream),
  PopAnnotationStream: (self2, that) => isDocStream(that) && that._tag === "PopAnnotationStream" && equals(self2.stream, that.stream)
};
var proto14 = {
  [DocStreamTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash3[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual3[this._tag](this, that);
  }
};
var isDocStream = (u) => typeof u === "object" && u != null && (DocStreamTypeId in u);
var isEmptyStream = (self2) => self2._tag === "EmptyStream";
var isLineStream = (self2) => self2._tag === "LineStream";
var failed = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto14);
  op._tag = "FailedStream";
  return op;
})();
var empty39 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto14);
  op._tag = "EmptyStream";
  return op;
})();
var char2 = /* @__PURE__ */ dual(2, (self2, char3) => {
  const op = Object.create(proto14);
  op._tag = "CharStream";
  op.char = char3;
  op.stream = self2;
  return op;
});
var text2 = /* @__PURE__ */ dual(2, (self2, text3) => {
  const op = Object.create(proto14);
  op._tag = "TextStream";
  op.text = text3;
  op.stream = self2;
  return op;
});
var line2 = /* @__PURE__ */ dual(2, (self2, indentation) => {
  const op = Object.create(proto14);
  op._tag = "LineStream";
  op.indentation = indentation;
  op.stream = self2;
  return op;
});
var pushAnnotation = /* @__PURE__ */ dual(2, (self2, annotation) => {
  const op = Object.create(proto14);
  op._tag = "PushAnnotationStream";
  op.annotation = annotation;
  op.stream = self2;
  return op;
});
var popAnnotation = (stream2) => {
  const op = Object.create(proto14);
  op._tag = "PopAnnotationStream";
  op.stream = stream2;
  return op;
};

// node_modules/@effect/printer/dist/esm/internal/layoutPipeline.js
var nil2 = {
  _tag: "Nil"
};
var cons2 = (indent2, document, pipeline) => ({
  _tag: "Cons",
  indent: indent2,
  document,
  pipeline
});
var undoAnnotation = (pipeline) => ({
  _tag: "UndoAnnotation",
  pipeline
});

// node_modules/@effect/printer/dist/esm/internal/pageWidth.js
var PageWidthSymbolKey = "@effect/printer/PageWidth";
var PageWidthTypeId = /* @__PURE__ */ Symbol.for(PageWidthSymbolKey);
var protoHash4 = {
  AvailablePerLine: (self2) => pipe(hash("@effect/printer/PageWidth/AvailablePerLine"), combine(hash(PageWidthSymbolKey)), combine(hash(self2.lineWidth)), combine(hash(self2.ribbonFraction))),
  Unbounded: (_) => pipe(hash("@effect/printer/PageWidth/Unbounded"), combine(hash(PageWidthSymbolKey)))
};
var protoEqual4 = {
  AvailablePerLine: (self2, that) => isPageWidth(that) && that._tag === "AvailablePerLine" && self2.lineWidth === that.lineWidth && self2.ribbonFraction === that.ribbonFraction,
  Unbounded: (self2, that) => isPageWidth(that) && that._tag === "Unbounded"
};
var proto15 = {
  [PageWidthTypeId]: PageWidthTypeId,
  [symbol]() {
    return cached(this, protoHash4[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual4[this._tag](this, that);
  }
};
var isPageWidth = (u) => typeof u === "object" && u != null && (PageWidthTypeId in u);
var availablePerLine = (lineWidth, ribbonFraction) => {
  const op = Object.create(proto15);
  op._tag = "AvailablePerLine";
  op.lineWidth = lineWidth;
  op.ribbonFraction = ribbonFraction;
  return op;
};
var unbounded8 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto15);
  op._tag = "Unbounded";
  return op;
})();
var defaultPageWidth = /* @__PURE__ */ availablePerLine(80, 1);
var remainingWidth = (pageWidth2, ribbonFraction, indentation, currentColumn) => {
  const columnsLeftInLine = pageWidth2 - currentColumn;
  const ribbonWidth = Math.max(0, Math.min(pageWidth2, Math.floor(pageWidth2 * ribbonFraction)));
  const columnsLeftInRibbon = indentation + ribbonWidth - currentColumn;
  return Math.min(columnsLeftInLine, columnsLeftInRibbon);
};

// node_modules/@effect/printer/dist/esm/internal/layout.js
var options = (pageWidth2) => ({
  pageWidth: pageWidth2
});
var wadlerLeijen = /* @__PURE__ */ dual(3, (self2, fits, options2) => runSync(wadlerLeijenSafe(cons2(0, self2, nil2), 0, 0, fits, options2)));
var wadlerLeijenSafe = (self2, nestingLevel, currentColumn, fits, options2) => {
  const best = (self3, nl, cc) => gen2(function* () {
    switch (self3._tag) {
      case "Nil": {
        return empty39;
      }
      case "Cons": {
        switch (self3.document._tag) {
          case "Fail": {
            return failed;
          }
          case "Empty": {
            return yield* best(self3.pipeline, nl, cc);
          }
          case "Char": {
            const stream2 = yield* best(self3.pipeline, nl, cc + 1);
            return char2(stream2, self3.document.char);
          }
          case "Text": {
            const length4 = self3.document.text.length;
            const stream2 = yield* best(self3.pipeline, nl, cc + length4);
            return text2(stream2, self3.document.text);
          }
          case "Line": {
            const stream2 = yield* best(self3.pipeline, self3.indent, self3.indent);
            const nextIndent = isEmptyStream(stream2) || isLineStream(stream2) ? 0 : self3.indent;
            return line2(stream2, nextIndent);
          }
          case "FlatAlt": {
            const next4 = cons2(self3.indent, self3.document.left, self3.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "Cat": {
            const inner = cons2(self3.indent, self3.document.right, self3.pipeline);
            const outer = cons2(self3.indent, self3.document.left, inner);
            return yield* best(outer, nl, cc);
          }
          case "Nest": {
            const indent2 = self3.indent + self3.document.indent;
            const next4 = cons2(indent2, self3.document.doc, self3.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "Union": {
            const leftPipeline = cons2(self3.indent, self3.document.left, self3.pipeline);
            const rightPipeline = cons2(self3.indent, self3.document.right, self3.pipeline);
            const left3 = best(leftPipeline, nl, cc);
            const right3 = best(rightPipeline, nl, cc);
            return selectNicer(fits, nl, cc, left3, right3);
          }
          case "Column": {
            const doc = self3.document.react(cc);
            const next4 = cons2(self3.indent, doc, self3.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "WithPageWidth": {
            const doc = self3.document.react(options2.pageWidth);
            const next4 = cons2(self3.indent, doc, self3.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "Nesting": {
            const doc = self3.document.react(self3.indent);
            const next4 = cons2(self3.indent, doc, self3.pipeline);
            return yield* best(next4, nl, cc);
          }
          case "Annotated": {
            const undo = undoAnnotation(self3.pipeline);
            const next4 = cons2(self3.indent, self3.document.doc, undo);
            const stream2 = yield* best(next4, nl, cc);
            return pushAnnotation(stream2, self3.document.annotation);
          }
        }
      }
      case "UndoAnnotation": {
        const stream2 = yield* best(self3.pipeline, nestingLevel, currentColumn);
        return popAnnotation(stream2);
      }
    }
  });
  return best(self2, nestingLevel, currentColumn);
};
var selectNicer = (fits, lineIndent, currentColumn, left3, right3) => {
  const leftStream = runSync(left3);
  let rightStream = undefined;
  return fits(leftStream, lineIndent, currentColumn, () => rightStream ?? (rightStream = runSync(right3), rightStream)) ? leftStream : rightStream ?? runSync(right3);
};
var compact2 = (self2) => runSync(compactSafe(of3(self2), 0));
var compactSafe = (docs, i) => gen2(function* () {
  if (isNil(docs)) {
    return empty39;
  }
  const head6 = docs.head;
  const tail2 = docs.tail;
  switch (head6._tag) {
    case "Fail": {
      return failed;
    }
    case "Empty": {
      return yield* compactSafe(tail2, i);
    }
    case "Char": {
      const stream2 = yield* compactSafe(tail2, i + 1);
      return char2(stream2, head6.char);
    }
    case "Text": {
      const stream2 = yield* compactSafe(tail2, i + head6.text.length);
      return text2(stream2, head6.text);
    }
    case "Line": {
      const stream2 = yield* compactSafe(tail2, 0);
      return line2(stream2, 0);
    }
    case "FlatAlt": {
      return yield* compactSafe(cons(head6.left, tail2), i);
    }
    case "Cat": {
      const list = cons(head6.left, cons(head6.right, tail2));
      return yield* compactSafe(list, i);
    }
    case "Nest": {
      return yield* compactSafe(cons(head6.doc, tail2), i);
    }
    case "Union": {
      return yield* compactSafe(cons(head6.right, tail2), i);
    }
    case "Column": {
      return yield* compactSafe(cons(head6.react(i), tail2), i);
    }
    case "WithPageWidth": {
      return yield* compactSafe(cons(head6.react(unbounded8), tail2), i);
    }
    case "Nesting": {
      return yield* compactSafe(cons(head6.react(0), tail2), i);
    }
    case "Annotated": {
      return yield* compactSafe(cons(head6.doc, tail2), i);
    }
  }
});
var pretty4 = /* @__PURE__ */ dual(2, (self2, options2) => {
  const width = options2.pageWidth;
  if (width._tag === "AvailablePerLine") {
    return wadlerLeijen(self2, (stream2, indentation, currentColumn) => {
      const remainingWidth2 = remainingWidth(width.lineWidth, width.ribbonFraction, indentation, currentColumn);
      return fitsPretty(stream2, remainingWidth2);
    }, options2);
  }
  return unbounded9(self2);
});
var fitsPretty = (self2, width) => {
  let w = width;
  let stream2 = self2;
  while (w >= 0) {
    switch (stream2._tag) {
      case "FailedStream": {
        return false;
      }
      case "EmptyStream": {
        return true;
      }
      case "CharStream": {
        w = w - 1;
        stream2 = stream2.stream;
        break;
      }
      case "TextStream": {
        w = w - stream2.text.length;
        stream2 = stream2.stream;
        break;
      }
      case "LineStream": {
        return true;
      }
      case "PushAnnotationStream": {
        stream2 = stream2.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream2 = stream2.stream;
        break;
      }
    }
  }
  return false;
};
var smart = /* @__PURE__ */ dual(2, (self2, options2) => {
  const width = options2.pageWidth;
  if (width._tag === "AvailablePerLine") {
    return wadlerLeijen(self2, fitsSmart(width.lineWidth, width.ribbonFraction), options2);
  }
  return unbounded9(self2);
});
var fitsSmart = (pageWidth2, ribbonFraction) => {
  return (stream2, indentation, currentColumn, comparator) => {
    const availableWidth = remainingWidth(pageWidth2, ribbonFraction, indentation, currentColumn);
    return fitsSmartLoop(stream2, comparator, pageWidth2, currentColumn, availableWidth);
  };
};
var fitsSmartLoop = (self2, comparator, pageWidth2, currentColumn, availableWidth) => {
  let minNestingLevel;
  let stream2 = self2;
  let w = availableWidth;
  while (w >= 0) {
    switch (stream2._tag) {
      case "FailedStream": {
        return false;
      }
      case "EmptyStream": {
        return true;
      }
      case "CharStream": {
        w = w - 1;
        stream2 = stream2.stream;
        break;
      }
      case "TextStream": {
        w = w - stream2.text.length;
        stream2 = stream2.stream;
        break;
      }
      case "LineStream": {
        if (!minNestingLevel) {
          minNestingLevel = match2(getInitialIndentation(comparator()), {
            onNone: () => currentColumn,
            onSome: (value) => Math.min(value, currentColumn)
          });
        }
        if (minNestingLevel < stream2.indentation) {
          return false;
        }
        w = pageWidth2 - stream2.indentation;
        stream2 = stream2.stream;
        break;
      }
      case "PushAnnotationStream": {
        stream2 = stream2.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream2 = stream2.stream;
        break;
      }
    }
  }
  return false;
};
var getInitialIndentation = (self2) => {
  let stream2 = self2;
  while (stream2._tag === "LineStream" || stream2._tag === "PushAnnotationStream" || stream2._tag === "PopAnnotationStream") {
    if (stream2._tag === "LineStream") {
      return some2(stream2.indentation);
    }
    stream2 = stream2.stream;
  }
  return none2();
};
var unbounded9 = (self2) => wadlerLeijen(self2, (stream2) => !failsOnFirstLine(stream2), {
  pageWidth: unbounded8
});
var failsOnFirstLine = (self2) => {
  let stream2 = self2;
  while (true) {
    switch (stream2._tag) {
      case "FailedStream": {
        return true;
      }
      case "EmptyStream": {
        return false;
      }
      case "CharStream": {
        stream2 = stream2.stream;
        break;
      }
      case "TextStream": {
        stream2 = stream2.stream;
        break;
      }
      case "LineStream": {
        return false;
      }
      case "PushAnnotationStream": {
        stream2 = stream2.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream2 = stream2.stream;
        break;
      }
    }
  }
  throw new Error("bug");
};

// node_modules/@effect/printer/dist/esm/Doc.js
var char3 = char;
var text3 = text;
var empty40 = empty38;
var hardLine2 = hardLine;
var space2 = space;
var cat2 = cat;
var cats2 = cats;
var hsep2 = hsep;
var vsep2 = vsep;
var nest2 = nest;
var align2 = align;
var indent2 = indent;
var annotate2 = annotate;

// node_modules/@effect/printer-ansi/dist/esm/internal/ansiDoc.js
var beep2 = /* @__PURE__ */ annotate2(empty40, beep);
var cursorTo2 = (column2, row) => annotate2(empty40, cursorTo(column2, row));
var cursorMove2 = (column2, row) => annotate2(empty40, cursorMove(column2, row));
var cursorDown2 = (lines = 1) => annotate2(empty40, cursorDown(lines));
var cursorLeft2 = /* @__PURE__ */ annotate2(empty40, cursorLeft);
var cursorSavePosition2 = /* @__PURE__ */ annotate2(empty40, cursorSavePosition);
var cursorRestorePosition2 = /* @__PURE__ */ annotate2(empty40, cursorRestorePosition);
var cursorHide2 = /* @__PURE__ */ annotate2(empty40, cursorHide);
var cursorShow2 = /* @__PURE__ */ annotate2(empty40, cursorShow);
var eraseLines2 = (rows) => annotate2(empty40, eraseLines(rows));
var eraseLine2 = /* @__PURE__ */ annotate2(empty40, eraseLine);

// node_modules/@effect/printer/dist/esm/PageWidth.js
var defaultPageWidth2 = defaultPageWidth;

// node_modules/@effect/printer/dist/esm/Layout.js
var options2 = options;
var compact3 = compact2;
var pretty5 = pretty4;
var smart2 = smart;

// node_modules/@effect/printer-ansi/dist/esm/internal/ansiRender.js
var render3 = /* @__PURE__ */ dual(2, (self2, config2) => {
  switch (config2.style) {
    case "compact": {
      return renderStream2(compact3(self2));
    }
    case "pretty": {
      const width2 = Object.assign({}, defaultPageWidth2, config2.options);
      return renderStream2(pretty5(self2, options2(width2)));
    }
    case "smart": {
      const width2 = Object.assign({}, defaultPageWidth2, config2.options);
      return renderStream2(smart2(self2, options2(width2)));
    }
  }
});
var renderStream2 = (self2) => runSync(renderSafe(self2, of3(none10)));
var unsafePeek = (stack) => {
  if (isNil(stack)) {
    throw new Error("BUG: AnsiRender.unsafePeek - peeked at an empty stack" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
  }
  return stack.head;
};
var unsafePop = (stack) => {
  if (isNil(stack)) {
    throw new Error("BUG: AnsiRender.unsafePop - popped from an empty stack" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
  }
  return [stack.head, stack.tail];
};
var renderSafe = (self2, stack) => {
  switch (self2._tag) {
    case "FailedStream": {
      return dieMessage2("BUG: AnsiRender.renderSafe - attempted to render a failed doc stream" + " - please report an issue at https://github.com/Effect-TS/printer/issues");
    }
    case "EmptyStream": {
      return succeed8("");
    }
    case "CharStream": {
      return map17(suspend3(() => renderSafe(self2.stream, stack)), (rest) => self2.char + rest);
    }
    case "TextStream": {
      return map17(suspend3(() => renderSafe(self2.stream, stack)), (rest) => self2.text + rest);
    }
    case "LineStream": {
      let indent3 = `
`;
      for (let i = 0;i < self2.indentation; i++) {
        indent3 = indent3 += " ";
      }
      return map17(suspend3(() => renderSafe(self2.stream, stack)), (rest) => indent3 + rest);
    }
    case "PushAnnotationStream": {
      const currentStyle = unsafePeek(stack);
      const nextStyle = combine14(self2.annotation, currentStyle);
      return map17(suspend3(() => renderSafe(self2.stream, cons(self2.annotation, stack))), (rest) => stringify(nextStyle) + rest);
    }
    case "PopAnnotationStream": {
      const [, styles] = unsafePop(stack);
      const nextStyle = unsafePeek(styles);
      return map17(suspend3(() => renderSafe(self2.stream, styles)), (rest) => stringify(nextStyle) + rest);
    }
  }
};

// node_modules/@effect/printer-ansi/dist/esm/AnsiDoc.js
var beep3 = beep2;
var cursorTo3 = cursorTo2;
var cursorMove3 = cursorMove2;
var cursorDown3 = cursorDown2;
var cursorLeft3 = cursorLeft2;
var cursorSavePosition3 = cursorSavePosition2;
var cursorRestorePosition3 = cursorRestorePosition2;
var cursorHide3 = cursorHide2;
var cursorShow3 = cursorShow2;
var eraseLines3 = eraseLines2;
var eraseLine3 = eraseLine2;
var render4 = render3;

// node_modules/@effect/printer/dist/esm/internal/optimize.js
var optimize2 = /* @__PURE__ */ dual(2, (self2, depth) => runSync(optimizeSafe(self2, depth)));
var optimizeSafe = (self2, depth) => {
  const optimize3 = (self3) => gen2(function* () {
    switch (self3._tag) {
      case "Fail":
      case "Empty":
      case "Char":
      case "Text":
      case "Line": {
        return self3;
      }
      case "FlatAlt": {
        const left3 = yield* optimize3(self3.left);
        const right3 = yield* optimize3(self3.right);
        return flatAlt(left3, right3);
      }
      case "Cat": {
        if (isEmpty15(self3.left)) {
          return yield* optimize3(self3.right);
        }
        if (isEmpty15(self3.right)) {
          return yield* optimize3(self3.left);
        }
        if (isChar(self3.left) && isChar(self3.right)) {
          return text(self3.left.char + self3.right.char);
        }
        if (isText(self3.left) && isChar(self3.right)) {
          return text(self3.left.text + self3.right.char);
        }
        if (isChar(self3.left) && isText(self3.right)) {
          return text(self3.left.char + self3.right.text);
        }
        if (isText(self3.left) && isText(self3.right)) {
          return text(self3.left.text + self3.right.text);
        }
        if (isChar(self3.left) && isCat(self3.right) && isChar(self3.right.left) || isChar(self3.left) && isCat(self3.right) && isText(self3.right.left) || isText(self3.left) && isCat(self3.right) && isChar(self3.right.left) || isText(self3.left) && isCat(self3.right) && isText(self3.right.left)) {
          const inner = yield* optimize3(cat(self3.left, self3.right.left));
          return yield* optimize3(cat(inner, self3.right.right));
        }
        if (isCat(self3.left) && isChar(self3.left.right) || isCat(self3.left) && isText(self3.left.right)) {
          const inner = yield* optimize3(cat(self3.left.right, self3.right));
          return yield* optimize3(cat(self3.left.left, inner));
        }
        const left3 = yield* optimize3(self3.left);
        const right3 = yield* optimize3(self3.right);
        return cat(left3, right3);
      }
      case "Nest": {
        if (self3.indent === 0) {
          return yield* optimize3(self3.doc);
        }
        if (isEmpty15(self3.doc) || isChar(self3.doc) || isText(self3.doc)) {
          return self3.doc;
        }
        if (isNest(self3.doc)) {
          const indent3 = self3.indent + self3.doc.indent;
          return yield* optimize3(nest(self3.doc.doc, indent3));
        }
        return nest(yield* optimize3(self3.doc), self3.indent);
      }
      case "Union": {
        const left3 = yield* optimize3(self3.left);
        const right3 = yield* optimize3(self3.right);
        return union11(left3, right3);
      }
      case "Column": {
        return depth._tag === "Shallow" ? self3 : column((position) => runSync(optimizeSafe(self3.react(position), depth)));
      }
      case "WithPageWidth": {
        return depth._tag === "Shallow" ? self3 : pageWidth((pageWidth3) => runSync(optimizeSafe(self3.react(pageWidth3), depth)));
      }
      case "Nesting": {
        return depth._tag === "Shallow" ? self3 : nesting((level) => runSync(optimizeSafe(self3.react(level), depth)));
      }
      case "Annotated": {
        return annotate(yield* optimize3(self3.doc), self3.annotation);
      }
    }
  });
  return optimize3(self2);
};

// node_modules/@effect/printer/dist/esm/Optimize.js
var Deep = {
  _tag: "Deep"
};
var optimize3 = optimize2;

// node_modules/@effect/printer-ansi/dist/esm/Color.js
var red4 = red;
var magenta3 = magenta;
var cyan3 = cyan;
var white4 = white;

// node_modules/@effect/cli/dist/esm/internal/helpDoc/span.js
var text4 = (value) => ({
  _tag: "Text",
  value
});
var empty41 = /* @__PURE__ */ text4("");
var space3 = /* @__PURE__ */ text4(" ");
var code = (value) => highlight(value, white4);
var error3 = (value) => highlight(value, red4);
var highlight = (value, color3) => ({
  _tag: "Highlight",
  value: typeof value === "string" ? text4(value) : value,
  color: color3
});
var strong = (value) => ({
  _tag: "Strong",
  value: typeof value === "string" ? text4(value) : value
});
var uri = (value) => ({
  _tag: "URI",
  value
});
var weak = (value) => ({
  _tag: "Weak",
  value: typeof value === "string" ? text4(value) : value
});
var isSequence = (self2) => self2._tag === "Sequence";
var isStrong = (self2) => self2._tag === "Strong";
var isText3 = (self2) => self2._tag === "Text";
var isUri = (self2) => self2._tag === "URI";
var isWeak = (self2) => self2._tag === "Weak";
var concat4 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: "Sequence",
  left: self2,
  right: that
}));
var getText = (self2) => {
  switch (self2._tag) {
    case "Text":
    case "URI": {
      return self2.value;
    }
    case "Highlight":
    case "Weak":
    case "Strong": {
      return getText(self2.value);
    }
    case "Sequence": {
      return getText(self2.left) + getText(self2.right);
    }
  }
};
var spans = (spans2) => {
  const elements = fromIterable(spans2);
  if (isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(concat4, elements[0]);
  }
  return empty41;
};
var isEmpty17 = (self2) => size16(self2) === 0;
var size16 = (self2) => {
  switch (self2._tag) {
    case "Text":
    case "URI": {
      return self2.value.length;
    }
    case "Highlight":
    case "Strong":
    case "Weak": {
      return size16(self2.value);
    }
    case "Sequence": {
      return size16(self2.left) + size16(self2.right);
    }
  }
};
var toAnsiDoc = (self2) => {
  switch (self2._tag) {
    case "Highlight": {
      return annotate2(toAnsiDoc(self2.value), color2(self2.color));
    }
    case "Sequence": {
      return cat2(toAnsiDoc(self2.left), toAnsiDoc(self2.right));
    }
    case "Strong": {
      return annotate2(toAnsiDoc(self2.value), bold2);
    }
    case "Text": {
      return text3(self2.value);
    }
    case "URI": {
      return annotate2(text3(self2.value), underlined2);
    }
    case "Weak": {
      return annotate2(toAnsiDoc(self2.value), black3);
    }
  }
};

// node_modules/@effect/cli/dist/esm/internal/helpDoc.js
var isEmpty18 = (helpDoc) => helpDoc._tag === "Empty";
var isHeader = (helpDoc) => helpDoc._tag === "Header";
var isParagraph = (helpDoc) => helpDoc._tag === "Paragraph";
var isDescriptionList = (helpDoc) => helpDoc._tag === "DescriptionList";
var empty42 = {
  _tag: "Empty"
};
var sequence = /* @__PURE__ */ dual(2, (self2, that) => {
  if (isEmpty18(self2)) {
    return that;
  }
  if (isEmpty18(that)) {
    return self2;
  }
  return {
    _tag: "Sequence",
    left: self2,
    right: that
  };
});
var blocks = (helpDocs) => {
  const elements = fromIterable(helpDocs);
  if (isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(sequence, elements[0]);
  }
  return empty42;
};
var getSpan = (self2) => isHeader(self2) || isParagraph(self2) ? self2.value : empty41;
var descriptionList = (definitions) => ({
  _tag: "DescriptionList",
  definitions
});
var enumeration = (elements) => ({
  _tag: "Enumeration",
  elements
});
var h1 = (value) => ({
  _tag: "Header",
  value: typeof value === "string" ? text4(value) : value,
  level: 1
});
var p = (value) => ({
  _tag: "Paragraph",
  value: typeof value === "string" ? text4(value) : value
});
var mapDescriptionList = /* @__PURE__ */ dual(2, (self2, f) => isDescriptionList(self2) ? descriptionList(map5(self2.definitions, ([span3, helpDoc]) => f(span3, helpDoc))) : self2);
var toAnsiDoc2 = (self2) => optimize3(toAnsiDocInternal(self2), Deep);
var toAnsiText = (self2) => render4(toAnsiDoc2(self2), {
  style: "pretty"
});
var toAnsiDocInternal = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty40;
    }
    case "Header": {
      return pipe(annotate2(toAnsiDoc(self2.value), bold2), cat2(hardLine2));
    }
    case "Paragraph": {
      return pipe(toAnsiDoc(self2.value), cat2(hardLine2));
    }
    case "DescriptionList": {
      const definitions = self2.definitions.map(([span3, doc]) => cats2([annotate2(toAnsiDoc(span3), bold2), empty40, indent2(toAnsiDocInternal(doc), 2)]));
      return vsep2(definitions);
    }
    case "Enumeration": {
      const elements = self2.elements.map((doc) => cat2(text3("- "), toAnsiDocInternal(doc)));
      return indent2(vsep2(elements), 2);
    }
    case "Sequence": {
      return vsep2([toAnsiDocInternal(self2.left), toAnsiDocInternal(self2.right)]);
    }
  }
};

// node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => new WeakMap);
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto16 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make61 = (value) => {
  const redacted = Object.create(proto16);
  redactedRegistry.set(redacted, value);
  return redacted;
};

// node_modules/effect/dist/esm/Redacted.js
var make62 = make61;

// node_modules/effect/dist/esm/BigDecimal.js
var TypeId21 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId21]: TypeId21,
  [symbol]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
  },
  [symbol2](that) {
    return isBigDecimal(that) && equals4(this, that);
  },
  toString() {
    return `BigDecimal(${format4(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u) => hasProperty(u, TypeId21);
var make63 = (value2, scale) => {
  const o = Object.create(BigDecimalProto);
  o.value = value2;
  o.scale = scale;
  return o;
};
var unsafeMakeNormalized = (value2, scale) => {
  if (value2 !== bigint04 && value2 % bigint10 === bigint04) {
    throw new RangeError("Value must be normalized");
  }
  const o = make63(value2, scale);
  o.normalized = o;
  return o;
};
var bigint04 = /* @__PURE__ */ BigInt(0);
var bigint10 = /* @__PURE__ */ BigInt(10);
var zero2 = /* @__PURE__ */ unsafeMakeNormalized(bigint04, 0);
var normalize = (self2) => {
  if (self2.normalized === undefined) {
    if (self2.value === bigint04) {
      self2.normalized = zero2;
    } else {
      const digits = `${self2.value}`;
      let trail = 0;
      for (let i = digits.length - 1;i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self2.normalized = self2;
      }
      const value2 = BigInt(digits.substring(0, digits.length - trail));
      const scale = self2.scale - trail;
      self2.normalized = unsafeMakeNormalized(value2, scale);
    }
  }
  return self2.normalized;
};
var scale = /* @__PURE__ */ dual(2, (self2, scale2) => {
  if (scale2 > self2.scale) {
    return make63(self2.value * bigint10 ** BigInt(scale2 - self2.scale), scale2);
  }
  if (scale2 < self2.scale) {
    return make63(self2.value / bigint10 ** BigInt(self2.scale - scale2), scale2);
  }
  return self2;
});
var abs = (n) => n.value < bigint04 ? make63(-n.value, n.scale) : n;
var Equivalence4 = /* @__PURE__ */ make((self2, that) => {
  if (self2.scale > that.scale) {
    return scale(that, self2.scale).value === self2.value;
  }
  if (self2.scale < that.scale) {
    return scale(self2, that.scale).value === that.value;
  }
  return self2.value === that.value;
});
var equals4 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence4(self2, that));
var format4 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative = normalized.value < bigint04;
  const absolute = negative ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before2;
  let after3;
  if (normalized.scale >= absolute.length) {
    before2 = "0";
    after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location2 = absolute.length - normalized.scale;
    if (location2 > absolute.length) {
      const zeros = location2 - absolute.length;
      before2 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location2);
      before2 = absolute.slice(0, location2);
    }
  }
  const complete4 = after3 === "" ? before2 : `${before2}.${after3}`;
  return negative ? `-${complete4}` : complete4;
};
var toExponential = (n) => {
  if (isZero2(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head6 = digits.slice(0, 1);
  const tail2 = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head6}`;
  if (tail2 !== "") {
    output += `.${tail2}`;
  }
  const exp = tail2.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
var isZero2 = (n) => n.value === bigint04;
var isNegative = (n) => n.value < bigint04;

// node_modules/effect/dist/esm/BigInt.js
var fromString = (s) => {
  try {
    return s.trim() === "" ? none2() : some2(BigInt(s));
  } catch {
    return none2();
  }
};

// node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = /* @__PURE__ */ Symbol.for(SecretSymbolKey);
var SecretProto = {
  ...proto16,
  [SecretTypeId]: SecretTypeId
};
var make64 = (bytes) => {
  const secret = Object.create(SecretProto);
  Object.defineProperty(secret, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret, "raw", {
    enumerable: false,
    value: bytes
  });
  redactedRegistry.set(secret, bytes.map((byte) => String.fromCharCode(byte)).join(""));
  return secret;
};
var fromString2 = (text5) => {
  return make64(text5.split("").map((char4) => char4.charCodeAt(0)));
};

// node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  _A: (_) => _
};
var proto17 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var boolean3 = (name) => {
  const config2 = primitive("a boolean property", (text5) => {
    switch (text5) {
      case "true":
      case "yes":
      case "on":
      case "1": {
        return right2(true);
      }
      case "false":
      case "no":
      case "off":
      case "0": {
        return right2(false);
      }
      default: {
        const error4 = InvalidData([], `Expected a boolean value but received ${text5}`);
        return left2(error4);
      }
    }
  });
  return name === undefined ? config2 : nested2(config2, name);
};
var number4 = (name) => {
  const config2 = primitive("a number property", (text5) => {
    const result = Number(text5);
    if (Number.isNaN(result)) {
      return left2(InvalidData([], `Expected a number value but received ${text5}`));
    }
    return right2(result);
  });
  return name === undefined ? config2 : nested2(config2, name);
};
var integer = (name) => {
  const config2 = primitive("an integer property", (text5) => {
    const result = Number(text5);
    if (!Number.isInteger(result)) {
      return left2(InvalidData([], `Expected an integer value but received ${text5}`));
    }
    return right2(result);
  });
  return name === undefined ? config2 : nested2(config2, name);
};
var duration2 = (name) => {
  const config2 = mapOrFail(string6(), (value2) => {
    const duration3 = decodeUnknown(value2);
    return fromOption2(duration3, () => InvalidData([], `Expected a duration but received ${value2}`));
  });
  return name === undefined ? config2 : nested2(config2, name);
};
var map29 = /* @__PURE__ */ dual(2, (self2, f) => mapOrFail(self2, (a) => right2(f(a))));
var mapOrFail = /* @__PURE__ */ dual(2, (self2, f) => {
  const mapOrFail2 = Object.create(proto17);
  mapOrFail2._tag = OP_MAP_OR_FAIL;
  mapOrFail2.original = self2;
  mapOrFail2.mapOrFail = f;
  return mapOrFail2;
});
var nested2 = /* @__PURE__ */ dual(2, (self2, name) => {
  const nested3 = Object.create(proto17);
  nested3._tag = OP_NESTED;
  nested3.name = name;
  nested3.config = self2;
  return nested3;
});
var orElseIf = /* @__PURE__ */ dual(2, (self2, options3) => {
  const fallback = Object.create(proto17);
  fallback._tag = OP_FALLBACK;
  fallback.first = self2;
  fallback.second = suspend11(options3.orElse);
  fallback.condition = options3.if;
  return fallback;
});
var option3 = (self2) => {
  return pipe(self2, map29(some2), orElseIf({
    orElse: () => succeed18(none2()),
    if: isMissingDataOnly2
  }));
};
var primitive = (description, parse6) => {
  const primitive2 = Object.create(proto17);
  primitive2._tag = OP_PRIMITIVE;
  primitive2.description = description;
  primitive2.parse = parse6;
  return primitive2;
};
var string6 = (name) => {
  const config2 = primitive("a text property", right2);
  return name === undefined ? config2 : nested2(config2, name);
};
var all7 = (arg) => {
  if (Array.isArray(arg)) {
    return tuple5(arg);
  } else if (Symbol.iterator in arg) {
    return tuple5([...arg]);
  }
  return struct6(arg);
};
var struct6 = (r) => {
  const entries2 = Object.entries(r);
  let result = pipe(entries2[0][1], map29((value2) => ({
    [entries2[0][0]]: value2
  })));
  if (entries2.length === 1) {
    return result;
  }
  const rest = entries2.slice(1);
  for (const [key, config2] of rest) {
    result = pipe(result, zipWith13(config2, (record2, value2) => ({
      ...record2,
      [key]: value2
    })));
  }
  return result;
};
var succeed18 = (value2) => {
  const constant3 = Object.create(proto17);
  constant3._tag = OP_CONSTANT;
  constant3.value = value2;
  constant3.parse = () => right2(value2);
  return constant3;
};
var suspend11 = (config2) => {
  const lazy = Object.create(proto17);
  lazy._tag = OP_LAZY;
  lazy.config = config2;
  return lazy;
};
var isConfig = (u) => hasProperty(u, ConfigTypeId);
var tuple5 = (tuple6) => {
  if (tuple6.length === 0) {
    return succeed18([]);
  }
  if (tuple6.length === 1) {
    return map29(tuple6[0], (x) => [x]);
  }
  let result = map29(tuple6[0], (x) => [x]);
  for (let i = 1;i < tuple6.length; i++) {
    const config2 = tuple6[i];
    result = pipe(result, zipWith13(config2, (tuple7, value2) => [...tuple7, value2]));
  }
  return result;
};
var withDefault = /* @__PURE__ */ dual(2, (self2, def) => orElseIf(self2, {
  orElse: () => succeed18(def),
  if: isMissingDataOnly2
}));
var withDescription = /* @__PURE__ */ dual(2, (self2, description) => {
  const described = Object.create(proto17);
  described._tag = OP_DESCRIBED;
  described.config = self2;
  described.description = description;
  return described;
});
var zipWith13 = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const zipWith14 = Object.create(proto17);
  zipWith14._tag = OP_ZIP_WITH;
  zipWith14.left = self2;
  zipWith14.right = that;
  zipWith14.zip = f;
  return zipWith14;
});

// node_modules/effect/dist/esm/Config.js
var all8 = all7;
var boolean4 = boolean3;
var number5 = number4;
var integer2 = integer;
var duration3 = duration2;
var isConfig2 = isConfig;
var map30 = map29;
var option4 = option3;
var string7 = string6;
var withDefault2 = withDefault;
var withDescription2 = withDescription;
// node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");
var MinLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinLength");

// node_modules/effect/dist/esm/Struct.js
var pick2 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys6) => {
  const out = {};
  for (const k of keys6) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys6) => {
  const out = {
    ...s
  };
  for (const k of keys6) {
    delete out[k];
  }
  return out;
});

// node_modules/effect/dist/esm/Schema.js
var TypeId22 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make66(ast) {
  return class SchemaClass {
    [TypeId22] = variance10;
    static ast = ast;
    static annotations(annotations2) {
      return make66(mergeSchemaAnnotations(this.ast, annotations2));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId22] = variance10;
  };
}
var variance10 = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations2) => {
  if (!annotations2) {
    return {};
  }
  const out = {
    ...annotations2
  };
  for (const key in builtInAnnotations) {
    if (key in annotations2) {
      const id2 = builtInAnnotations[key];
      out[id2] = annotations2[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
function asSchema(schema) {
  return schema;
}
var format6 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make66(encodedAST(schema.ast));
var typeSchema = (schema) => make66(typeAST(schema.ast));
var encodeUnknown2 = (schema, options3) => {
  const encodeUnknown3 = encodeUnknown(schema, options3);
  return (u, overrideOptions) => mapError3(encodeUnknown3(u, overrideOptions), parseError);
};
var encode4 = encodeUnknown2;
var decodeUnknown3 = (schema, options3) => {
  const decodeUnknown4 = decodeUnknown2(schema, options3);
  return (u, overrideOptions) => mapError3(decodeUnknown4(u, overrideOptions), parseError);
};
var decode6 = decodeUnknown3;
var isSchema = (u) => hasProperty(u, TypeId22) && isObject(u[TypeId22]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make66(ast) {
    static annotations(annotations2) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var declareConstructor = (typeParameters, options3, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options3.decode(...typeParameters2.map(make66)), (...typeParameters2) => options3.encode(...typeParameters2.map(make66)), toASTAnnotations(annotations2)));
var declarePrimitive = (is2, annotations2) => {
  const decodeUnknown4 = () => (input, _, ast) => is2(input) ? succeed9(input) : fail9(new Type2(ast, input));
  const encodeUnknown3 = decodeUnknown4;
  return makeDeclareClass([], new Declaration([], decodeUnknown4, encodeUnknown3, toASTAnnotations(annotations2)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make66(ast) {
    static annotations(annotations2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static typeParameters = [...typeParameters];
  };
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options3 = arguments[1];
    const annotations3 = arguments[2];
    return declareConstructor(typeParameters, options3, annotations3);
  }
  const is2 = arguments[0];
  const annotations2 = arguments[1];
  return declarePrimitive(is2, annotations2);
};
class Void extends (/* @__PURE__ */ make66(voidKeyword)) {
}
class Never extends (/* @__PURE__ */ make66(neverKeyword)) {
}

class Unknown extends (/* @__PURE__ */ make66(unknownKeyword)) {
}
class BigIntFromSelf extends (/* @__PURE__ */ make66(bigIntKeyword)) {
}
class String$ extends (/* @__PURE__ */ make66(stringKeyword)) {
}

class Number$ extends (/* @__PURE__ */ make66(numberKeyword)) {
}

class Boolean$ extends (/* @__PURE__ */ make66(booleanKeyword)) {
}
var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make66(ast) {
    static annotations(annotations2) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static members = [...members];
  };
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class TupleTypeClass extends make66(ast) {
    static annotations(annotations2) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static elements = [...elements];
    static rest = [...rest];
  };
}
function makeArrayClass(value3, ast) {
  return class ArrayClass extends makeTupleTypeClass([], [value3], ast) {
    static annotations(annotations2) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static value = value3;
  };
}
var Array$ = (value3) => makeArrayClass(value3);
function makeNonEmptyArrayClass(value3, ast) {
  return class NonEmptyArrayClass extends makeTupleTypeClass([value3], [value3], ast) {
    static annotations(annotations2) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static value = value3;
  };
}
var NonEmptyArray = (value3) => makeNonEmptyArrayClass(value3);
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';

class PropertySignatureDeclaration extends OptionalType {
  isReadonly;
  defaultValue;
  _tag = "PropertySignatureDeclaration";
  constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
    super(type, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
}
class ToPropertySignature extends OptionalType {
  isReadonly;
  defaultValue;
  constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
    super(type, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
}
var formatPropertyKey2 = (p2) => {
  if (p2 === undefined) {
    return "never";
  }
  if (isString(p2)) {
    return JSON.stringify(p2);
  }
  return String(p2);
};

class PropertySignatureTransformation2 {
  from;
  to;
  decode;
  encode;
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode7, encode5) {
    this.from = from;
    this.to = to;
    this.decode = decode7;
    this.encode = encode5;
  }
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
var mergeSignatureAnnotations = (ast, annotations2) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations2
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations2
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);

class PropertySignatureImpl {
  ast;
  [TypeId22];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations2) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)));
  }
  toString() {
    return String(this.ast);
  }
}
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);

class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations2) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)), this.from);
  }
}
var propertySignature = (self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, undefined), self2);
var withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys2 = ownKeys(fields);
  const pss = [];
  if (ownKeys2.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0;i < ownKeys2.length; i++) {
      const key = ownKeys2[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is2) => {
          issFrom.push(is2);
          issTo.push(new IndexSignature(is2.parameter, typeAST(is2.type), is2.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is2) => iss.push(is2));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys2 = ownKeys(fields);
  for (const key of ownKeys2) {
    const field = fields[key];
    if (out[key] === undefined && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== undefined) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make66(ast) {
    static annotations(annotations2) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options3) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options3) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
    static pick(...keys6) {
      return Struct(pick2(fields, ...keys6));
    }
    static omit(...keys6) {
      return Struct(omit3(fields, ...keys6));
    }
  };
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
var tag2 = (tag3) => Literal2(tag3).pipe(propertySignature, withConstructorDefault(() => tag3));
var TaggedStruct = (value3, fields) => Struct({
  _tag: tag2(value3),
  ...fields
});
function makeRecordClass(key, value3, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value: value3
  }], ast) {
    static annotations(annotations2) {
      return makeRecordClass(key, value3, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static key = key;
    static value = value3;
  };
}
var Record = (options3) => makeRecordClass(options3.key, options3.value);
function makeBrandClass(from, ast) {
  return class BrandClass extends make66(ast) {
    static annotations(annotations2) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static make = (a, options3) => {
      return getDisableValidationMakeOption(options3) ? a : validateSync(this)(a);
    };
    static from = from;
  };
}
var brand = (brand2, annotations2) => (self2) => {
  const annotation = match2(getBrandAnnotation(self2.ast), {
    onNone: () => [brand2],
    onSome: (brands) => [...brands, brand2]
  });
  const ast = annotations(self2.ast, toASTAnnotations({
    [BrandAnnotationId]: annotation,
    ...annotations2
  }));
  return makeBrandClass(self2, ast);
};
var intersectTypeLiterals = (x, y, path) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
};
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path) => Union.make(intersectUnionMembers([x], [y], path));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y, path);
          const to = intersectTypeLiterals(x.to, typeAST(y), path);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options3, ast, fromI) => map18(transformation.decode(fromA, options3, ast, fromI), (partial2) => ({
                ...fromA,
                ...partial2
              })), (toI, options3, ast, toA) => map18(transformation.encode(toI, options3, ast, toA), (partial2) => ({
                ...toI,
                ...partial2
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
}));
var extend4 = /* @__PURE__ */ dual(2, (self2, that) => make66(extendAST(self2.ast, that.ast, [])));
var compose3 = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose(from.ast, to.ast)));
var suspend12 = (f) => make66(new Suspend(() => f().ast));
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter11, ast) {
  return class RefineClass extends make66(ast) {
    static annotations(annotations2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter11;
    static make = (a, options3) => {
      return getDisableValidationMakeOption(options3) ? a : validateSync(this)(a);
    };
  };
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter11(predicate, annotations2) {
  return (self2) => {
    function filter12(input, options3, ast2) {
      return toFilterParseIssue(predicate(input, options3, ast2), ast2, input);
    }
    const ast = new Refinement(self2.ast, filter12, toASTAnnotations(annotations2));
    return makeRefineClass(self2, filter12, ast);
  };
}
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make66(ast) {
    static annotations(annotations2) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static from = from;
    static to = to;
  };
}
var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options3) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options3.decode, options3.encode))));
var transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options3) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed9(options3.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed9(options3.encode(toI, toA))
}));
var annotations2 = /* @__PURE__ */ dual(2, (self2, annotations3) => self2.annotations(annotations3));
var TrimmedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Trimmed");
var trimmed = (annotations3) => (self2) => self2.pipe(filter11((a) => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations3
}));
var MinLengthSchemaId2 = MinLengthSchemaId;
var minLength = (minLength2, annotations3) => (self2) => self2.pipe(filter11((a) => a.length >= minLength2, {
  schemaId: MinLengthSchemaId2,
  title: `minLength(${minLength2})`,
  description: `a string at least ${minLength2} character(s) long`,
  jsonSchema: {
    minLength: minLength2
  },
  ...annotations3
}));
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations3) => (self2) => {
  const source = regex.source;
  return self2.pipe(filter11((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations3
  }));
};
var nonEmptyString2 = (annotations3) => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations3
});
class Trimmed extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ trimmed({
  identifier: "Trimmed"
}))) {
}

class NonEmptyTrimmedString extends (/* @__PURE__ */ Trimmed.pipe(/* @__PURE__ */ nonEmptyString2({
  identifier: "NonEmptyTrimmedString"
}))) {
}
class NonEmptyString extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ nonEmptyString2({
  identifier: "NonEmptyString"
}))) {
}
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;

class UUID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
}
var IntSchemaId2 = IntSchemaId;
var int = (annotations3) => (self2) => self2.pipe(filter11((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations3
}));
function parseNumber(self2) {
  return transformOrFail(self2, Number$, {
    strict: false,
    decode: (i, _, ast) => fromOption4(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed9(String(a))
  });
}

class NumberFromString extends (/* @__PURE__ */ parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
}
class Int extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int"
}))) {
}
class BigInt$ extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromOption4(fromString(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)),
  encode: (a) => succeed9(String(a))
}).annotations({
  identifier: "BigInt"
})) {
}
var toComposite = (eff, onSuccess, ast, actual) => mapBoth5(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
});
var ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations3) => (self2) => self2.pipe(filter11((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations3
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;

class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date2) => `new Date(${JSON.stringify(date2)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
}
class DateFromString extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
})) {
}

class Date$ extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
}
var optionDecode = (input) => input._tag === "None" ? none2() : some2(input.value);
var optionArbitrary = (value3, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value3(fc)
})).map(optionDecode);
var optionPretty = (value3) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value3(a)})`
});
var optionParse = (decodeUnknown4) => (u, options3, ast) => isOption2(u) ? isNone2(u) ? succeed9(none2()) : toComposite(decodeUnknown4(u.value, options3), some2, ast, u) : fail9(new Type2(ast, u));
var OptionFromSelf = (value3) => {
  return declare([value3], {
    decode: (value4) => optionParse(decodeUnknown2(value4)),
    encode: (value4) => optionParse(encodeUnknown(value4))
  }, {
    description: `Option<${format6(value3)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence
  });
};
var chunkArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable2);
};
var chunkPretty = (item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`;
var chunkParse = (decodeUnknown4) => (u, options3, ast) => isChunk(u) ? isEmpty(u) ? succeed9(empty6()) : toComposite(decodeUnknown4(toReadonlyArray(u), options3), fromIterable2, ast, u) : fail9(new Type2(ast, u));
var ChunkFromSelf = (value3) => {
  return declare([value3], {
    decode: (item) => chunkParse(decodeUnknown2(Array$(item))),
    encode: (item) => chunkParse(encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format6(value3)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence4
  });
};
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => ("fields" in hasFields) ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var Class5 = (identifier2) => (fieldsOr, annotations3) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class2,
  annotations: annotations3
});
var getClassTag = (tag3) => withConstructorDefault(propertySignature(Literal2(tag3)), () => tag3);
var TaggedClass3 = (identifier2) => (tag3, fieldsOr, annotations3) => {
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedClass4 extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag3,
    schema: extend4(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Class2,
    annotations: annotations3
  }) {
    static _tag = tag3;
  };
};
var TaggedError2 = (identifier2) => (tag3, fieldsOr, annotations3) => {

  class Base3 extends Error3 {
  }
  Base3.prototype.name = tag3;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;

  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag3,
    schema: extend4(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations3,
    disableToString: true
  }) {
    static _tag = tag3;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${ownKeys(fields).map((p2) => `${formatPropertyKey(p2)}: ${formatUnknown(this[p2])}`).join(", ")} }`;
      },
      enumerable: false,
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
};
function getDisableValidationMakeOption(options3) {
  return isBoolean(options3) ? options3 : options3?.disableValidation ?? false;
}
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => new WeakMap);
var getClassAnnotations = (annotations3) => {
  if (annotations3 === undefined) {
    return [];
  } else if (Array.isArray(annotations3)) {
    return annotations3;
  } else {
    return [annotations3];
  }
};
var makeClass = ({
  Base: Base3,
  annotations: annotations3,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations3);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    [JSONIdentifierAnnotationId]: identifier2,
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
  const klass = class extends Base3 {
    constructor(props = {}, options3 = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options3)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    static [TypeId22] = variance10;
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed9(input) : fail9(new Type2(ast, input)),
        encode: () => (input, options3) => input instanceof this ? succeed9(input) : map18(encodeUnknown(typeSide)(input, options3), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty6) => (self2) => `${identifier2}(${pretty6(self2)})`,
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform2(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations4) {
      return make66(this.ast).annotations(annotations4);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations4) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend4(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options3, annotations4) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options3),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options3, annotations4) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options3),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${ownKeys(fields).map((p2) => `${formatPropertyKey(p2)}: ${formatUnknown(this[p2])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Composite"),
  left: suspend12(() => FiberIdEncoded),
  right: suspend12(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId3) => {
  switch (fiberId3._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId3.id}, ${fiberId3.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId3.right)}, ${fiberIdPretty(fiberId3.left)})`;
  }
};
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var causeDieEncoded = (defect) => Struct({
  _tag: Literal2("Die"),
  defect
});
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Empty")
});
var causeFailEncoded = (error4) => Struct({
  _tag: Literal2("Fail"),
  error: error4
});
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = (error4, defect) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const suspended3 = suspend12(() => out);
  const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format6(error4)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
};
var causeArbitrary = (error4, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error4(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error4) => (cause3) => {
  const f = (cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error4(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty2(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
    }
  };
  return f(cause3);
};
var causeParse = (decodeUnknown4) => (u, options3, ast) => isCause2(u) ? toComposite(decodeUnknown4(causeEncode(u), options3), causeDecode, ast, u) : fail9(new Type2(ast, u));
var CauseFromSelf = ({
  defect,
  error: error4
}) => {
  return declare([error4, defect], {
    decode: (error5, defect2) => causeParse(decodeUnknown2(causeEncoded(error5, defect2))),
    encode: (error5, defect2) => causeParse(encodeUnknown(causeEncoded(error5, defect2)))
  }, {
    title: `Cause<${error4.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty30;
    case "Fail":
      return fail5(cause3.error);
    case "Die":
      return die4(cause3.defect);
    case "Interrupt":
      return interrupt5(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
var Cause = ({
  defect,
  error: error4
}) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const out = transform2(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => causeDecode(i),
    encode: (a) => causeEncode(a)
  });
  return out;
};

class Defect extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return String(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
})) {
}
var exitFailureEncoded = (error4, defect) => Struct({
  _tag: Literal2("Failure"),
  cause: causeEncoded(error4, defect)
});
var exitSuccessEncoded = (value3) => Struct({
  _tag: Literal2("Success"),
  value: value3
});
var exitEncoded = (value3, error4, defect) => {
  return Union2(exitFailureEncoded(error4, defect), exitSuccessEncoded(value3)).annotations({
    title: `ExitEncoded<${format6(value3)}, ${format6(error4)}, ${format6(defect)}>`
  });
};
var exitDecode = (input) => {
  switch (input._tag) {
    case "Failure":
      return failCause4(causeDecode(input.cause));
    case "Success":
      return succeed4(input.value);
  }
};
var exitArbitrary = (value3, error4, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error4, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value3(fc)
})).map(exitDecode);
var exitPretty = (value3, error4) => (exit3) => exit3._tag === "Failure" ? `Exit.failCause(${causePretty(error4)(exit3.cause)})` : `Exit.succeed(${value3(exit3.value)})`;
var exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options3, ast) => isExit(u) ? match9(u, {
  onFailure: (cause3) => toComposite(decodeUnknownCause(cause3, options3), failCause4, ast, u),
  onSuccess: (value3) => toComposite(decodeUnknownValue(value3, options3), succeed4, ast, u)
}) : fail9(new Type2(ast, u));
var ExitFromSelf = ({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse(decodeUnknown2(success2), decodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse(encodeUnknown(success2), encodeUnknown(CauseFromSelf({
    error: failure2,
    defect: defect2
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
var Exit = ({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out = transform2(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => exitDecode(i),
    encode: (a) => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }
  });
  return out;
};

// node_modules/effect/dist/esm/Secret.js
var fromString4 = fromString2;

// node_modules/@effect/cli/dist/esm/internal/cliConfig.js
var make67 = (params) => ({
  ...defaultConfig,
  ...params
});
var Tag4 = /* @__PURE__ */ GenericTag("@effect/cli/CliConfig");
var defaultConfig = {
  isCaseSensitive: false,
  autoCorrectLimit: 2,
  finalCheckBuiltIn: false,
  showAllNames: true,
  showBuiltIns: true,
  showTypes: true
};
var defaultLayer = /* @__PURE__ */ succeed10(Tag4, defaultConfig);
var layer = (config2) => succeed10(Tag4, make67(config2));
var normalizeCase = /* @__PURE__ */ dual(2, (self2, text5) => self2.isCaseSensitive ? text5 : text5.toLowerCase());

// node_modules/@effect/platform/dist/esm/internal/terminal.js
var tag3 = /* @__PURE__ */ GenericTag("@effect/platform/Terminal");

// node_modules/@effect/platform/dist/esm/Terminal.js
class QuitException extends (/* @__PURE__ */ TaggedError("QuitException")) {
}
var Terminal = tag3;

// node_modules/@effect/cli/dist/esm/internal/prompt/action.js
var Action = /* @__PURE__ */ taggedEnum();

// node_modules/@effect/cli/dist/esm/internal/prompt.js
var PromptSymbolKey = "@effect/cli/Prompt";
var PromptTypeId = /* @__PURE__ */ Symbol.for(PromptSymbolKey);
var proto18 = {
  ...CommitPrototype2,
  [PromptTypeId]: {
    _Output: (_) => _
  },
  commit() {
    return run5(this);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isPrompt = (u) => typeof u === "object" && u != null && (PromptTypeId in u);
var custom3 = (initialState, handlers) => {
  const op = Object.create(proto18);
  op._tag = "Loop";
  op.initialState = initialState;
  op.render = handlers.render;
  op.process = handlers.process;
  op.clear = handlers.clear;
  return op;
};
var map31 = /* @__PURE__ */ dual(2, (self2, f) => flatMap19(self2, (a) => succeed19(f(a))));
var flatMap19 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto18);
  op._tag = "OnSuccess";
  op.prompt = self2;
  op.onSuccess = f;
  return op;
});
var run5 = (self2) => flatMap10(Terminal, (terminal) => {
  const op = self2;
  switch (op._tag) {
    case "Loop": {
      const makeStateRef = isEffect2(op.initialState) ? op.initialState.pipe(flatMap10(make26)) : make26(op.initialState);
      return makeStateRef.pipe(flatMap10((ref) => {
        const loop3 = (action) => get11(ref).pipe(flatMap10((state) => op.render(state, action).pipe(flatMap10((msg) => orDie2(terminal.display(msg))), zipRight3(terminal.readInput), flatMap10((input) => op.process(input, state)), flatMap10((action2) => {
          switch (action2._tag) {
            case "Beep": {
              return loop3(action2);
            }
            case "NextFrame": {
              return op.clear(state, action2).pipe(flatMap10((clear4) => orDie2(terminal.display(clear4))), zipRight3(set6(ref, action2.state)), zipRight3(loop3(action2)));
            }
            case "Submit": {
              return op.clear(state, action2).pipe(flatMap10((clear4) => orDie2(terminal.display(clear4))), zipRight3(op.render(state, action2)), flatMap10((msg) => orDie2(terminal.display(msg))), zipRight3(succeed8(action2.value)));
            }
          }
        }))));
        return get11(ref).pipe(flatMap10((state) => loop3(Action.NextFrame({
          state
        }))));
      }), ensuring2(orDie2(terminal.display(render4(cursorShow3, {
        style: "pretty"
      })))));
    }
    case "OnSuccess": {
      return flatMap10(run5(op.prompt), (a) => run5(op.onSuccess(a)));
    }
    case "Succeed": {
      return succeed8(op.value);
    }
  }
});
var succeed19 = (value4) => {
  const op = Object.create(proto18);
  op._tag = "Succeed";
  op.value = value4;
  return op;
};

// node_modules/effect/dist/esm/internal/matcher.js
var TypeId23 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId23]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId23]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value4) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value4;
  return matcher;
}
var makeWhen = (guard, evaluate3) => ({
  _tag: "When",
  guard,
  evaluate: evaluate3
});
var makePredicate = (pattern2) => {
  if (typeof pattern2 === "function") {
    return pattern2;
  } else if (Array.isArray(pattern2)) {
    const predicates = pattern2.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0;i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern2 !== null && typeof pattern2 === "object") {
    const keysAndPredicates = Object.entries(pattern2).map(([k, p2]) => [k, makePredicate(p2)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0;i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern2;
};
var value4 = (i) => makeValueMatcher(i, left2(i));
var when5 = (pattern2, f) => (self2) => self2.add(makeWhen(makePredicate(pattern2), f));
var orElse12 = (f) => (self2) => {
  const result = either7(self2);
  if (isEither2(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
var either7 = (self2) => {
  if (self2._tag === "ValueMatcher") {
    return self2.value;
  }
  const len = self2.cases.length;
  if (len === 1) {
    const _case = self2.cases[0];
    return (input) => {
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0;i < len; i++) {
      const _case = self2.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
    }
    return left2(input);
  };
};

// node_modules/effect/dist/esm/Match.js
var value5 = value4;
var when6 = when5;
var orElse13 = orElse12;

// node_modules/@effect/cli/dist/esm/internal/prompt/ansi-utils.js
var defaultFigures = {
  arrowUp: /* @__PURE__ */ text3("↑"),
  arrowDown: /* @__PURE__ */ text3("↓"),
  arrowLeft: /* @__PURE__ */ text3("←"),
  arrowRight: /* @__PURE__ */ text3("→"),
  radioOn: /* @__PURE__ */ text3("◉"),
  radioOff: /* @__PURE__ */ text3("◯"),
  checkboxOn: /* @__PURE__ */ text3("☒"),
  checkboxOff: /* @__PURE__ */ text3("☐"),
  tick: /* @__PURE__ */ text3("✔"),
  cross: /* @__PURE__ */ text3("✖"),
  ellipsis: /* @__PURE__ */ text3("…"),
  pointerSmall: /* @__PURE__ */ text3("›"),
  line: /* @__PURE__ */ text3("─"),
  pointer: /* @__PURE__ */ text3("❯")
};
var windowsFigures = {
  arrowUp: defaultFigures.arrowUp,
  arrowDown: defaultFigures.arrowDown,
  arrowLeft: defaultFigures.arrowLeft,
  arrowRight: defaultFigures.arrowRight,
  radioOn: /* @__PURE__ */ text3("(*)"),
  radioOff: /* @__PURE__ */ text3("( )"),
  checkboxOn: /* @__PURE__ */ text3("[*]"),
  checkboxOff: /* @__PURE__ */ text3("[ ]"),
  tick: /* @__PURE__ */ text3("√"),
  cross: /* @__PURE__ */ text3("×"),
  ellipsis: /* @__PURE__ */ text3("..."),
  pointerSmall: /* @__PURE__ */ text3("»"),
  line: /* @__PURE__ */ text3("─"),
  pointer: /* @__PURE__ */ text3(">")
};
var figures = /* @__PURE__ */ map17(/* @__PURE__ */ sync3(() => process.platform === "win32"), (isWindows) => isWindows ? windowsFigures : defaultFigures);
function eraseText(text5, columns) {
  if (columns === 0) {
    return cat2(eraseLine3, cursorTo3(0));
  }
  let rows = 0;
  const lines = text5.split(/\r?\n/);
  for (const line4 of lines) {
    rows += 1 + Math.floor(Math.max(line4.length - 1, 0) / columns);
  }
  return eraseLines3(rows);
}
function lines(prompt, columns) {
  const lines2 = prompt.split(/\r?\n/);
  return columns === 0 ? lines2.length : pipe(map5(lines2, (line4) => Math.ceil(line4.length / columns)), reduce(0, (left3, right3) => left3 + right3));
}

// node_modules/@effect/cli/dist/esm/internal/prompt/date.js
var renderBeep = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function handleClear(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
      const clearError = match2(state.error, {
        onNone: () => empty40,
        onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
      });
      const clearOutput = eraseText(options3.message, columns);
      return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render4({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
var NEWLINE_REGEX = /\r?\n/;
function renderError(state, pointer) {
  return match2(state.error, {
    onNone: () => empty40,
    onSome: (error4) => {
      const errorLines = error4.split(NEWLINE_REGEX);
      if (isNonEmptyReadonlyArray(errorLines)) {
        const annotateLine = (line4) => annotate2(text3(line4), combine15(italicized2, red3));
        const prefix = cat2(annotate2(pointer, red3), space2);
        const lines2 = map5(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines2))), cat2(cursorRestorePosition3));
      }
      return empty40;
    }
  });
}
function renderParts(state, submitted = false) {
  return reduce(state.dateParts, empty40, (doc, part, currentIndex) => {
    const partDoc = text3(part.toString());
    if (currentIndex === state.cursor && !submitted) {
      const annotation = combine15(underlined2, cyanBright2);
      return cat2(doc, annotate2(partDoc, annotation));
    }
    return cat2(doc, partDoc);
  });
}
function renderOutput(leadingSymbol, trailingSymbol, parts2, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(/\r?\n/), {
    onEmpty: () => hsep2([prefix, trailingSymbol, parts2]),
    onNonEmpty: (promptLines) => {
      const lines2 = map5(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(parts2));
    }
  });
}
function renderNextFrame(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const parts2 = renderParts(state);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, parts2, options3);
    const errorMsg = renderError(state, figures2.pointerSmall);
    return cursorHide3.pipe(cat2(promptMsg), cat2(errorMsg), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const parts2 = renderParts(state, true);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, parts2, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processUp(state) {
  state.dateParts[state.cursor].increment();
  return Action.NextFrame({
    state: {
      ...state,
      typed: ""
    }
  });
}
function processDown(state) {
  state.dateParts[state.cursor].decrement();
  return Action.NextFrame({
    state: {
      ...state,
      typed: ""
    }
  });
}
function processCursorLeft(state) {
  const previousPart = state.dateParts[state.cursor].previousPart();
  return match2(previousPart, {
    onNone: () => Action.Beep(),
    onSome: (previous2) => Action.NextFrame({
      state: {
        ...state,
        typed: "",
        cursor: state.dateParts.indexOf(previous2)
      }
    })
  });
}
function processCursorRight(state) {
  const nextPart = state.dateParts[state.cursor].nextPart();
  return match2(nextPart, {
    onNone: () => Action.Beep(),
    onSome: (next4) => Action.NextFrame({
      state: {
        ...state,
        typed: "",
        cursor: state.dateParts.indexOf(next4)
      }
    })
  });
}
function processNext(state) {
  const nextPart = state.dateParts[state.cursor].nextPart();
  const cursor = match2(nextPart, {
    onNone: () => state.dateParts.findIndex((part) => !part.isToken()),
    onSome: (next4) => state.dateParts.indexOf(next4)
  });
  return Action.NextFrame({
    state: {
      ...state,
      cursor
    }
  });
}
function defaultProcessor(value6, state) {
  if (/\d/.test(value6)) {
    const typed = state.typed + value6;
    state.dateParts[state.cursor].setValue(typed);
    return Action.NextFrame({
      state: {
        ...state,
        typed
      }
    });
  }
  return Action.Beep();
}
var defaultLocales = {
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
};
function handleRender(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep),
      NextFrame: ({
        state: state2
      }) => renderNextFrame(state2, options3),
      Submit: () => renderSubmission(state, options3)
    });
  };
}
function handleProcess(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "left": {
        return succeed8(processCursorLeft(state));
      }
      case "right": {
        return succeed8(processCursorRight(state));
      }
      case "k":
      case "up": {
        return succeed8(processUp(state));
      }
      case "j":
      case "down": {
        return succeed8(processDown(state));
      }
      case "tab": {
        return succeed8(processNext(state));
      }
      case "enter":
      case "return": {
        return match12(options3.validate(state.value), {
          onFailure: (error4) => Action.NextFrame({
            state: {
              ...state,
              error: some2(error4)
            }
          }),
          onSuccess: (value6) => Action.Submit({
            value: value6
          })
        });
      }
      default: {
        const value6 = getOrElse(input.input, () => "");
        return succeed8(defaultProcessor(value6, state));
      }
    }
  };
}
var date2 = (options3) => {
  const opts = {
    initial: new Date,
    dateMask: "YYYY-MM-DD HH:mm:ss",
    validate: succeed8,
    ...options3,
    locales: {
      ...defaultLocales,
      ...options3.locales
    }
  };
  const dateParts = makeDateParts(opts.dateMask, opts.initial, opts.locales);
  const initialCursorPosition = dateParts.findIndex((part) => !part.isToken());
  const initialState = {
    dateParts,
    typed: "",
    cursor: initialCursorPosition,
    value: opts.initial,
    error: none2()
  };
  return custom3(initialState, {
    render: handleRender(opts),
    process: handleProcess(opts),
    clear: handleClear(opts)
  });
};
var DATE_PART_REGEX = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
var regexGroups = {
  1: ({
    token,
    ...opts
  }) => new Token({
    token: token.replace(/\\(.)/g, "$1"),
    ...opts
  }),
  2: (opts) => new Day(opts),
  3: (opts) => new Month(opts),
  4: (opts) => new Year(opts),
  5: (opts) => new Meridiem(opts),
  6: (opts) => new Hours(opts),
  7: (opts) => new Minutes(opts),
  8: (opts) => new Seconds(opts),
  9: (opts) => new Milliseconds(opts)
};
var makeDateParts = (dateMask, date3, locales) => {
  const parts2 = [];
  let result = null;
  while (result = DATE_PART_REGEX.exec(dateMask)) {
    const match21 = result.shift();
    const index = result.findIndex((group6) => group6 !== undefined);
    if (index in regexGroups) {
      const token = result[index] || match21;
      parts2.push(regexGroups[index]({
        token,
        date: date3,
        parts: parts2,
        locales
      }));
    } else {
      parts2.push(new Token({
        token: result[index] || match21,
        date: date3,
        parts: parts2,
        locales
      }));
    }
  }
  const orderedParts = parts2.reduce((array9, element) => {
    const lastElement = array9[array9.length - 1];
    if (element.isToken() && lastElement !== undefined && lastElement.isToken()) {
      lastElement.setValue(element.token);
    } else {
      array9.push(element);
    }
    return array9;
  }, empty3());
  parts2.splice(0, parts2.length, ...orderedParts);
  return parts2;
};

class DatePart {
  token;
  date;
  parts;
  locales;
  constructor(params) {
    this.token = params.token;
    this.locales = params.locales;
    this.date = params.date || new Date;
    this.parts = params.parts || [this];
  }
  isToken() {
    return false;
  }
  nextPart() {
    return findFirstIndex(this.parts, (part) => part === this).pipe(flatMap((currentPartIndex) => findFirst2(this.parts.slice(currentPartIndex + 1), (part) => !part.isToken())));
  }
  previousPart() {
    return findFirstIndex(this.parts, (part) => part === this).pipe(flatMap((currentPartIndex) => findLast(this.parts.slice(0, currentPartIndex), (part) => !part.isToken())));
  }
  toString() {
    return String(this.date);
  }
}

class Token extends DatePart {
  increment() {}
  decrement() {}
  setValue(value6) {
    this.token = this.token + value6;
  }
  isToken() {
    return true;
  }
  toString() {
    return this.token;
  }
}

class Milliseconds extends DatePart {
  increment() {
    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
  }
  decrement() {
    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
  }
  setValue(value6) {
    this.date.setMilliseconds(Number.parseInt(value6.slice(-this.token.length)));
  }
  toString() {
    const millis2 = `${this.date.getMilliseconds()}`;
    return millis2.padStart(4, "0").substring(0, this.token.length);
  }
}

class Seconds extends DatePart {
  increment() {
    this.date.setSeconds(this.date.getSeconds() + 1);
  }
  decrement() {
    this.date.setSeconds(this.date.getSeconds() - 1);
  }
  setValue(value6) {
    this.date.setSeconds(Number.parseInt(value6.slice(-2)));
  }
  toString() {
    const seconds2 = `${this.date.getSeconds()}`;
    return this.token.length > 1 ? seconds2.padStart(2, "0") : seconds2;
  }
}

class Minutes extends DatePart {
  increment() {
    this.date.setMinutes(this.date.getMinutes() + 1);
  }
  decrement() {
    this.date.setMinutes(this.date.getMinutes() - 1);
  }
  setValue(value6) {
    this.date.setMinutes(Number.parseInt(value6.slice(-2)));
  }
  toString() {
    const minutes2 = `${this.date.getMinutes()}`;
    return this.token.length > 1 ? minutes2.padStart(2, "0") : minutes2;
  }
}

class Hours extends DatePart {
  increment() {
    this.date.setHours(this.date.getHours() + 1);
  }
  decrement() {
    this.date.setHours(this.date.getHours() - 1);
  }
  setValue(value6) {
    this.date.setHours(Number.parseInt(value6.slice(-2)));
  }
  toString() {
    const hours2 = /h/.test(this.token) ? this.date.getHours() % 12 || 12 : this.date.getHours();
    return this.token.length > 1 ? `${hours2}`.padStart(2, "0") : `${hours2}`;
  }
}

class Day extends DatePart {
  increment() {
    this.date.setDate(this.date.getDate() + 1);
  }
  decrement() {
    this.date.setDate(this.date.getDate() - 1);
  }
  setValue(value6) {
    this.date.setDate(Number.parseInt(value6.slice(-2)));
  }
  toString() {
    const date3 = this.date.getDate();
    const day = this.date.getDay();
    return value5(this.token).pipe(when6("DD", () => `${date3}`.padStart(2, "0")), when6("Do", () => `${date3}${this.ordinalIndicator(date3)}`), when6("d", () => `${day + 1}`), when6("ddd", () => this.locales.weekdaysShort[day]), when6("dddd", () => this.locales.weekdays[day]), orElse13(() => `${date3}`));
  }
  ordinalIndicator(day) {
    return value5(day % 10).pipe(when6(1, () => "st"), when6(2, () => "nd"), when6(3, () => "rd"), orElse13(() => "th"));
  }
}

class Month extends DatePart {
  increment() {
    this.date.setMonth(this.date.getMonth() + 1);
  }
  decrement() {
    this.date.setMonth(this.date.getMonth() - 1);
  }
  setValue(value6) {
    const month = Number.parseInt(value6.slice(-2)) - 1;
    this.date.setMonth(month < 0 ? 0 : month);
  }
  toString() {
    const month = this.date.getMonth();
    return value5(this.token.length).pipe(when6(2, () => `${month + 1}`.padStart(2, "0")), when6(3, () => this.locales.monthsShort[month]), when6(4, () => this.locales.months[month]), orElse13(() => `${month + 1}`));
  }
}

class Year extends DatePart {
  increment() {
    this.date.setFullYear(this.date.getFullYear() + 1);
  }
  decrement() {
    this.date.setFullYear(this.date.getFullYear() - 1);
  }
  setValue(value6) {
    this.date.setFullYear(Number.parseInt(value6.slice(-4)));
  }
  toString() {
    const year = `${this.date.getFullYear()}`.padStart(4, "0");
    return this.token.length === 2 ? year.substring(-2) : year;
  }
}

class Meridiem extends DatePart {
  increment() {
    this.date.setHours((this.date.getHours() + 12) % 24);
  }
  decrement() {
    this.increment();
  }
  setValue(_value) {}
  toString() {
    const meridiem = this.date.getHours() > 12 ? "pm" : "am";
    return /A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
  }
}

// node_modules/@effect/platform/dist/esm/internal/path.js
var TypeId24 = /* @__PURE__ */ Symbol.for("@effect/platform/Path");
var Path = /* @__PURE__ */ GenericTag("@effect/platform/Path");
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0;i <= path.length; ++i) {
    if (i < path.length) {
      code2 = path.charCodeAt(i);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/" + path.slice(lastSlash + 1, i);
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep, pathObject) {
  const dir3 = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir3) {
    return base;
  }
  if (dir3 === pathObject.root) {
    return dir3 + base;
  }
  return dir3 + sep + base;
}
function fromFileUrl(url2) {
  if (url2.protocol !== "file:") {
    return fail8(BadArgument({
      module: "Path",
      method: "fromFileUrl",
      message: "URL must be of scheme file"
    }));
  } else if (url2.hostname !== "") {
    return fail8(BadArgument({
      module: "Path",
      method: "fromFileUrl",
      message: "Invalid file URL host"
    }));
  }
  const pathname = url2.pathname;
  for (let n = 0;n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        return fail8(BadArgument({
          module: "Path",
          method: "fromFileUrl",
          message: "must not include encoded / characters"
        }));
      }
    }
  }
  return succeed8(decodeURIComponent(pathname));
}
var resolve = function resolve2() {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd = undefined;
  for (let i = arguments.length - 1;i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = arguments[i];
    } else {
      const process2 = globalThis.process;
      if (cwd === undefined && "process" in globalThis && typeof process2 === "object" && process2 !== null && typeof process2.cwd === "function") {
        cwd = process2.cwd();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charCodeAt(0) === 47;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) {
      return "/" + resolvedPath;
    } else {
      return "/";
    }
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  } else {
    return ".";
  }
};
var CHAR_FORWARD_SLASH = 47;
function toFileUrl(filepath) {
  const outURL = new URL("file://");
  let resolved = resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
    resolved += "/";
  }
  outURL.pathname = encodePathChars(resolved);
  return succeed8(outURL);
}
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes(`
`)) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("\t")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var posixImpl = /* @__PURE__ */ Path.of({
  [TypeId24]: TypeId24,
  resolve,
  normalize(path) {
    if (path.length === 0)
      return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute)
      path = ".";
    if (path.length > 0 && trailingSeparator)
      path += "/";
    if (isAbsolute)
      return "/" + path;
    return path;
  },
  isAbsolute(path) {
    return path.length > 0 && path.charCodeAt(0) === 47;
  },
  join() {
    if (arguments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0;i < arguments.length; ++i) {
      const arg = arguments[i];
      if (arg.length > 0) {
        if (joined === undefined) {
          joined = arg;
        } else {
          joined += "/" + arg;
        }
      }
    }
    if (joined === undefined) {
      return ".";
    }
    return posixImpl.normalize(joined);
  },
  relative(from, to) {
    if (from === to)
      return "";
    from = posixImpl.resolve(from);
    to = posixImpl.resolve(to);
    if (from === to)
      return "";
    let fromStart = 1;
    for (;fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47) {
        break;
      }
    }
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    for (;toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47) {
        break;
      }
    }
    const toEnd = to.length;
    const toLen = toEnd - toStart;
    const length4 = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (;i <= length4; ++i) {
      if (i === length4) {
        if (toLen > length4) {
          if (to.charCodeAt(toStart + i) === 47) {
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length4) {
          if (from.charCodeAt(fromStart + i) === 47) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i);
      const toCode3 = to.charCodeAt(toStart + i);
      if (fromCode !== toCode3) {
        break;
      } else if (fromCode === 47) {
        lastCommonSep = i;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1;i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        if (out.length === 0) {
          out += "..";
        } else {
          out += "/..";
        }
      }
    }
    if (out.length > 0) {
      return out + to.slice(toStart + lastCommonSep);
    } else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47) {
        ++toStart;
      }
      return to.slice(toStart);
    }
  },
  dirname(path) {
    if (path.length === 0)
      return ".";
    let code2 = path.charCodeAt(0);
    const hasRoot = code2 === 47;
    let end6 = -1;
    let matchedSlash = true;
    for (let i = path.length - 1;i >= 1; --i) {
      code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          end6 = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end6 === -1)
      return hasRoot ? "/" : ".";
    if (hasRoot && end6 === 1)
      return "//";
    return path.slice(0, end6);
  },
  basename(path, ext) {
    let start3 = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1;i >= 0; --i) {
        const code2 = path.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code2 === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end6 = i;
              }
            } else {
              extIdx = -1;
              end6 = firstNonSlashEnd;
            }
          }
        }
      }
      if (start3 === end6)
        end6 = firstNonSlashEnd;
      else if (end6 === -1)
        end6 = path.length;
      return path.slice(start3, end6);
    } else {
      for (i = path.length - 1;i >= 0; --i) {
        if (path.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else if (end6 === -1) {
          matchedSlash = false;
          end6 = i + 1;
        }
      }
      if (end6 === -1)
        return "";
      return path.slice(start3, end6);
    }
  },
  extname(path) {
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1;i >= 0; --i) {
      const code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code2 === 46) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end6);
  },
  format: function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  },
  parse(path) {
    const ret = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (path.length === 0)
      return ret;
    let code2 = path.charCodeAt(0);
    const isAbsolute = code2 === 47;
    let start3;
    if (isAbsolute) {
      ret.root = "/";
      start3 = 1;
    } else {
      start3 = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (;i >= start3; --i) {
      code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      if (end6 !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path.slice(1, end6);
        else
          ret.base = ret.name = path.slice(startPart, end6);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end6);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end6);
      }
      ret.ext = path.slice(startDot, end6);
    }
    if (startPart > 0)
      ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute)
      ret.dir = "/";
    return ret;
  },
  sep: "/",
  fromFileUrl,
  toFileUrl,
  toNamespacedPath: identity
});

// node_modules/@effect/platform/dist/esm/Path.js
var TypeId25 = TypeId24;
var Path2 = Path;

// node_modules/@effect/cli/dist/esm/internal/prompt/utils.js
var entriesToDisplay = (cursor, total, maxVisible) => {
  const max9 = maxVisible === undefined ? total : maxVisible;
  let startIndex = Math.min(total - max9, cursor - Math.floor(max9 / 2));
  if (startIndex < 0) {
    startIndex = 0;
  }
  const endIndex = Math.min(startIndex + max9, total);
  return {
    startIndex,
    endIndex
  };
};

// node_modules/@effect/cli/dist/esm/internal/prompt/file.js
var CONFIRM_MESSAGE = "The selected directory contains files. Would you like to traverse the selected directory?";
var Confirm = /* @__PURE__ */ taggedEnum();
var showConfirmation = /* @__PURE__ */ Confirm.$is("Show");
var renderBeep2 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function resolveCurrentPath(path, options3) {
  return match2(path, {
    onNone: () => match2(options3.startingPath, {
      onNone: () => sync3(() => process.cwd()),
      onSome: (path2) => flatMap10(FileSystem, (fs) => orDie2(fs.exists(path2)).pipe(filterOrDieMessage2(identity, `The provided starting path '${path2}' does not exist`), as3(path2)))
    }),
    onSome: (path2) => succeed8(path2)
  });
}
function getFileList(directory, options3) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const path = yield* Path2;
    const files = yield* orDie2(fs.readDirectory(directory)).pipe(map17((files2) => ["..", ...files2]));
    return yield* filter8(files, (file) => {
      const result = options3.filter(file);
      const userDefinedFilter = isEffect2(result) ? result : succeed8(result);
      const directoryFilter = options3.type === "directory" ? map17(orDie2(fs.stat(path.join(directory, file))), (info3) => info3.type === "Directory") : succeed8(true);
      return zipWith7(userDefinedFilter, directoryFilter, (a, b) => a && b);
    }, {
      concurrency: files.length
    });
  });
}
function handleClear2(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const currentPath = yield* resolveCurrentPath(state.path, options3);
      const text5 = `
`.repeat(Math.min(state.files.length, options3.maxPerPage));
      const clearPath = eraseText(currentPath, columns);
      const message = showConfirmation(state.confirm) ? CONFIRM_MESSAGE : options3.message;
      const clearPrompt = eraseText(`
${message}`, columns);
      const clearOptions = eraseText(text5, columns);
      return clearOptions.pipe(cat2(clearPath), cat2(clearPrompt), optimize3(Deep), render4({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
var NEWLINE_REGEX2 = /\r?\n/;
function renderPrompt(confirm, message, leadingSymbol, trailingSymbol) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(message.split(NEWLINE_REGEX2), {
    onEmpty: () => hsep2([prefix, trailingSymbol, confirm]),
    onNonEmpty: (promptLines) => {
      const lines2 = map5(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(confirm));
    }
  });
}
function renderPrefix(state, toDisplay, currentIndex, length4, figures2) {
  let prefix = space2;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures2.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < length4) {
    prefix = figures2.arrowDown;
  }
  return state.cursor === currentIndex ? figures2.pointer.pipe(annotate2(cyanBright2), cat2(prefix)) : prefix.pipe(cat2(space2));
}
function renderFileName(file, isSelected) {
  return isSelected ? annotate2(text3(file), combine15(underlined2, cyanBright2)) : text3(file);
}
function renderFiles(state, files, figures2, options3) {
  const length4 = files.length;
  const toDisplay = entriesToDisplay(state.cursor, length4, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex;index < toDisplay.endIndex; index++) {
    const isSelected = state.cursor === index;
    const prefix = renderPrefix(state, toDisplay, index, length4, figures2);
    const fileName = renderFileName(files[index], isSelected);
    documents.push(cat2(prefix, fileName));
  }
  return vsep2(documents);
}
function renderNextFrame2(state, options3) {
  return gen2(function* () {
    const path = yield* Path2;
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const currentPath = yield* resolveCurrentPath(state.path, options3);
    const selectedPath = state.files[state.cursor];
    const resolvedPath = path.resolve(currentPath, selectedPath);
    const resolvedPathMsg = figures2.pointerSmall.pipe(cat2(space2), cat2(text3(resolvedPath)), annotate2(blackBright2));
    if (showConfirmation(state.confirm)) {
      const leadingSymbol2 = annotate2(text3("?"), cyanBright2);
      const trailingSymbol2 = annotate2(figures2.pointerSmall, blackBright2);
      const confirm = annotate2(text3("(Y/n)"), blackBright2);
      const promptMsg2 = renderPrompt(confirm, CONFIRM_MESSAGE, leadingSymbol2, trailingSymbol2);
      return cursorHide3.pipe(cat2(promptMsg2), cat2(hardLine2), cat2(resolvedPathMsg), optimize3(Deep), render4({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    }
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderPrompt(empty40, options3.message, leadingSymbol, trailingSymbol);
    const files = renderFiles(state, state.files, figures2, options3);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(resolvedPathMsg), cat2(hardLine2), cat2(files), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission2(value6, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderPrompt(empty40, options3.message, leadingSymbol, trailingSymbol);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(text3(value6), white3)), cat2(hardLine2), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleRender2(options3) {
  return (_, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep2),
      NextFrame: ({
        state
      }) => renderNextFrame2(state, options3),
      Submit: ({
        value: value6
      }) => renderSubmission2(value6, options3)
    });
  };
}
function processCursorUp(state) {
  const cursor = state.cursor - 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor: cursor < 0 ? state.files.length - 1 : cursor
    }
  }));
}
function processCursorDown(state) {
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor: (state.cursor + 1) % state.files.length
    }
  }));
}
function processSelection(state, options3) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const path = yield* Path2;
    const currentPath = yield* resolveCurrentPath(state.path, options3);
    const selectedPath = state.files[state.cursor];
    const resolvedPath = path.resolve(currentPath, selectedPath);
    const info3 = yield* orDie2(fs.stat(resolvedPath));
    if (info3.type === "Directory") {
      const files = yield* getFileList(resolvedPath, options3);
      const filesWithoutParent = files.filter((file) => file !== "..");
      if (options3.type === "directory" || options3.type === "either") {
        return filesWithoutParent.length === 0 ? Action.Submit({
          value: resolvedPath
        }) : Action.NextFrame({
          state: {
            ...state,
            confirm: Confirm.Show()
          }
        });
      }
      return Action.NextFrame({
        state: {
          cursor: 0,
          files,
          path: some2(resolvedPath),
          confirm: Confirm.Hide()
        }
      });
    }
    return Action.Submit({
      value: resolvedPath
    });
  });
}
function handleProcess2(options3) {
  return (input, state) => gen2(function* () {
    switch (input.key.name) {
      case "k":
      case "up": {
        return yield* processCursorUp(state);
      }
      case "j":
      case "down":
      case "tab": {
        return yield* processCursorDown(state);
      }
      case "enter":
      case "return": {
        return yield* processSelection(state, options3);
      }
      case "y":
      case "t": {
        if (showConfirmation(state.confirm)) {
          const path = yield* Path2;
          const currentPath = yield* resolveCurrentPath(state.path, options3);
          const selectedPath = state.files[state.cursor];
          const resolvedPath = path.resolve(currentPath, selectedPath);
          const files = yield* getFileList(resolvedPath, options3);
          return Action.NextFrame({
            state: {
              cursor: 0,
              files,
              path: some2(resolvedPath),
              confirm: Confirm.Hide()
            }
          });
        }
        return Action.Beep();
      }
      case "n":
      case "f": {
        if (showConfirmation(state.confirm)) {
          const path = yield* Path2;
          const currentPath = yield* resolveCurrentPath(state.path, options3);
          const selectedPath = state.files[state.cursor];
          const resolvedPath = path.resolve(currentPath, selectedPath);
          return Action.Submit({
            value: resolvedPath
          });
        }
        return Action.Beep();
      }
      default: {
        return Action.Beep();
      }
    }
  });
}
var file = (options3 = {}) => {
  const opts = {
    type: options3.type ?? "file",
    message: options3.message ?? `Choose a file`,
    startingPath: fromNullable(options3.startingPath),
    maxPerPage: options3.maxPerPage ?? 10,
    filter: options3.filter ?? (() => succeed8(true))
  };
  const initialState = gen2(function* () {
    const path = none2();
    const currentPath = yield* resolveCurrentPath(path, opts);
    const files = yield* getFileList(currentPath, opts);
    const confirm = Confirm.Hide();
    return {
      cursor: 0,
      files,
      path,
      confirm
    };
  });
  return custom3(initialState, {
    render: handleRender2(opts),
    process: handleProcess2(opts),
    clear: handleClear2(opts)
  });
};

// node_modules/@effect/cli/dist/esm/internal/prompt/number.js
var parseInt2 = /* @__PURE__ */ NumberFromString.pipe(/* @__PURE__ */ int(), decodeUnknown3);
var parseFloat2 = /* @__PURE__ */ decodeUnknown3(NumberFromString);
var renderBeep3 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function handleClear3(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
      const clearError = match2(state.error, {
        onNone: () => empty40,
        onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
      });
      const clearOutput = eraseText(options3.message, columns);
      return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render4({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
function renderInput(state, submitted) {
  const annotation = match2(state.error, {
    onNone: () => combine15(underlined2, cyanBright2),
    onSome: () => red3
  });
  const value6 = state.value === "" ? empty40 : text3(`${state.value}`);
  return submitted ? value6 : annotate2(value6, annotation);
}
var NEWLINE_REGEX3 = /\r?\n/;
function renderError2(state, pointer) {
  return match2(state.error, {
    onNone: () => empty40,
    onSome: (error4) => match3(error4.split(NEWLINE_REGEX3), {
      onEmpty: () => empty40,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => annotate2(text3(line4), combine15(italicized2, red3));
        const prefix = cat2(annotate2(pointer, red3), space2);
        const lines2 = map5(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines2))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderOutput2(state, leadingSymbol, trailingSymbol, options3, submitted = false) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(/\r?\n/), {
    onEmpty: () => hsep2([prefix, trailingSymbol, renderInput(state, submitted)]),
    onNonEmpty: (promptLines) => {
      const lines2 = map5(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(renderInput(state, submitted)));
    }
  });
}
function renderNextFrame3(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const errorMsg = renderError2(state, figures2.pointerSmall);
    const promptMsg = renderOutput2(state, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(errorMsg), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission3(nextState, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput2(nextState, leadingSymbol, trailingSymbol, options3, true);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace(state) {
  if (state.value.length <= 0) {
    return succeed8(Action.Beep());
  }
  const value6 = state.value.slice(0, state.value.length - 1);
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      value: value6,
      error: none2()
    }
  }));
}
function defaultIntProcessor(state, input) {
  if (state.value.length === 0 && input === "-") {
    return succeed8(Action.NextFrame({
      state: {
        ...state,
        value: "-",
        error: none2()
      }
    }));
  }
  return match12(parseInt2(state.value + input), {
    onFailure: () => Action.Beep(),
    onSuccess: (value6) => Action.NextFrame({
      state: {
        ...state,
        value: `${value6}`,
        error: none2()
      }
    })
  });
}
function defaultFloatProcessor(state, input) {
  if (input === "." && state.value.includes(".")) {
    return succeed8(Action.Beep());
  }
  if (state.value.length === 0 && input === "-") {
    return succeed8(Action.NextFrame({
      state: {
        ...state,
        value: "-",
        error: none2()
      }
    }));
  }
  return match12(parseFloat2(state.value + input), {
    onFailure: () => Action.Beep(),
    onSuccess: (value6) => Action.NextFrame({
      state: {
        ...state,
        value: input === "." ? `${value6}.` : `${value6}`,
        error: none2()
      }
    })
  });
}
var initialState = {
  cursor: 0,
  value: "",
  error: /* @__PURE__ */ none2()
};
function handleRenderInteger(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep3),
      NextFrame: ({
        state: state2
      }) => renderNextFrame3(state2, options3),
      Submit: () => renderSubmission3(state, options3)
    });
  };
}
function handleProcessInteger(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace(state);
      }
      case "k":
      case "up": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `${options3.incrementBy}` : `${Number.parseInt(state.value) + options3.incrementBy}`,
            error: none2()
          }
        }));
      }
      case "j":
      case "down": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `-${options3.decrementBy}` : `${Number.parseInt(state.value) - options3.decrementBy}`,
            error: none2()
          }
        }));
      }
      case "enter":
      case "return": {
        return matchEffect2(parseInt2(state.value), {
          onFailure: () => succeed8(Action.NextFrame({
            state: {
              ...state,
              error: some2("Must provide an integer value")
            }
          })),
          onSuccess: (n) => match12(options3.validate(n), {
            onFailure: (error4) => Action.NextFrame({
              state: {
                ...state,
                error: some2(error4)
              }
            }),
            onSuccess: (value6) => Action.Submit({
              value: value6
            })
          })
        });
      }
      default: {
        const value6 = getOrElse(input.input, () => "");
        return defaultIntProcessor(state, value6);
      }
    }
  };
}
var integer3 = (options3) => {
  const opts = {
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    incrementBy: 1,
    decrementBy: 1,
    validate: (n) => {
      if (n < opts.min) {
        return fail8(`${n} must be greater than or equal to ${opts.min}`);
      }
      if (n > opts.max) {
        return fail8(`${n} must be less than or equal to ${opts.max}`);
      }
      return succeed8(n);
    },
    ...options3
  };
  return custom3(initialState, {
    render: handleRenderInteger(opts),
    process: handleProcessInteger(opts),
    clear: handleClear3(opts)
  });
};
function handleRenderFloat(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep3),
      NextFrame: ({
        state: state2
      }) => renderNextFrame3(state2, options3),
      Submit: () => renderSubmission3(state, options3)
    });
  };
}
function handleProcessFloat(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace(state);
      }
      case "k":
      case "up": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `${options3.incrementBy}` : `${Number.parseFloat(state.value) + options3.incrementBy}`,
            error: none2()
          }
        }));
      }
      case "j":
      case "down": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `-${options3.decrementBy}` : `${Number.parseFloat(state.value) - options3.decrementBy}`,
            error: none2()
          }
        }));
      }
      case "enter":
      case "return": {
        return matchEffect2(parseFloat2(state.value), {
          onFailure: () => succeed8(Action.NextFrame({
            state: {
              ...state,
              error: some2("Must provide a floating point value")
            }
          })),
          onSuccess: (n) => flatMap10(sync3(() => round(n, options3.precision)), (rounded) => match12(options3.validate(rounded), {
            onFailure: (error4) => Action.NextFrame({
              state: {
                ...state,
                error: some2(error4)
              }
            }),
            onSuccess: (value6) => Action.Submit({
              value: value6
            })
          }))
        });
      }
      default: {
        const value6 = getOrElse(input.input, () => "");
        return defaultFloatProcessor(state, value6);
      }
    }
  };
}
var float = (options3) => {
  const opts = {
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    incrementBy: 1,
    decrementBy: 1,
    precision: 2,
    validate: (n) => {
      if (n < opts.min) {
        return fail8(`${n} must be greater than or equal to ${opts.min}`);
      }
      if (n > opts.max) {
        return fail8(`${n} must be less than or equal to ${opts.max}`);
      }
      return succeed8(n);
    },
    ...options3
  };
  return custom3(initialState, {
    render: handleRenderFloat(opts),
    process: handleProcessFloat(opts),
    clear: handleClear3(opts)
  });
};

// node_modules/@effect/cli/dist/esm/internal/prompt/select.js
var renderBeep4 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
var NEWLINE_REGEX4 = /\r?\n/;
function renderOutput3(leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(NEWLINE_REGEX4), {
    onEmpty: () => hsep2([prefix, trailingSymbol]),
    onNonEmpty: (promptLines) => {
      const lines2 = map5(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2));
    }
  });
}
function renderChoicePrefix(state, choices, toDisplay, currentIndex, figures2) {
  let prefix = space2;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures2.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < choices.length) {
    prefix = figures2.arrowDown;
  }
  if (choices[currentIndex].disabled) {
    const annotation = combine15(bold2, blackBright2);
    return state === currentIndex ? figures2.pointer.pipe(annotate2(annotation), cat2(prefix)) : prefix.pipe(cat2(space2));
  }
  return state === currentIndex ? figures2.pointer.pipe(annotate2(cyanBright2), cat2(prefix)) : prefix.pipe(cat2(space2));
}
function renderChoiceTitle(choice2, isSelected) {
  const title = text3(choice2.title);
  if (isSelected) {
    return choice2.disabled ? annotate2(title, combine15(underlined2, blackBright2)) : annotate2(title, combine15(underlined2, cyanBright2));
  }
  return choice2.disabled ? annotate2(title, combine15(strikethrough2, blackBright2)) : title;
}
function renderChoiceDescription(choice2, isSelected) {
  if (!choice2.disabled && choice2.description && isSelected) {
    return char3("-").pipe(cat2(space2), cat2(text3(choice2.description)), annotate2(blackBright2));
  }
  return empty40;
}
function renderChoices(state, options3, figures2) {
  const choices = options3.choices;
  const toDisplay = entriesToDisplay(state, choices.length, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex;index < toDisplay.endIndex; index++) {
    const choice2 = choices[index];
    const isSelected = state === index;
    const prefix = renderChoicePrefix(state, choices, toDisplay, index, figures2);
    const title = renderChoiceTitle(choice2, isSelected);
    const description = renderChoiceDescription(choice2, isSelected);
    documents.push(prefix.pipe(cat2(title), cat2(space2), cat2(description)));
  }
  return vsep2(documents);
}
function renderNextFrame4(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const choices = renderChoices(state, options3, figures2);
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const promptMsg = renderOutput3(leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(choices), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission4(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const selected = text3(options3.choices[state].title);
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput3(leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(selected, white3)), cat2(hardLine2), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processCursorUp2(state, choices) {
  if (state === 0) {
    return succeed8(Action.NextFrame({
      state: choices.length - 1
    }));
  }
  return succeed8(Action.NextFrame({
    state: state - 1
  }));
}
function processCursorDown2(state, choices) {
  if (state === choices.length - 1) {
    return succeed8(Action.NextFrame({
      state: 0
    }));
  }
  return succeed8(Action.NextFrame({
    state: state + 1
  }));
}
function processNext2(state, choices) {
  return succeed8(Action.NextFrame({
    state: (state + 1) % choices.length
  }));
}
function handleRender3(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep4),
      NextFrame: ({
        state: state2
      }) => renderNextFrame4(state2, options3),
      Submit: () => renderSubmission4(state, options3)
    });
  };
}
function handleClear4(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const text5 = `
`.repeat(Math.min(options3.choices.length, options3.maxPerPage)) + options3.message;
    const clearOutput = eraseText(text5, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleProcess3(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "k":
      case "up": {
        return processCursorUp2(state, options3.choices);
      }
      case "j":
      case "down": {
        return processCursorDown2(state, options3.choices);
      }
      case "tab": {
        return processNext2(state, options3.choices);
      }
      case "enter":
      case "return": {
        const selected = options3.choices[state];
        if (selected.disabled) {
          return succeed8(Action.Beep());
        }
        return succeed8(Action.Submit({
          value: selected.value
        }));
      }
      default: {
        return succeed8(Action.Beep());
      }
    }
  };
}
var select = (options3) => {
  const opts = {
    maxPerPage: 10,
    ...options3
  };
  return custom3(0, {
    render: handleRender3(opts),
    process: handleProcess3(opts),
    clear: () => handleClear4(opts)
  });
};

// node_modules/@effect/cli/dist/esm/internal/prompt/text.js
function getValue(state, options3) {
  return state.value.length > 0 ? state.value : options3.default;
}
var renderBeep5 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function renderClearScreen(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
    const clearError = match2(state.error, {
      onNone: () => empty40,
      onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
    });
    const clearOutput = eraseText(options3.message, columns);
    return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderInput2(nextState, options3, submitted) {
  const text5 = getValue(nextState, options3);
  const annotation = match2(nextState.error, {
    onNone: () => {
      if (submitted) {
        return white3;
      }
      if (nextState.value.length === 0) {
        return blackBright2;
      }
      return combine15(underlined2, cyanBright2);
    },
    onSome: () => red3
  });
  switch (options3.type) {
    case "hidden": {
      return empty40;
    }
    case "password": {
      return annotate2(text3("*".repeat(text5.length)), annotation);
    }
    case "text": {
      return annotate2(text3(text5), annotation);
    }
  }
}
function renderError3(nextState, pointer) {
  return match2(nextState.error, {
    onNone: () => empty40,
    onSome: (error4) => match3(error4.split(/\r?\n/), {
      onEmpty: () => empty40,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => text3(line4).pipe(annotate2(combine15(italicized2, red3)));
        const prefix = cat2(annotate2(pointer, red3), space2);
        const lines2 = map5(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines2))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderOutput4(nextState, leadingSymbol, trailingSymbol, options3, submitted = false) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const promptLines = options3.message.split(/\r?\n/);
  const prefix = cat2(leadingSymbol, space2);
  if (isNonEmptyReadonlyArray(promptLines)) {
    const lines2 = map5(promptLines, (line4) => annotateLine(line4));
    return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(renderInput2(nextState, options3, submitted)));
  }
  return hsep2([prefix, trailingSymbol, renderInput2(nextState, options3, submitted)]);
}
function renderNextFrame5(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const promptMsg = renderOutput4(state, leadingSymbol, trailingSymbol, options3);
    const errorMsg = renderError3(state, figures2.pointerSmall);
    return promptMsg.pipe(cat2(errorMsg), cat2(cursorMove3(state.offset)), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission5(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput4(state, leadingSymbol, trailingSymbol, options3, true);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace2(state) {
  if (state.cursor <= 0) {
    return succeed8(Action.Beep());
  }
  const beforeCursor = state.value.slice(0, state.cursor - 1);
  const afterCursor = state.value.slice(state.cursor);
  const cursor = state.cursor - 1;
  const value6 = `${beforeCursor}${afterCursor}`;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      value: value6,
      error: none2()
    }
  }));
}
function processCursorLeft2(state) {
  if (state.cursor <= 0) {
    return succeed8(Action.Beep());
  }
  const cursor = state.cursor - 1;
  const offset = state.offset - 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      offset,
      error: none2()
    }
  }));
}
function processCursorRight2(state) {
  if (state.cursor >= state.value.length) {
    return succeed8(Action.Beep());
  }
  const cursor = Math.min(state.cursor + 1, state.value.length);
  const offset = Math.min(state.offset + 1, state.value.length);
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      offset,
      error: none2()
    }
  }));
}
function processTab(state, options3) {
  if (state.value === options3.default) {
    return succeed8(Action.Beep());
  }
  const value6 = getValue(state, options3);
  const cursor = value6.length;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      value: value6,
      cursor,
      error: none2()
    }
  }));
}
function defaultProcessor2(input, state) {
  const beforeCursor = state.value.slice(0, state.cursor);
  const afterCursor = state.value.slice(state.cursor);
  const value6 = `${beforeCursor}${input}${afterCursor}`;
  const cursor = beforeCursor.length + 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      value: value6,
      error: none2()
    }
  }));
}
var initialState2 = {
  cursor: 0,
  offset: 0,
  value: "",
  error: /* @__PURE__ */ none2()
};
function handleRender4(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep5),
      NextFrame: ({
        state: state2
      }) => renderNextFrame5(state2, options3),
      Submit: () => renderSubmission5(state, options3)
    });
  };
}
function handleProcess4(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace2(state);
      }
      case "left": {
        return processCursorLeft2(state);
      }
      case "right": {
        return processCursorRight2(state);
      }
      case "enter":
      case "return": {
        const value6 = getValue(state, options3);
        return match12(options3.validate(value6), {
          onFailure: (error4) => Action.NextFrame({
            state: {
              ...state,
              value: value6,
              error: some2(error4)
            }
          }),
          onSuccess: (value7) => Action.Submit({
            value: value7
          })
        });
      }
      case "tab": {
        return processTab(state, options3);
      }
      default: {
        const value6 = getOrElse(input.input, () => "");
        return defaultProcessor2(value6, state);
      }
    }
  };
}
function handleClear5(options3) {
  return (state, _) => {
    return renderClearScreen(state, options3);
  };
}
function basePrompt(options3, type2) {
  const opts = {
    default: "",
    type: type2,
    validate: succeed8,
    ...options3
  };
  return custom3(initialState2, {
    render: handleRender4(opts),
    process: handleProcess4(opts),
    clear: handleClear5(opts)
  });
}
var hidden = (options3) => basePrompt(options3, "hidden").pipe(map31(make62));
var text5 = (options3) => basePrompt(options3, "text");

// node_modules/@effect/cli/dist/esm/internal/prompt/toggle.js
var renderBeep6 = /* @__PURE__ */ render4(beep3, {
  style: "pretty"
});
function handleClear6(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const clearOutput = eraseText(options3.message, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderToggle(value6, options3, submitted = false) {
  const separator = annotate2(char3("/"), blackBright2);
  const selectedAnnotation = combine15(underlined2, submitted ? white3 : cyanBright2);
  const inactive = value6 ? text3(options3.inactive) : annotate2(text3(options3.inactive), selectedAnnotation);
  const active2 = value6 ? annotate2(text3(options3.active), selectedAnnotation) : text3(options3.active);
  return hsep2([active2, separator, inactive]);
}
function renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const promptLines = options3.message.split(/\r?\n/);
  const prefix = cat2(leadingSymbol, space2);
  if (isNonEmptyReadonlyArray(promptLines)) {
    const lines2 = map5(promptLines, (line4) => annotateLine(line4));
    return prefix.pipe(cat2(nest2(vsep2(lines2), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(toggle3));
  }
  return hsep2([prefix, trailingSymbol, toggle3]);
}
function renderNextFrame6(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const figures2 = yield* figures;
    const columns = yield* terminal.columns;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const toggle3 = renderToggle(state, options3);
    const promptMsg = renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission6(value6, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const figures2 = yield* figures;
    const columns = yield* terminal.columns;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const toggle3 = renderToggle(value6, options3, true);
    const promptMsg = renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render4({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
var activate = /* @__PURE__ */ succeed8(/* @__PURE__ */ Action.NextFrame({
  state: true
}));
var deactivate = /* @__PURE__ */ succeed8(/* @__PURE__ */ Action.NextFrame({
  state: false
}));
function handleRender5(options3) {
  return (state, action) => {
    switch (action._tag) {
      case "Beep": {
        return succeed8(renderBeep6);
      }
      case "NextFrame": {
        return renderNextFrame6(state, options3);
      }
      case "Submit": {
        return renderSubmission6(state, options3);
      }
    }
  };
}
function handleProcess5(input, state) {
  switch (input.key.name) {
    case "0":
    case "j":
    case "delete":
    case "right":
    case "down": {
      return deactivate;
    }
    case "1":
    case "k":
    case "left":
    case "up": {
      return activate;
    }
    case " ":
    case "tab": {
      return state ? deactivate : activate;
    }
    case "enter":
    case "return": {
      return succeed8(Action.Submit({
        value: state
      }));
    }
    default: {
      return succeed8(Action.Beep());
    }
  }
}
var toggle3 = (options3) => {
  const opts = {
    initial: false,
    active: "on",
    inactive: "off",
    ...options3
  };
  return custom3(opts.initial, {
    render: handleRender5(opts),
    process: handleProcess5,
    clear: () => handleClear6(opts)
  });
};

// node_modules/@effect/cli/dist/esm/internal/primitive.js
var PrimitiveSymbolKey = "@effect/cli/Primitive";
var PrimitiveTypeId = /* @__PURE__ */ Symbol.for(PrimitiveSymbolKey);
var proto19 = {
  [PrimitiveTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isPrimitive = (u) => typeof u === "object" && u != null && (PrimitiveTypeId in u);
var isBool = (self2) => isPrimitive(self2) && isBoolType(self2);
var isBoolType = (self2) => self2._tag === "Bool";
var trueValues = /* @__PURE__ */ Literal2("true", "1", "y", "yes", "on");
var isTrueValue = /* @__PURE__ */ is(trueValues);
var falseValues = /* @__PURE__ */ Literal2("false", "0", "n", "no", "off");
var isFalseValue = /* @__PURE__ */ is(falseValues);
var boolean5 = (defaultValue) => {
  const op = Object.create(proto19);
  op._tag = "Bool";
  op.defaultValue = defaultValue;
  return op;
};
var choice2 = (alternatives) => {
  const op = Object.create(proto19);
  op._tag = "Choice";
  op.alternatives = alternatives;
  return op;
};
var date3 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "DateTime";
  return op;
})();
var float2 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Float";
  return op;
})();
var integer4 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Integer";
  return op;
})();
var path = (pathType, pathExists) => {
  const op = Object.create(proto19);
  op._tag = "Path";
  op.pathType = pathType;
  op.pathExists = pathExists;
  return op;
};
var redacted2 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Redacted";
  return op;
})();
var secret2 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Secret";
  return op;
})();
var text6 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Text";
  return op;
})();
var getChoices = (self2) => getChoicesInternal(self2);
var getHelp = (self2) => getHelpInternal(self2);
var getTypeName = (self2) => getTypeNameInternal(self2);
var validate5 = /* @__PURE__ */ dual(3, (self2, value6, config2) => validateInternal(self2, value6, config2));
var wizard = /* @__PURE__ */ dual(2, (self2, help) => wizardInternal(self2, help));
var getChoicesInternal = (self2) => {
  switch (self2._tag) {
    case "Bool": {
      return some2("true | false");
    }
    case "Choice": {
      const choices = pipe(map5(self2.alternatives, ([choice3]) => choice3), join(" | "));
      return some2(choices);
    }
    case "DateTime": {
      return some2("date");
    }
    case "Float":
    case "Integer":
    case "Path":
    case "Redacted":
    case "Secret":
    case "Text": {
      return none2();
    }
  }
};
var getHelpInternal = (self2) => {
  switch (self2._tag) {
    case "Bool": {
      return text4("A true or false value.");
    }
    case "Choice": {
      const choices = pipe(map5(self2.alternatives, ([choice3]) => choice3), join(", "));
      return text4(`One of the following: ${choices}`);
    }
    case "DateTime": {
      return text4("A date without a time-zone in the ISO-8601 format, such as 2007-12-03T10:15:30.");
    }
    case "Float": {
      return text4("A floating point number.");
    }
    case "Integer": {
      return text4("An integer.");
    }
    case "Path": {
      if (self2.pathType === "either" && self2.pathExists === "yes") {
        return text4("An existing file or directory.");
      }
      if (self2.pathType === "file" && self2.pathExists === "yes") {
        return text4("An existing file.");
      }
      if (self2.pathType === "directory" && self2.pathExists === "yes") {
        return text4("An existing directory.");
      }
      if (self2.pathType === "either" && self2.pathExists === "no") {
        return text4("A file or directory that must not exist.");
      }
      if (self2.pathType === "file" && self2.pathExists === "no") {
        return text4("A file that must not exist.");
      }
      if (self2.pathType === "directory" && self2.pathExists === "no") {
        return text4("A directory that must not exist.");
      }
      if (self2.pathType === "either" && self2.pathExists === "either") {
        return text4("A file or directory.");
      }
      if (self2.pathType === "file" && self2.pathExists === "either") {
        return text4("A file.");
      }
      if (self2.pathType === "directory" && self2.pathExists === "either") {
        return text4("A directory.");
      }
      throw new Error("[BUG]: Path.help - encountered invalid combination of path type " + `('${self2.pathType}') and path existence ('${self2.pathExists}')`);
    }
    case "Secret":
    case "Redacted": {
      return text4("A user-defined piece of text that is confidential.");
    }
    case "Text": {
      return text4("A user-defined piece of text.");
    }
  }
};
var getTypeNameInternal = (self2) => {
  switch (self2._tag) {
    case "Bool": {
      return "boolean";
    }
    case "Choice": {
      return "choice";
    }
    case "DateTime": {
      return "date";
    }
    case "Float": {
      return "float";
    }
    case "Integer": {
      return "integer";
    }
    case "Path": {
      if (self2.pathType === "either") {
        return "path";
      }
      return self2.pathType;
    }
    case "Redacted": {
      return "redacted";
    }
    case "Secret": {
      return "secret";
    }
    case "Text": {
      return "text";
    }
  }
};
var validateInternal = (self2, value6, config2) => {
  switch (self2._tag) {
    case "Bool": {
      return map2(value6, (str) => normalizeCase(config2, str)).pipe(match2({
        onNone: () => orElseFail2(self2.defaultValue, () => `Missing default value for boolean parameter`),
        onSome: (value7) => isTrueValue(value7) ? succeed8(true) : isFalseValue(value7) ? succeed8(false) : fail8(`Unable to recognize '${value7}' as a valid boolean`)
      }));
    }
    case "Choice": {
      return orElseFail2(value6, () => `Choice options to not have a default value`).pipe(flatMap10((value7) => findFirst2(self2.alternatives, ([choice3]) => choice3 === value7)), mapBoth4({
        onFailure: () => {
          const choices = pipe(map5(self2.alternatives, ([choice3]) => choice3), join(", "));
          return `Expected one of the following cases: ${choices}`;
        },
        onSuccess: ([, value7]) => value7
      }));
    }
    case "DateTime": {
      return attempt(value6, getTypeNameInternal(self2), decodeUnknown3(Date$));
    }
    case "Float": {
      return attempt(value6, getTypeNameInternal(self2), decodeUnknown3(NumberFromString));
    }
    case "Integer": {
      const intFromString = compose3(NumberFromString, Int);
      return attempt(value6, getTypeNameInternal(self2), decodeUnknown3(intFromString));
    }
    case "Path": {
      return flatMap10(FileSystem, (fileSystem) => {
        const errorMsg = "Path options do not have a default value";
        return orElseFail2(value6, () => errorMsg).pipe(tap2((path2) => orDie2(fileSystem.exists(path2)).pipe(tap2((pathExists) => validatePathExistence(path2, self2.pathExists, pathExists).pipe(zipRight3(validatePathType(path2, self2.pathType, fileSystem).pipe(when2(() => self2.pathExists !== "no" && pathExists))))))));
      });
    }
    case "Redacted": {
      return attempt(value6, getTypeNameInternal(self2), decodeUnknown3(String$)).pipe(map17((value7) => make62(value7)));
    }
    case "Secret": {
      return attempt(value6, getTypeNameInternal(self2), decodeUnknown3(String$)).pipe(map17((value7) => fromString4(value7)));
    }
    case "Text": {
      return attempt(value6, getTypeNameInternal(self2), decodeUnknown3(String$));
    }
  }
};
var attempt = (option6, typeName, parse6) => orElseFail2(option6, () => `${typeName} options do not have a default value`).pipe(flatMap10((value6) => orElseFail2(parse6(value6), () => `'${value6}' is not a ${typeName}`)));
var validatePathExistence = (path2, shouldPathExist, pathExists) => {
  if (shouldPathExist === "no" && pathExists) {
    return fail8(`Path '${path2}' must not exist`);
  }
  if (shouldPathExist === "yes" && !pathExists) {
    return fail8(`Path '${path2}' must exist`);
  }
  return _void;
};
var validatePathType = (path2, pathType, fileSystem) => {
  switch (pathType) {
    case "file": {
      const checkIsFile = fileSystem.stat(path2).pipe(map17((info3) => info3.type === "File"), orDie2);
      return fail8(`Expected path '${path2}' to be a regular file`).pipe(unlessEffect2(checkIsFile), asVoid4);
    }
    case "directory": {
      const checkIsDirectory = fileSystem.stat(path2).pipe(map17((info3) => info3.type === "Directory"), orDie2);
      return fail8(`Expected path '${path2}' to be a directory`).pipe(unlessEffect2(checkIsDirectory), asVoid4);
    }
    case "either": {
      return _void;
    }
  }
};
var wizardInternal = (self2, help) => {
  switch (self2._tag) {
    case "Bool": {
      const primitiveHelp = p("Select true or false");
      const message = sequence(help, primitiveHelp);
      const initial = getOrElse(self2.defaultValue, () => false);
      return toggle3({
        message: toAnsiText(message).trimEnd(),
        initial,
        active: "true",
        inactive: "false"
      }).pipe(map31((bool) => `${bool}`));
    }
    case "Choice": {
      const primitiveHelp = p("Select one of the following choices");
      const message = sequence(help, primitiveHelp);
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: map5(self2.alternatives, ([title]) => ({
          title,
          value: title
        }))
      });
    }
    case "DateTime": {
      const primitiveHelp = p("Enter a date");
      const message = sequence(help, primitiveHelp);
      return date2({
        message: toAnsiText(message).trimEnd()
      }).pipe(map31((date4) => date4.toISOString()));
    }
    case "Float": {
      const primitiveHelp = p("Enter a floating point value");
      const message = sequence(help, primitiveHelp);
      return float({
        message: toAnsiText(message).trimEnd()
      }).pipe(map31((value6) => `${value6}`));
    }
    case "Integer": {
      const primitiveHelp = p("Enter an integer");
      const message = sequence(help, primitiveHelp);
      return integer3({
        message: toAnsiText(message).trimEnd()
      }).pipe(map31((value6) => `${value6}`));
    }
    case "Path": {
      const primitiveHelp = p("Select a file system path");
      const message = sequence(help, primitiveHelp);
      return file({
        type: self2.pathType,
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Redacted": {
      const primitiveHelp = p("Enter some text (value will be redacted)");
      const message = sequence(help, primitiveHelp);
      return hidden({
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Secret": {
      const primitiveHelp = p("Enter some text (value will be redacted)");
      const message = sequence(help, primitiveHelp);
      return hidden({
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Text": {
      const primitiveHelp = p("Enter some text");
      const message = sequence(help, primitiveHelp);
      return text5({
        message: toAnsiText(message).trimEnd()
      });
    }
  }
};
var getBashCompletions = (self2) => {
  switch (self2._tag) {
    case "Bool": {
      return '"${cur}"';
    }
    case "DateTime":
    case "Float":
    case "Integer":
    case "Secret":
    case "Redacted":
    case "Text": {
      return '$(compgen -f "${cur}")';
    }
    case "Path": {
      switch (self2.pathType) {
        case "file": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? '$(compgen -f "${cur}")' : "";
        }
        case "directory": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? '$(compgen -d "${cur}")' : "";
        }
        case "either": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? '$(compgen -f "${cur}")' : "";
        }
      }
    }
    case "Choice": {
      const choices = pipe(map5(self2.alternatives, ([choice3]) => choice3), join(","));
      return `$(compgen -W "${choices}" -- "\${cur}")`;
    }
  }
};
var getFishCompletions = (self2) => {
  switch (self2._tag) {
    case "Bool": {
      return empty3();
    }
    case "DateTime":
    case "Float":
    case "Integer":
    case "Redacted":
    case "Secret":
    case "Text": {
      return make4("-r", "-f");
    }
    case "Path": {
      switch (self2.pathType) {
        case "file": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? make4("-r", "-F") : make4("-r");
        }
        case "directory": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? make4("-r", "-f", "-a", `"(__fish_complete_directories (commandline -ct))"`) : make4("-r");
        }
        case "either": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? make4("-r", "-F") : make4("-r");
        }
      }
    }
    case "Choice": {
      const choices = pipe(map5(self2.alternatives, ([choice3]) => `${choice3}''`), join(","));
      return make4("-r", "-f", "-a", `"{${choices}}"`);
    }
  }
};
var getZshCompletions = (self2) => {
  switch (self2._tag) {
    case "Bool": {
      return "";
    }
    case "Choice": {
      const choices = pipe(map5(self2.alternatives, ([name]) => name), join(" "));
      return `:CHOICE:(${choices})`;
    }
    case "DateTime": {
      return "";
    }
    case "Float": {
      return "";
    }
    case "Integer": {
      return "";
    }
    case "Path": {
      switch (self2.pathType) {
        case "file": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? ":PATH:_files" : "";
        }
        case "directory": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? ":PATH:_files -/" : "";
        }
        case "either": {
          return self2.pathExists === "yes" || self2.pathExists === "either" ? ":PATH:_files" : "";
        }
      }
    }
    case "Redacted":
    case "Secret":
    case "Text": {
      return "";
    }
  }
};

// node_modules/@effect/cli/dist/esm/internal/usage.js
var empty43 = {
  _tag: "Empty"
};
var mixed = {
  _tag: "Empty"
};
var named = (names, acceptedValues) => ({
  _tag: "Named",
  names,
  acceptedValues
});
var optional = (self2) => ({
  _tag: "Optional",
  usage: self2
});
var repeated2 = (self2) => ({
  _tag: "Repeated",
  usage: self2
});
var alternation = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: "Alternation",
  left: self2,
  right: that
}));
var concat5 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: "Concat",
  left: self2,
  right: that
}));
var getHelp2 = (self2) => {
  const spans2 = enumerate(self2, defaultConfig);
  if (isNonEmptyReadonlyArray(spans2)) {
    const head6 = headNonEmpty(spans2);
    const tail2 = tailNonEmpty(spans2);
    if (isNonEmptyReadonlyArray(tail2)) {
      return pipe(map5(spans2, (span3) => p(span3)), reduceRight(empty42, (left3, right3) => sequence(left3, right3)));
    }
    return p(head6);
  }
  return empty42;
};
var enumerate = /* @__PURE__ */ dual(2, (self2, config2) => render5(simplify(self2, config2), config2));
var simplify = (self2, config2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty43;
    }
    case "Mixed": {
      return mixed;
    }
    case "Named": {
      if (isNone2(head(render5(self2, config2)))) {
        return empty43;
      }
      return self2;
    }
    case "Optional": {
      if (self2.usage._tag === "Empty") {
        return empty43;
      }
      const usage = simplify(self2.usage, config2);
      return usage._tag === "Empty" ? empty43 : usage._tag === "Optional" ? usage : optional(usage);
    }
    case "Repeated": {
      const usage = simplify(self2.usage, config2);
      return usage._tag === "Empty" ? empty43 : repeated2(usage);
    }
    case "Alternation": {
      const leftUsage = simplify(self2.left, config2);
      const rightUsage = simplify(self2.right, config2);
      return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : alternation(leftUsage, rightUsage);
    }
    case "Concat": {
      const leftUsage = simplify(self2.left, config2);
      const rightUsage = simplify(self2.right, config2);
      return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : concat5(leftUsage, rightUsage);
    }
  }
};
var render5 = (self2, config2) => {
  switch (self2._tag) {
    case "Empty": {
      return of(text4(""));
    }
    case "Mixed": {
      return of(text4("<command>"));
    }
    case "Named": {
      const typeInfo = config2.showTypes ? match2(self2.acceptedValues, {
        onNone: () => empty41,
        onSome: (s) => concat4(space3, text4(s))
      }) : empty41;
      const namesToShow = config2.showAllNames ? self2.names : self2.names.length > 1 ? pipe(filter2(self2.names, (name) => name.startsWith("--")), head, map2(of), getOrElse(() => self2.names)) : self2.names;
      const nameInfo = text4(join(namesToShow, ", "));
      return config2.showAllNames && self2.names.length > 1 ? of(spans([text4("("), nameInfo, typeInfo, text4(")")])) : of(concat4(nameInfo, typeInfo));
    }
    case "Optional": {
      return map5(render5(self2.usage, config2), (span3) => spans([text4("["), span3, text4("]")]));
    }
    case "Repeated": {
      return map5(render5(self2.usage, config2), (span3) => concat4(span3, text4("...")));
    }
    case "Alternation": {
      if (self2.left._tag === "Repeated" || self2.right._tag === "Repeated" || self2.left._tag === "Concat" || self2.right._tag === "Concat") {
        return appendAll(render5(self2.left, config2), render5(self2.right, config2));
      }
      return flatMap2(render5(self2.left, config2), (left3) => map5(render5(self2.right, config2), (right3) => spans([left3, text4("|"), right3])));
    }
    case "Concat": {
      const leftSpan = render5(self2.left, config2);
      const rightSpan = render5(self2.right, config2);
      const separator = isNonEmptyReadonlyArray(leftSpan) && isNonEmptyReadonlyArray(rightSpan) ? space3 : empty41;
      return flatMap2(leftSpan, (left3) => map5(rightSpan, (right3) => spans([left3, separator, right3])));
    }
  }
};

// node_modules/@effect/cli/dist/esm/internal/validationError.js
var ValidationErrorSymbolKey = "@effect/cli/ValidationError";
var ValidationErrorTypeId = /* @__PURE__ */ Symbol.for(ValidationErrorSymbolKey);
var proto20 = {
  [ValidationErrorTypeId]: ValidationErrorTypeId
};
var isValidationError = (u) => typeof u === "object" && u != null && (ValidationErrorTypeId in u);
var isCommandMismatch = (self2) => self2._tag === "CommandMismatch";
var isHelpRequested = (self2) => self2._tag === "HelpRequested";
var isMultipleValuesDetected = (self2) => self2._tag === "MultipleValuesDetected";
var isMissingValue = (self2) => self2._tag === "MissingValue";
var commandMismatch = (error4) => {
  const op = Object.create(proto20);
  op._tag = "CommandMismatch";
  op.error = error4;
  return op;
};
var correctedFlag = (error4) => {
  const op = Object.create(proto20);
  op._tag = "CorrectedFlag";
  op.error = error4;
  return op;
};
var invalidArgument = (error4) => {
  const op = Object.create(proto20);
  op._tag = "InvalidArgument";
  op.error = error4;
  return op;
};
var invalidValue = (error4) => {
  const op = Object.create(proto20);
  op._tag = "InvalidValue";
  op.error = error4;
  return op;
};
var missingFlag = (error4) => {
  const op = Object.create(proto20);
  op._tag = "MissingFlag";
  op.error = error4;
  return op;
};
var missingValue = (error4) => {
  const op = Object.create(proto20);
  op._tag = "MissingValue";
  op.error = error4;
  return op;
};
var multipleValuesDetected = (error4, values4) => {
  const op = Object.create(proto20);
  op._tag = "MultipleValuesDetected";
  op.error = error4;
  op.values = values4;
  return op;
};
var noBuiltInMatch = (error4) => {
  const op = Object.create(proto20);
  op._tag = "NoBuiltInMatch";
  op.error = error4;
  return op;
};
var unclusteredFlag = (error4, unclustered, rest) => {
  const op = Object.create(proto20);
  op._tag = "UnclusteredFlag";
  op.error = error4;
  op.unclustered = unclustered;
  op.rest = rest;
  return op;
};

// node_modules/@effect/cli/dist/esm/internal/args.js
var ArgsSymbolKey = "@effect/cli/Args";
var ArgsTypeId = /* @__PURE__ */ Symbol.for(ArgsSymbolKey);
var proto21 = {
  [ArgsTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isArgs = (u) => typeof u === "object" && u != null && (ArgsTypeId in u);
var isInstruction = (self2) => self2;
var isEmpty19 = (self2) => self2._tag === "Empty";
var isWithDefault = (self2) => self2._tag === "WithDefault";
var all9 = function() {
  if (arguments.length === 1) {
    if (isArgs(arguments[0])) {
      return map32(arguments[0], (x) => [x]);
    } else if (isArray(arguments[0])) {
      return allTupled(arguments[0]);
    } else {
      const entries2 = Object.entries(arguments[0]);
      let result = map32(entries2[0][1], (value6) => ({
        [entries2[0][0]]: value6
      }));
      if (entries2.length === 1) {
        return result;
      }
      const rest = entries2.slice(1);
      for (const [key, options3] of rest) {
        result = map32(makeBoth(result, options3), ([record2, value6]) => ({
          ...record2,
          [key]: value6
        }));
      }
      return result;
    }
  }
  return allTupled(arguments[0]);
};
var boolean6 = (config2) => makeSingle(fromNullable(config2?.name), boolean5(none2()));
var choice3 = (choices, config2) => makeSingle(fromNullable(config2?.name), choice2(choices));
var date4 = (config2) => makeSingle(fromNullable(config2?.name), date3);
var directory = (config2) => makeSingle(fromNullable(config2?.name), path("directory", config2?.exists || "either"));
var file2 = (config2) => makeSingle(fromNullable(config2?.name), path("file", config2?.exists || "either"));
var fileContent = (config2) => mapEffect6(file2({
  ...config2,
  exists: "yes"
}), (path2) => mapError2(read2(path2), (e) => p(e)));
var fileParse = (config2) => mapEffect6(fileText(config2), ([path2, content]) => mapError2(parse5(path2, content, config2?.format), (e) => p(e)));
var fileSchema = (schema, config2) => withSchema(fileParse(config2), schema);
var fileText = (config2) => mapEffect6(file2({
  ...config2,
  exists: "yes"
}), (path2) => mapError2(readString(path2), (e) => p(e)));
var float3 = (config2) => makeSingle(fromNullable(config2?.name), float2);
var integer5 = (config2) => makeSingle(fromNullable(config2?.name), integer4);
var none11 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto21);
  op._tag = "Empty";
  return op;
})();
var path2 = (config2) => makeSingle(fromNullable(config2?.name), path("either", config2?.exists || "either"));
var redacted3 = (config2) => makeSingle(fromNullable(config2?.name), redacted2);
var secret3 = (config2) => makeSingle(fromNullable(config2?.name), secret2);
var text7 = (config2) => makeSingle(fromNullable(config2?.name), text6);
var atLeast = /* @__PURE__ */ dual(2, (self2, times2) => makeVariadic(self2, some2(times2), none2()));
var atMost = /* @__PURE__ */ dual(2, (self2, times2) => makeVariadic(self2, none2(), some2(times2)));
var between5 = /* @__PURE__ */ dual(3, (self2, min7, max9) => makeVariadic(self2, some2(min7), some2(max9)));
var getHelp3 = (self2) => getHelpInternal2(self2);
var getIdentifier = (self2) => getIdentifierInternal(self2);
var getMinSize = (self2) => getMinSizeInternal(self2);
var getMaxSize = (self2) => getMaxSizeInternal(self2);
var getUsage = (self2) => getUsageInternal(self2);
var map32 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect6(self2, (a) => succeed8(f(a))));
var mapEffect6 = /* @__PURE__ */ dual(2, (self2, f) => makeMap(self2, f));
var mapTryCatch = /* @__PURE__ */ dual(3, (self2, f, onError5) => mapEffect6(self2, (a) => {
  try {
    return right2(f(a));
  } catch (e) {
    return left2(onError5(e));
  }
}));
var optional2 = (self2) => makeWithDefault(map32(self2, some2), none2());
var repeated3 = (self2) => makeVariadic(self2, none2(), none2());
var validate6 = /* @__PURE__ */ dual(3, (self2, args2, config2) => validateInternal2(self2, args2, config2));
var withDefault3 = /* @__PURE__ */ dual(2, (self2, fallback) => makeWithDefault(self2, fallback));
var withFallbackConfig = /* @__PURE__ */ dual(2, (self2, config2) => {
  if (isInstruction(self2) && isWithDefault(self2)) {
    return makeWithDefault(withFallbackConfig(self2.args, config2), self2.fallback);
  }
  return makeWithFallbackConfig(self2, config2);
});
var withSchema = /* @__PURE__ */ dual(2, (self2, schema) => {
  const decode7 = decode2(schema);
  return mapEffect6(self2, (_) => mapError2(decode7(_), (issue) => p(TreeFormatter.formatIssueSync(issue))));
});
var withDescription3 = /* @__PURE__ */ dual(2, (self2, description) => withDescriptionInternal(self2, description));
var wizard2 = /* @__PURE__ */ dual(2, (self2, config2) => wizardInternal2(self2, config2));
var allTupled = (arg) => {
  if (arg.length === 0) {
    return none11;
  }
  if (arg.length === 1) {
    return map32(arg[0], (x) => [x]);
  }
  let result = map32(arg[0], (x) => [x]);
  for (let i = 1;i < arg.length; i++) {
    const curr = arg[i];
    result = map32(makeBoth(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
var getHelpInternal2 = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty42;
    }
    case "Single": {
      return descriptionList([[weak(self2.name), sequence(p(getHelp(self2.primitiveType)), self2.description)]]);
    }
    case "Map": {
      return getHelpInternal2(self2.args);
    }
    case "Both": {
      return sequence(getHelpInternal2(self2.left), getHelpInternal2(self2.right));
    }
    case "Variadic": {
      const help = getHelpInternal2(self2.args);
      return mapDescriptionList(help, (oldSpan, oldBlock) => {
        const min7 = getMinSizeInternal(self2);
        const max9 = getMaxSizeInternal(self2);
        const newSpan = text4(isSome2(self2.max) ? ` ${min7} - ${max9}` : min7 === 0 ? "..." : ` ${min7}+`);
        const newBlock = p(isSome2(self2.max) ? `This argument must be repeated at least ${min7} times and may be repeated up to ${max9} times.` : min7 === 0 ? "This argument may be repeated zero or more times." : `This argument must be repeated at least ${min7} times.`);
        return [concat4(oldSpan, newSpan), sequence(oldBlock, newBlock)];
      });
    }
    case "WithDefault": {
      return mapDescriptionList(getHelpInternal2(self2.args), (span3, block) => {
        const optionalDescription = isOption2(self2.fallback) ? match2(self2.fallback, {
          onNone: () => p("This setting is optional."),
          onSome: (fallbackValue) => {
            const inspectableValue = isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
            const displayValue = toStringUnknown(inspectableValue, 0);
            return p(`This setting is optional. Defaults to: ${displayValue}`);
          }
        }) : p("This setting is optional.");
        return [span3, sequence(block, optionalDescription)];
      });
    }
    case "WithFallbackConfig": {
      return mapDescriptionList(getHelpInternal2(self2.args), (span3, block) => [span3, sequence(block, p("This argument can be set from environment variables."))]);
    }
  }
};
var getIdentifierInternal = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return none2();
    }
    case "Single": {
      return some2(self2.name);
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getIdentifierInternal(self2.args);
    }
    case "Both": {
      const ids3 = getSomes([getIdentifierInternal(self2.left), getIdentifierInternal(self2.right)]);
      return match3(ids3, {
        onEmpty: () => none2(),
        onNonEmpty: (ids4) => some2(join(ids4, ", "))
      });
    }
  }
};
var getMinSizeInternal = (self2) => {
  switch (self2._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallbackConfig": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "Map": {
      return getMinSizeInternal(self2.args);
    }
    case "Both": {
      const leftMinSize = getMinSizeInternal(self2.left);
      const rightMinSize = getMinSizeInternal(self2.right);
      return leftMinSize + rightMinSize;
    }
    case "Variadic": {
      const argsMinSize = getMinSizeInternal(self2.args);
      return Math.floor(getOrElse(self2.min, () => 0) * argsMinSize);
    }
  }
};
var getMaxSizeInternal = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "Map":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getMaxSizeInternal(self2.args);
    }
    case "Both": {
      const leftMaxSize = getMaxSizeInternal(self2.left);
      const rightMaxSize = getMaxSizeInternal(self2.right);
      return leftMaxSize + rightMaxSize;
    }
    case "Variadic": {
      const argsMaxSize = getMaxSizeInternal(self2.args);
      return Math.floor(getOrElse(self2.max, () => Number.MAX_SAFE_INTEGER / 2) * argsMaxSize);
    }
  }
};
var getUsageInternal = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty43;
    }
    case "Single": {
      return named(of(self2.name), getChoices(self2.primitiveType));
    }
    case "Map": {
      return getUsageInternal(self2.args);
    }
    case "Both": {
      return concat5(getUsageInternal(self2.left), getUsageInternal(self2.right));
    }
    case "Variadic": {
      return repeated2(getUsageInternal(self2.args));
    }
    case "WithDefault":
    case "WithFallbackConfig": {
      return optional(getUsageInternal(self2.args));
    }
  }
};
var makeSingle = (pseudoName, primitiveType, description = empty42) => {
  const op = Object.create(proto21);
  op._tag = "Single";
  op.name = `<${getOrElse(pseudoName, () => getTypeName(primitiveType))}>`;
  op.pseudoName = pseudoName;
  op.primitiveType = primitiveType;
  op.description = description;
  return op;
};
var makeMap = (self2, f) => {
  const op = Object.create(proto21);
  op._tag = "Map";
  op.args = self2;
  op.f = f;
  return op;
};
var makeBoth = (left3, right3) => {
  const op = Object.create(proto21);
  op._tag = "Both";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeWithDefault = (self2, fallback) => {
  const op = Object.create(proto21);
  op._tag = "WithDefault";
  op.args = self2;
  op.fallback = fallback;
  return op;
};
var makeWithFallbackConfig = (args2, config2) => {
  const op = Object.create(proto21);
  op._tag = "WithFallbackConfig";
  op.args = args2;
  op.config = config2;
  return op;
};
var makeVariadic = (args2, min7, max9) => {
  const op = Object.create(proto21);
  op._tag = "Variadic";
  op.args = args2;
  op.min = min7;
  op.max = max9;
  return op;
};
var validateInternal2 = (self2, args2, config2) => {
  switch (self2._tag) {
    case "Empty": {
      return succeed8([args2, undefined]);
    }
    case "Single": {
      return suspend3(() => {
        return matchLeft(args2, {
          onEmpty: () => {
            const choices = getChoices(self2.primitiveType);
            if (isSome2(self2.pseudoName) && isSome2(choices)) {
              return fail8(missingValue(p(`Missing argument <${self2.pseudoName.value}> with choices ${choices.value}`)));
            }
            if (isSome2(self2.pseudoName)) {
              return fail8(missingValue(p(`Missing argument <${self2.pseudoName.value}>`)));
            }
            if (isSome2(choices)) {
              return fail8(missingValue(p(`Missing argument ${getTypeName(self2.primitiveType)} with choices ${choices.value}`)));
            }
            return fail8(missingValue(p(`Missing argument ${getTypeName(self2.primitiveType)}`)));
          },
          onNonEmpty: (head6, tail2) => validate5(self2.primitiveType, some2(head6), config2).pipe(mapBoth4({
            onFailure: (text8) => invalidArgument(p(text8)),
            onSuccess: (a) => [tail2, a]
          }))
        });
      });
    }
    case "Map": {
      return validateInternal2(self2.args, args2, config2).pipe(flatMap10(([leftover2, a]) => matchEffect2(self2.f(a), {
        onFailure: (doc) => fail8(invalidArgument(doc)),
        onSuccess: (b) => succeed8([leftover2, b])
      })));
    }
    case "Both": {
      return validateInternal2(self2.left, args2, config2).pipe(flatMap10(([args3, a]) => validateInternal2(self2.right, args3, config2).pipe(map17(([args4, b]) => [args4, [a, b]]))));
    }
    case "Variadic": {
      const min1 = getOrElse(self2.min, () => 0);
      const max1 = getOrElse(self2.max, () => Number.MAX_SAFE_INTEGER);
      const loop3 = (args3, acc) => {
        if (acc.length >= max1) {
          return succeed8([args3, acc]);
        }
        return validateInternal2(self2.args, args3, config2).pipe(matchEffect2({
          onFailure: (failure) => acc.length >= min1 && isEmptyReadonlyArray(args3) ? succeed8([args3, acc]) : fail8(failure),
          onSuccess: ([args4, a]) => loop3(args4, append(acc, a))
        }));
      };
      return loop3(args2, empty3()).pipe(map17(([args3, acc]) => [args3, acc]));
    }
    case "WithDefault": {
      return validateInternal2(self2.args, args2, config2).pipe(catchTag2("MissingValue", () => succeed8([args2, self2.fallback])));
    }
    case "WithFallbackConfig": {
      return validateInternal2(self2.args, args2, config2).pipe(catchTag2("MissingValue", (e) => map17(catchAll2(self2.config, (e2) => {
        if (isMissingDataOnly2(e2)) {
          const help = p(String(e2));
          const error4 = invalidValue(help);
          return fail8(error4);
        }
        return fail8(e);
      }), (value6) => [args2, value6])));
    }
  }
};
var withDescriptionInternal = (self2, description) => {
  switch (self2._tag) {
    case "Empty": {
      return none11;
    }
    case "Single": {
      const desc = sequence(self2.description, p(description));
      return makeSingle(self2.pseudoName, self2.primitiveType, desc);
    }
    case "Map": {
      return makeMap(withDescriptionInternal(self2.args, description), self2.f);
    }
    case "Both": {
      return makeBoth(withDescriptionInternal(self2.left, description), withDescriptionInternal(self2.right, description));
    }
    case "Variadic": {
      return makeVariadic(withDescriptionInternal(self2.args, description), self2.min, self2.max);
    }
    case "WithDefault": {
      return makeWithDefault(withDescriptionInternal(self2.args, description), self2.fallback);
    }
    case "WithFallbackConfig": {
      return makeWithFallbackConfig(withDescriptionInternal(self2.args, description), self2.config);
    }
  }
};
var wizardInternal2 = (self2, config2) => {
  switch (self2._tag) {
    case "Empty": {
      return succeed8(empty3());
    }
    case "Single": {
      const help = getHelpInternal2(self2);
      return wizard(self2.primitiveType, help).pipe(zipLeft2(log3()), flatMap10((input) => {
        const args2 = of(input);
        return validateInternal2(self2, args2, config2).pipe(as3(args2));
      }));
    }
    case "Map": {
      return wizardInternal2(self2.args, config2).pipe(tap2((args2) => validateInternal2(self2.args, args2, config2)));
    }
    case "Both": {
      return zipWith7(wizardInternal2(self2.left, config2), wizardInternal2(self2.right, config2), (left3, right3) => appendAll(left3, right3)).pipe(tap2((args2) => validateInternal2(self2, args2, config2)));
    }
    case "Variadic": {
      const repeatHelp = p("How many times should this argument should be repeated?");
      const message = pipe(getHelpInternal2(self2), sequence(repeatHelp));
      return integer3({
        message: toAnsiText(message).trimEnd(),
        min: getMinSizeInternal(self2),
        max: getMaxSizeInternal(self2)
      }).pipe(zipLeft2(log3()), flatMap10((n) => n <= 0 ? succeed8(empty3()) : make26(empty3()).pipe(flatMap10((ref) => wizardInternal2(self2.args, config2).pipe(flatMap10((args2) => update4(ref, appendAll(args2))), repeatN2(n - 1), zipRight3(get11(ref)), tap2((args2) => validateInternal2(self2, args2, config2)))))));
    }
    case "WithDefault": {
      const defaultHelp = p(`This argument is optional - use the default?`);
      const message = pipe(getHelpInternal2(self2.args), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Default ['${JSON.stringify(self2.fallback)}']`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap10((useFallback) => useFallback ? succeed8(empty3()) : wizardInternal2(self2.args, config2)));
    }
    case "WithFallbackConfig": {
      const defaultHelp = p(`Try load this option from the environment?`);
      const message = pipe(getHelpInternal2(self2.args), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Use environment variables`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap10((useFallback) => useFallback ? succeed8(empty3()) : wizardInternal2(self2.args, config2)));
    }
  }
};
var getShortDescription = (self2) => {
  switch (self2._tag) {
    case "Empty":
    case "Both": {
      return "";
    }
    case "Single": {
      return getText(getSpan(self2.description));
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getShortDescription(self2.args);
    }
  }
};
var getFishCompletions2 = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty3();
    }
    case "Single": {
      const description = getShortDescription(self2);
      return pipe(getFishCompletions(self2.primitiveType), appendAll(description.length === 0 ? empty3() : of(`-d '${description}'`)), join(" "), of);
    }
    case "Both": {
      return pipe(getFishCompletions2(self2.left), appendAll(getFishCompletions2(self2.right)));
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getFishCompletions2(self2.args);
    }
  }
};
var getZshCompletions2 = (self2, state = {
  multiple: false,
  optional: false
}) => {
  switch (self2._tag) {
    case "Empty": {
      return empty3();
    }
    case "Single": {
      const multiple = state.multiple ? "*" : "";
      const optional3 = state.optional ? "::" : ":";
      const shortDescription = getShortDescription(self2);
      const description = shortDescription.length > 0 ? ` -- ${shortDescription}` : "";
      const possibleValues = getZshCompletions(self2.primitiveType);
      return possibleValues.length === 0 ? empty3() : of(`${multiple}${optional3}${self2.name}${description}${possibleValues}`);
    }
    case "Map": {
      return getZshCompletions2(self2.args, state);
    }
    case "Both": {
      const left3 = getZshCompletions2(self2.left, state);
      const right3 = getZshCompletions2(self2.right, state);
      return appendAll(left3, right3);
    }
    case "Variadic": {
      return isSome2(self2.max) && self2.max.value > 1 ? getZshCompletions2(self2.args, {
        ...state,
        multiple: true
      }) : getZshCompletions2(self2.args, state);
    }
    case "WithDefault":
    case "WithFallbackConfig": {
      return getZshCompletions2(self2.args, {
        ...state,
        optional: true
      });
    }
  }
};

// node_modules/@effect/cli/dist/esm/Args.js
var ArgsTypeId2 = ArgsTypeId;
var isArgs2 = isArgs;
var all10 = all9;
var atLeast2 = atLeast;
var atMost2 = atMost;
var between6 = between5;
var boolean7 = boolean6;
var choice4 = choice3;
var date5 = date4;
var directory2 = directory;
var file3 = file2;
var fileContent2 = fileContent;
var fileParse2 = fileParse;
var fileSchema2 = fileSchema;
var fileText2 = fileText;
var float4 = float3;
var getHelp4 = getHelp3;
var getIdentifier2 = getIdentifier;
var getMinSize2 = getMinSize;
var getMaxSize2 = getMaxSize;
var getUsage2 = getUsage;
var integer6 = integer5;
var map33 = map32;
var mapEffect7 = mapEffect6;
var mapTryCatch2 = mapTryCatch;
var optional3 = optional2;
var none12 = none11;
var path3 = path2;
var repeated4 = repeated3;
var redacted4 = redacted3;
var secret4 = secret3;
var text8 = text7;
var validate7 = validate6;
var withDefault4 = withDefault3;
var withFallbackConfig2 = withFallbackConfig;
var withDescription4 = withDescription3;
var withSchema2 = withSchema;
var wizard3 = wizard2;
// node_modules/@effect/cli/dist/esm/internal/autoCorrect.js
var levensteinDistance = (first3, second, config2) => {
  if (first3.length === 0 && second.length === 0) {
    return 0;
  }
  if (first3.length === 0) {
    return second.length;
  }
  if (second.length === 0) {
    return first3.length;
  }
  const rowCount = first3.length;
  const columnCount = second.length;
  const matrix = new Array(rowCount);
  const normalFirst = normalizeCase(config2, first3);
  const normalSecond = normalizeCase(config2, second);
  for (let x = 0;x <= rowCount; x++) {
    matrix[x] = new Array(columnCount);
    matrix[x][0] = x;
  }
  for (let y = 0;y <= columnCount; y++) {
    matrix[0][y] = y;
  }
  for (let row = 1;row <= rowCount; row++) {
    for (let col = 1;col <= columnCount; col++) {
      const cost = normalFirst.charAt(row - 1) === normalSecond.charAt(col - 1) ? 0 : 1;
      matrix[row][col] = Math.min(matrix[row][col - 1] + 1, Math.min(matrix[row - 1][col] + 1, matrix[row - 1][col - 1] + cost));
    }
  }
  return matrix[rowCount][columnCount];
};
// node_modules/@effect/cli/dist/esm/internal/prompt/list.js
var list3 = (options3) => text5(options3).pipe(map31((output) => output.split(options3.delimiter || ",")));

// node_modules/@effect/cli/dist/esm/internal/options.js
var OptionsSymbolKey = "@effect/cli/Options";
var OptionsTypeId = /* @__PURE__ */ Symbol.for(OptionsSymbolKey);
var proto22 = {
  [OptionsTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isOptions = (u) => typeof u === "object" && u != null && (OptionsTypeId in u);
var isInstruction2 = (self2) => self2;
var isEmpty20 = (self2) => self2._tag === "Empty";
var isSingle2 = (self2) => self2._tag === "Single";
var isWithDefault2 = (self2) => self2._tag === "WithDefault";
var all11 = function() {
  if (arguments.length === 1) {
    if (isOptions(arguments[0])) {
      return map34(arguments[0], (x) => [x]);
    } else if (isArray(arguments[0])) {
      return allTupled2(arguments[0]);
    } else {
      const entries2 = Object.entries(arguments[0]);
      let result = map34(entries2[0][1], (value6) => ({
        [entries2[0][0]]: value6
      }));
      if (entries2.length === 1) {
        return result;
      }
      const rest = entries2.slice(1);
      for (const [key, options3] of rest) {
        result = map34(makeBoth2(result, options3), ([record2, value6]) => ({
          ...record2,
          [key]: value6
        }));
      }
      return result;
    }
  }
  return allTupled2(arguments[0]);
};
var defaultBooleanOptions = {
  ifPresent: true,
  negationNames: [],
  aliases: []
};
var boolean8 = (name, options3) => {
  const {
    aliases,
    ifPresent,
    negationNames
  } = {
    ...defaultBooleanOptions,
    ...options3
  };
  const option6 = makeSingle2(name, aliases, boolean5(some2(ifPresent)));
  if (isNonEmptyReadonlyArray(negationNames)) {
    const head6 = headNonEmpty(negationNames);
    const tail2 = tailNonEmpty(negationNames);
    const negationOption = makeSingle2(head6, tail2, boolean5(some2(!ifPresent)));
    return withDefault5(orElse14(option6, negationOption), !ifPresent);
  }
  return withDefault5(option6, !ifPresent);
};
var choice5 = (name, choices) => {
  const primitive2 = choice2(map5(choices, (choice6) => [choice6, choice6]));
  return makeSingle2(name, empty3(), primitive2);
};
var choiceWithValue = (name, choices) => makeSingle2(name, empty3(), choice2(choices));
var date6 = (name) => makeSingle2(name, empty3(), date3);
var directory3 = (name, config2) => makeSingle2(name, empty3(), path("directory", config2?.exists ?? "either"));
var file4 = (name, config2) => makeSingle2(name, empty3(), path("file", config2?.exists ?? "either"));
var fileContent3 = (name) => mapEffect8(file4(name, {
  exists: "yes"
}), (path4) => mapError2(read2(path4), (msg) => invalidValue(p(msg))));
var fileParse3 = (name, format8) => mapEffect8(fileText3(name), ([path4, content]) => mapError2(parse5(path4, content, format8), (error4) => invalidValue(p(error4))));
var fileSchema3 = (name, schema, format8) => withSchema3(fileParse3(name, format8), schema);
var fileText3 = (name) => mapEffect8(file4(name, {
  exists: "yes"
}), (path4) => mapError2(readString(path4), (error4) => invalidValue(p(error4))));
var filterMap9 = /* @__PURE__ */ dual(3, (self2, f, message) => mapEffect8(self2, (a) => match2(f(a), {
  onNone: () => left2(invalidValue(p(message))),
  onSome: right2
})));
var float5 = (name) => makeSingle2(name, empty3(), float2);
var integer7 = (name) => makeSingle2(name, empty3(), integer4);
var keyValueMap = (option6) => {
  if (typeof option6 === "string") {
    const single2 = makeSingle2(option6, empty3(), text6);
    return makeKeyValueMap(single2);
  }
  if (!isSingle2(option6)) {
    throw new Error("InvalidArgumentException: only single options can be key/value maps");
  } else {
    return makeKeyValueMap(option6);
  }
};
var none13 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto22);
  op._tag = "Empty";
  return op;
})();
var redacted5 = (name) => makeSingle2(name, empty3(), redacted2);
var secret5 = (name) => makeSingle2(name, empty3(), secret2);
var text9 = (name) => makeSingle2(name, empty3(), text6);
var atLeast3 = /* @__PURE__ */ dual(2, (self2, times2) => makeVariadic2(self2, some2(times2), none2()));
var atMost3 = /* @__PURE__ */ dual(2, (self2, times2) => makeVariadic2(self2, none2(), some2(times2)));
var between7 = /* @__PURE__ */ dual(3, (self2, min7, max9) => makeVariadic2(self2, some2(min7), some2(max9)));
var isBool2 = (self2) => isBoolInternal(self2);
var getHelp5 = (self2) => getHelpInternal3(self2);
var getIdentifier3 = (self2) => getIdentifierInternal2(self2);
var getUsage3 = (self2) => getUsageInternal2(self2);
var map34 = /* @__PURE__ */ dual(2, (self2, f) => makeMap2(self2, (a) => right2(f(a))));
var mapEffect8 = /* @__PURE__ */ dual(2, (self2, f) => makeMap2(self2, f));
var mapTryCatch3 = /* @__PURE__ */ dual(3, (self2, f, onError5) => mapEffect8(self2, (a) => {
  try {
    return right2(f(a));
  } catch (e) {
    return left2(invalidValue(onError5(e)));
  }
}));
var optional4 = (self2) => withDefault5(map34(self2, some2), none2());
var orElse14 = /* @__PURE__ */ dual(2, (self2, that) => orElseEither5(self2, that).pipe(map34(merge)));
var orElseEither5 = /* @__PURE__ */ dual(2, (self2, that) => makeOrElse(self2, that));
var parse6 = /* @__PURE__ */ dual(3, (self2, args2, config2) => parseInternal(self2, args2, config2));
var processCommandLine = /* @__PURE__ */ dual(3, (self2, args2, config2) => matchOptions(args2, toParseableInstruction(self2), config2).pipe(flatMap10(([error4, commandArgs, matchedOptions]) => parseInternal(self2, matchedOptions, config2).pipe(catchAll2((e) => match2(error4, {
  onNone: () => fail8(e),
  onSome: (err) => fail8(err)
})), map17((a) => [error4, commandArgs, a])))));
var repeated5 = (self2) => makeVariadic2(self2, none2(), none2());
var withAlias = /* @__PURE__ */ dual(2, (self2, alias) => modifySingle(self2, (single2) => {
  const aliases = append(single2.aliases, alias);
  return makeSingle2(single2.name, aliases, single2.primitiveType, single2.description, single2.pseudoName);
}));
var withDefault5 = /* @__PURE__ */ dual(2, (self2, fallback) => makeWithDefault2(self2, fallback));
var withFallbackConfig3 = /* @__PURE__ */ dual(2, (self2, config2) => {
  if (isInstruction2(self2) && isWithDefault2(self2)) {
    return makeWithDefault2(withFallbackConfig3(self2.options, config2), self2.fallback);
  }
  return makeWithFallback(self2, config2);
});
var withFallbackPrompt = /* @__PURE__ */ dual(2, (self2, prompt) => {
  if (isInstruction2(self2) && isWithDefault2(self2)) {
    return makeWithDefault2(withFallbackPrompt(self2.options, prompt), self2.fallback);
  }
  return makeWithFallback(self2, prompt);
});
var withDescription5 = /* @__PURE__ */ dual(2, (self2, desc) => modifySingle(self2, (single2) => {
  const description = sequence(single2.description, p(desc));
  return makeSingle2(single2.name, single2.aliases, single2.primitiveType, description, single2.pseudoName);
}));
var withPseudoName = /* @__PURE__ */ dual(2, (self2, pseudoName) => modifySingle(self2, (single2) => makeSingle2(single2.name, single2.aliases, single2.primitiveType, single2.description, some2(pseudoName))));
var withSchema3 = /* @__PURE__ */ dual(2, (self2, schema) => {
  const decode7 = decode2(schema);
  return mapEffect8(self2, (_) => mapError2(decode7(_), (issue) => invalidValue(p(TreeFormatter.formatIssueSync(issue)))));
});
var wizard4 = /* @__PURE__ */ dual(2, (self2, config2) => wizardInternal3(self2, config2));
var allTupled2 = (arg) => {
  if (arg.length === 0) {
    return none13;
  }
  if (arg.length === 1) {
    return map34(arg[0], (x) => [x]);
  }
  let result = map34(arg[0], (x) => [x]);
  for (let i = 1;i < arg.length; i++) {
    const curr = arg[i];
    result = map34(makeBoth2(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
var getHelpInternal3 = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty42;
    }
    case "Single": {
      return descriptionList(of([getSpan(getHelp2(getUsageInternal2(self2))), sequence(p(getHelp(self2.primitiveType)), self2.description)]));
    }
    case "KeyValueMap": {
      const identifier2 = getOrThrow2(getIdentifierInternal2(self2.argumentOption));
      return mapDescriptionList(getHelpInternal3(self2.argumentOption), (span3, oldBlock) => {
        const header = p("This setting is a property argument which:");
        const single2 = `${identifier2} key1=value key2=value2`;
        const multiple = `${identifier2} key1=value ${identifier2} key2=value2`;
        const description = enumeration([p(`May be specified a single time:  '${single2}'`), p(`May be specified multiple times: '${multiple}'`)]);
        const newBlock = pipe(oldBlock, sequence(header), sequence(description));
        return [span3, newBlock];
      });
    }
    case "Map": {
      return getHelpInternal3(self2.options);
    }
    case "Both":
    case "OrElse": {
      return sequence(getHelpInternal3(self2.left), getHelpInternal3(self2.right));
    }
    case "Variadic": {
      const help = getHelpInternal3(self2.argumentOption);
      return mapDescriptionList(help, (oldSpan, oldBlock) => {
        const min7 = getMinSizeInternal2(self2);
        const max9 = getMaxSizeInternal2(self2);
        const newSpan = text4(isSome2(self2.max) ? ` ${min7} - ${max9}` : min7 === 0 ? "..." : ` ${min7}+`);
        const newBlock = p(isSome2(self2.max) ? `This option must be repeated at least ${min7} times and may be repeated up to ${max9} times.` : min7 === 0 ? "This option may be repeated zero or more times." : `This option must be repeated at least ${min7} times.`);
        return [concat4(oldSpan, newSpan), sequence(oldBlock, newBlock)];
      });
    }
    case "WithDefault": {
      return mapDescriptionList(getHelpInternal3(self2.options), (span3, block) => {
        const optionalDescription = isOption2(self2.fallback) ? match2(self2.fallback, {
          onNone: () => p("This setting is optional."),
          onSome: (fallbackValue) => {
            const inspectableValue = isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
            const displayValue = toStringUnknown(inspectableValue, 0);
            return p(`This setting is optional. Defaults to: ${displayValue}`);
          }
        }) : p("This setting is optional.");
        return [span3, sequence(block, optionalDescription)];
      });
    }
    case "WithFallback": {
      const helpDoc = isConfig2(self2.effect) ? p("This option can be set from environment variables.") : isPrompt(self2.effect) ? p("Will prompt the user for input if this option is not provided.") : empty42;
      return mapDescriptionList(getHelpInternal3(self2.options), (span3, block) => [span3, sequence(block, helpDoc)]);
    }
  }
};
var getIdentifierInternal2 = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return none2();
    }
    case "Single": {
      return some2(self2.fullName);
    }
    case "Both":
    case "OrElse": {
      const ids3 = getSomes([getIdentifierInternal2(self2.left), getIdentifierInternal2(self2.right)]);
      return match3(ids3, {
        onEmpty: () => none2(),
        onNonEmpty: (ids4) => some2(join(ids4, ", "))
      });
    }
    case "KeyValueMap":
    case "Variadic": {
      return getIdentifierInternal2(self2.argumentOption);
    }
    case "Map":
    case "WithFallback":
    case "WithDefault": {
      return getIdentifierInternal2(self2.options);
    }
  }
};
var getMinSizeInternal2 = (self2) => {
  switch (self2._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallback": {
      return 0;
    }
    case "Single":
    case "KeyValueMap": {
      return 1;
    }
    case "Map": {
      return getMinSizeInternal2(self2.options);
    }
    case "Both": {
      const leftMinSize = getMinSizeInternal2(self2.left);
      const rightMinSize = getMinSizeInternal2(self2.right);
      return leftMinSize + rightMinSize;
    }
    case "OrElse": {
      const leftMinSize = getMinSizeInternal2(self2.left);
      const rightMinSize = getMinSizeInternal2(self2.right);
      return Math.min(leftMinSize, rightMinSize);
    }
    case "Variadic": {
      const selfMinSize = getOrElse(self2.min, () => 0);
      const argumentOptionMinSize = getMinSizeInternal2(self2.argumentOption);
      return selfMinSize * argumentOptionMinSize;
    }
  }
};
var getMaxSizeInternal2 = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "KeyValueMap": {
      return Number.MAX_SAFE_INTEGER;
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getMaxSizeInternal2(self2.options);
    }
    case "Both": {
      const leftMaxSize = getMaxSizeInternal2(self2.left);
      const rightMaxSize = getMaxSizeInternal2(self2.right);
      return leftMaxSize + rightMaxSize;
    }
    case "OrElse": {
      const leftMin = getMaxSizeInternal2(self2.left);
      const rightMin = getMaxSizeInternal2(self2.right);
      return Math.min(leftMin, rightMin);
    }
    case "Variadic": {
      const selfMaxSize = getOrElse(self2.max, () => Number.MAX_SAFE_INTEGER / 2);
      const optionsMaxSize = getMaxSizeInternal2(self2.argumentOption);
      return Math.floor(selfMaxSize * optionsMaxSize);
    }
  }
};
var getUsageInternal2 = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty43;
    }
    case "Single": {
      const acceptedValues = isBool(self2.primitiveType) ? none2() : orElse(getChoices(self2.primitiveType), () => some2(self2.placeholder));
      return named(getNames(self2), acceptedValues);
    }
    case "KeyValueMap": {
      return getUsageInternal2(self2.argumentOption);
    }
    case "Map": {
      return getUsageInternal2(self2.options);
    }
    case "Both": {
      return concat5(getUsageInternal2(self2.left), getUsageInternal2(self2.right));
    }
    case "OrElse": {
      return alternation(getUsageInternal2(self2.left), getUsageInternal2(self2.right));
    }
    case "Variadic": {
      return repeated2(getUsageInternal2(self2.argumentOption));
    }
    case "WithDefault":
    case "WithFallback": {
      return optional(getUsageInternal2(self2.options));
    }
  }
};
var isBoolInternal = (self2) => {
  switch (self2._tag) {
    case "Single": {
      return isBool(self2.primitiveType);
    }
    case "Map": {
      return isBoolInternal(self2.options);
    }
    case "WithDefault": {
      return isBoolInternal(self2.options);
    }
    default: {
      return false;
    }
  }
};
var makeBoth2 = (left3, right3) => {
  const op = Object.create(proto22);
  op._tag = "Both";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeFullName = (str) => str.length === 1 ? [true, `-${str}`] : [false, `--${str}`];
var makeKeyValueMap = (argumentOption) => {
  const op = Object.create(proto22);
  op._tag = "KeyValueMap";
  op.argumentOption = argumentOption;
  return op;
};
var makeMap2 = (options3, f) => {
  const op = Object.create(proto22);
  op._tag = "Map";
  op.options = options3;
  op.f = f;
  return op;
};
var makeOrElse = (left3, right3) => {
  const op = Object.create(proto22);
  op._tag = "OrElse";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeSingle2 = (name, aliases, primitiveType, description = empty42, pseudoName = none2()) => {
  const op = Object.create(proto22);
  op._tag = "Single";
  op.name = name;
  op.fullName = makeFullName(name)[1];
  op.placeholder = `${getOrElse(pseudoName, () => getTypeName(primitiveType))}`;
  op.aliases = aliases;
  op.primitiveType = primitiveType;
  op.description = description;
  op.pseudoName = pseudoName;
  return op;
};
var makeVariadic2 = (argumentOption, min7, max9) => {
  if (!isSingle2(argumentOption)) {
    throw new Error("InvalidArgumentException: only single options can be variadic");
  }
  const op = Object.create(proto22);
  op._tag = "Variadic";
  op.argumentOption = argumentOption;
  op.min = min7;
  op.max = max9;
  return op;
};
var makeWithDefault2 = (options3, fallback) => {
  const op = Object.create(proto22);
  op._tag = "WithDefault";
  op.options = options3;
  op.fallback = fallback;
  return op;
};
var makeWithFallback = (options3, effect4) => {
  const op = Object.create(proto22);
  op._tag = "WithFallback";
  op.options = options3;
  op.effect = effect4;
  return op;
};
var modifySingle = (self2, f) => {
  switch (self2._tag) {
    case "Empty": {
      return none13;
    }
    case "Single": {
      return f(self2);
    }
    case "KeyValueMap": {
      return makeKeyValueMap(f(self2.argumentOption));
    }
    case "Map": {
      return makeMap2(modifySingle(self2.options, f), self2.f);
    }
    case "Both": {
      return makeBoth2(modifySingle(self2.left, f), modifySingle(self2.right, f));
    }
    case "OrElse": {
      return makeOrElse(modifySingle(self2.left, f), modifySingle(self2.right, f));
    }
    case "Variadic": {
      return makeVariadic2(f(self2.argumentOption), self2.min, self2.max);
    }
    case "WithDefault": {
      return makeWithDefault2(modifySingle(self2.options, f), self2.fallback);
    }
    case "WithFallback": {
      return makeWithFallback(modifySingle(self2.options, f), self2.effect);
    }
  }
};
var getNames = (self2) => {
  const loop3 = (self3) => {
    switch (self3._tag) {
      case "Empty": {
        return empty3();
      }
      case "Single": {
        return prepend(self3.aliases, self3.name);
      }
      case "KeyValueMap":
      case "Variadic": {
        return loop3(self3.argumentOption);
      }
      case "Map":
      case "WithDefault":
      case "WithFallback": {
        return loop3(self3.options);
      }
      case "Both":
      case "OrElse": {
        const left3 = loop3(self3.left);
        const right3 = loop3(self3.right);
        return appendAll(left3, right3);
      }
    }
  };
  const order = mapInput2(boolean, (tuple6) => !tuple6[0]);
  return pipe(loop3(self2), map5((str) => makeFullName(str)), sort(order), map5((tuple6) => tuple6[1]));
};
var toParseableInstruction = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty3();
    }
    case "Single":
    case "KeyValueMap":
    case "Variadic": {
      return of(self2);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return toParseableInstruction(self2.options);
    }
    case "Both":
    case "OrElse": {
      return appendAll(toParseableInstruction(self2.left), toParseableInstruction(self2.right));
    }
  }
};
var keyValueSplitter = /=(.*)/;
var parseInternal = (self2, args2, config2) => {
  switch (self2._tag) {
    case "Empty": {
      return _void;
    }
    case "Single": {
      const singleNames = filterMap2(getNames(self2), (name) => get7(args2, name));
      if (isNonEmptyReadonlyArray(singleNames)) {
        const head6 = headNonEmpty(singleNames);
        const tail2 = tailNonEmpty(singleNames);
        if (isEmptyReadonlyArray(tail2)) {
          if (isEmptyReadonlyArray(head6)) {
            return validate5(self2.primitiveType, none2(), config2).pipe(mapError2((e) => invalidValue(p(e))));
          }
          if (isNonEmptyReadonlyArray(head6) && isEmptyReadonlyArray(tailNonEmpty(head6))) {
            const value6 = headNonEmpty(head6);
            return validate5(self2.primitiveType, some2(value6), config2).pipe(mapError2((e) => invalidValue(p(e))));
          }
          return fail8(multipleValuesDetected(empty42, head6));
        }
        const error5 = p(`More than one reference to option '${self2.fullName}' detected`);
        return fail8(invalidValue(error5));
      }
      const error4 = p(`Expected to find option: '${self2.fullName}'`);
      return fail8(missingValue(error4));
    }
    case "KeyValueMap": {
      const extractKeyValue = (value6) => {
        const split4 = value6.trim().split(keyValueSplitter, 2);
        if (isNonEmptyReadonlyArray(split4) && split4.length === 2 && split4[1] !== "") {
          return succeed8(split4);
        }
        const error4 = p(`Expected a key/value pair but received '${value6}'`);
        return fail8(invalidArgument(error4));
      };
      return parseInternal(self2.argumentOption, args2, config2).pipe(matchEffect2({
        onFailure: (e) => isMultipleValuesDetected(e) ? forEach9(e.values, (kv) => extractKeyValue(kv)).pipe(map17(fromIterable6)) : fail8(e),
        onSuccess: (kv) => extractKeyValue(kv).pipe(map17(make16))
      }));
    }
    case "Map": {
      return parseInternal(self2.options, args2, config2).pipe(flatMap10((a) => self2.f(a)));
    }
    case "Both": {
      return parseInternal(self2.left, args2, config2).pipe(catchAll2((err1) => parseInternal(self2.right, args2, config2).pipe(matchEffect2({
        onFailure: (err2) => {
          const error4 = sequence(err1.error, err2.error);
          return fail8(missingValue(error4));
        },
        onSuccess: () => fail8(err1)
      }))), zip5(parseInternal(self2.right, args2, config2)));
    }
    case "OrElse": {
      return parseInternal(self2.left, args2, config2).pipe(matchEffect2({
        onFailure: (err1) => parseInternal(self2.right, args2, config2).pipe(mapBoth4({
          onFailure: (err2) => isMissingValue(err1) && isMissingValue(err2) ? missingValue(sequence(err1.error, err2.error)) : invalidValue(sequence(err1.error, err2.error)),
          onSuccess: (b) => right2(b)
        })),
        onSuccess: (a) => parseInternal(self2.right, args2, config2).pipe(matchEffect2({
          onFailure: () => succeed8(left2(a)),
          onSuccess: () => {
            const leftUid = getOrElse(getIdentifierInternal2(self2.left), () => "???");
            const rightUid = getOrElse(getIdentifierInternal2(self2.right), () => "???");
            const error4 = p("Collision between two options detected - you can only specify " + `one of either: ['${leftUid}', '${rightUid}']`);
            return fail8(invalidValue(error4));
          }
        }))
      }));
    }
    case "Variadic": {
      const min7 = getOrElse(self2.min, () => 0);
      const max9 = getOrElse(self2.max, () => Number.MAX_SAFE_INTEGER);
      const matchedArgument = filterMap2(getNames(self2), (name) => get7(args2, name));
      const validateMinMax = (values4) => {
        if (values4.length < min7) {
          const name = self2.argumentOption.fullName;
          const error4 = `Expected at least ${min7} value(s) for option: '${name}'`;
          return fail8(invalidValue(p(error4)));
        }
        if (values4.length > max9) {
          const name = self2.argumentOption.fullName;
          const error4 = `Expected at most ${max9} value(s) for option: '${name}'`;
          return fail8(invalidValue(p(error4)));
        }
        const primitive2 = self2.argumentOption.primitiveType;
        const validatePrimitive = (value6) => validate5(primitive2, some2(value6), config2).pipe(mapError2((e) => invalidValue(p(e))));
        return forEach9(values4, (value6) => validatePrimitive(value6));
      };
      if (every(matchedArgument, isEmptyReadonlyArray)) {
        return validateMinMax(empty3());
      }
      return parseInternal(self2.argumentOption, args2, config2).pipe(matchEffect2({
        onFailure: (error4) => isMultipleValuesDetected(error4) ? validateMinMax(error4.values) : fail8(error4),
        onSuccess: (value6) => validateMinMax(of(value6))
      }));
    }
    case "WithDefault": {
      return parseInternal(self2.options, args2, config2).pipe(catchTag2("MissingValue", () => succeed8(self2.fallback)));
    }
    case "WithFallback": {
      return parseInternal(self2.options, args2, config2).pipe(catchTag2("MissingValue", (e) => self2.effect.pipe(catchAll2((e2) => {
        if (isTagged(e2, "QuitException")) {
          return die5(e2);
        }
        if (isConfigError2(e2) && !isMissingDataOnly2(e2)) {
          const help = p(String(e2));
          const error4 = invalidValue(help);
          return fail8(error4);
        }
        return fail8(e);
      }))));
    }
  }
};
var wizardInternal3 = (self2, config2) => {
  switch (self2._tag) {
    case "Empty": {
      return succeed8(empty3());
    }
    case "Single": {
      const help = getHelpInternal3(self2);
      return wizard(self2.primitiveType, help).pipe(flatMap10((input) => {
        const args2 = make4(getNames(self2)[0], input);
        return parseCommandLine(self2, args2, config2).pipe(as3(args2));
      }), zipLeft2(log3()));
    }
    case "KeyValueMap": {
      const message = p("Enter `key=value` pairs separated by spaces");
      return list3({
        message: toAnsiText(message).trim(),
        delimiter: " "
      }).pipe(flatMap10((args2) => {
        const identifier2 = getOrElse(getIdentifierInternal2(self2), () => "");
        return parseInternal(self2, make16([identifier2, args2]), config2).pipe(as3(prepend(args2, identifier2)));
      }), zipLeft2(log3()));
    }
    case "Map": {
      return wizardInternal3(self2.options, config2);
    }
    case "Both": {
      return zipWith7(wizardInternal3(self2.left, config2), wizardInternal3(self2.right, config2), (left3, right3) => appendAll(left3, right3));
    }
    case "OrElse": {
      const alternativeHelp = p("Select which option you would like to use");
      const message = pipe(getHelpInternal3(self2), sequence(alternativeHelp));
      const makeChoice = (title, value6) => ({
        title,
        value: value6
      });
      const choices = getSomes([map2(getIdentifierInternal2(self2.left), (title) => makeChoice(title, self2.left)), map2(getIdentifierInternal2(self2.right), (title) => makeChoice(title, self2.right))]);
      return select({
        message: toAnsiText(message).trimEnd(),
        choices
      }).pipe(flatMap10((option6) => wizardInternal3(option6, config2)));
    }
    case "Variadic": {
      const repeatHelp = p("How many times should this argument be repeated?");
      const message = pipe(getHelpInternal3(self2), sequence(repeatHelp));
      return integer3({
        message: toAnsiText(message).trimEnd(),
        min: getMinSizeInternal2(self2),
        max: getMaxSizeInternal2(self2)
      }).pipe(flatMap10((n) => n <= 0 ? succeed8(empty3()) : make26(empty3()).pipe(flatMap10((ref) => wizardInternal3(self2.argumentOption, config2).pipe(flatMap10((args2) => update4(ref, appendAll(args2))), repeatN2(n - 1), zipRight3(get11(ref)))))));
    }
    case "WithDefault": {
      if (isBoolInternal(self2.options)) {
        return wizardInternal3(self2.options, config2);
      }
      const defaultHelp = p(`This option is optional - use the default?`);
      const message = pipe(getHelpInternal3(self2.options), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: "Yes",
          value: true,
          description: `use the default ${isOption2(self2.fallback) ? match2(self2.fallback, {
            onNone: () => "",
            onSome: (a) => `(${JSON.stringify(a)})`
          }) : `(${JSON.stringify(self2.fallback)})`}`
        }, {
          title: "No",
          value: false,
          description: "use a custom value"
        }]
      }).pipe(zipLeft2(log3()), flatMap10((useFallback) => useFallback ? succeed8(empty3()) : wizardInternal3(self2.options, config2)));
    }
    case "WithFallback": {
      if (isBoolInternal(self2.options)) {
        return wizardInternal3(self2.options, config2);
      }
      if (isPrompt(self2.effect)) {
        return wizardInternal3(self2.options, config2);
      }
      const defaultHelp = p(`Try load this option from the environment?`);
      const message = pipe(getHelpInternal3(self2.options), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Use environment variables`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log3()), flatMap10((useFallback) => useFallback ? succeed8(empty3()) : wizardInternal3(self2.options, config2)));
    }
  }
};
var matchOptions = (input, options3, config2) => {
  if (isNonEmptyReadonlyArray(options3)) {
    return findOptions(input, options3, config2).pipe(flatMap10(([otherArgs, otherOptions, map1]) => {
      if (isEmpty3(map1)) {
        return succeed8([none2(), input, map1]);
      }
      return matchOptions(otherArgs, otherOptions, config2).pipe(map17(([error4, otherArgs2, map210]) => [error4, otherArgs2, merge11(map1, fromIterable(map210))]));
    }), catchAll2((e) => succeed8([some2(e), input, empty10()])));
  }
  return isEmptyReadonlyArray(input) ? succeed8([none2(), empty3(), empty10()]) : succeed8([none2(), input, empty10()]);
};
var findOptions = (input, options3, config2) => matchLeft(options3, {
  onEmpty: () => succeed8([input, empty3(), empty10()]),
  onNonEmpty: (head6, tail2) => parseCommandLine(head6, input, config2).pipe(flatMap10(({
    leftover: leftover2,
    parsed
  }) => match2(parsed, {
    onNone: () => findOptions(leftover2, tail2, config2).pipe(map17(([nextArgs, nextOptions, map35]) => [nextArgs, prepend(nextOptions, head6), map35])),
    onSome: ({
      name,
      values: values4
    }) => succeed8([leftover2, tail2, make16([name, values4])])
  })), catchTags2({
    CorrectedFlag: (e) => findOptions(input, tail2, config2).pipe(catchSome2(() => some2(fail8(e))), flatMap10(([otherArgs, otherOptions, map35]) => fail8(e).pipe(when2(() => isEmpty3(map35)), as3([otherArgs, prepend(otherOptions, head6), map35])))),
    MissingFlag: () => findOptions(input, tail2, config2).pipe(map17(([otherArgs, otherOptions, map35]) => [otherArgs, prepend(otherOptions, head6), map35])),
    UnclusteredFlag: (e) => matchUnclustered(e.unclustered, e.rest, options3, config2).pipe(catchAll2(() => fail8(e)))
  }))
});
var CLUSTERED_REGEX = /^-{1}([^-]{2,}$)/;
var FLAG_REGEX = /^(--[^=]+)(?:=(.+))?$/;
var processArgs = (args2) => matchLeft(args2, {
  onEmpty: () => succeed8(empty3()),
  onNonEmpty: (head6, tail2) => {
    const value6 = head6.trim();
    if (CLUSTERED_REGEX.test(value6)) {
      const unclustered = value6.substring(1).split("").map((c) => `-${c}`);
      return fail8(unclusteredFlag(empty42, unclustered, tail2));
    }
    if (FLAG_REGEX.test(value6)) {
      const result = FLAG_REGEX.exec(value6);
      if (result !== null && result[2] !== undefined) {
        return succeed8(appendAll([result[1], result[2]], tail2));
      }
    }
    return succeed8(args2);
  }
});
var parseCommandLine = (self2, args2, config2) => {
  switch (self2._tag) {
    case "Single": {
      return processArgs(args2).pipe(flatMap10((args3) => matchLeft(args3, {
        onEmpty: () => {
          const error4 = p(`Expected to find option: '${self2.fullName}'`);
          return fail8(missingFlag(error4));
        },
        onNonEmpty: (head6, tail2) => {
          const normalize2 = (value6) => normalizeCase(config2, value6);
          const normalizedHead = normalize2(head6);
          const normalizedNames = map5(getNames(self2), (name) => normalize2(name));
          if (contains2(normalizedNames, normalizedHead)) {
            if (isBool(self2.primitiveType)) {
              return matchLeft(tail2, {
                onEmpty: () => {
                  const parsed = some2({
                    name: head6,
                    values: empty3()
                  });
                  return succeed8({
                    parsed,
                    leftover: tail2
                  });
                },
                onNonEmpty: (value6, leftover2) => {
                  if (isTrueValue(value6)) {
                    const parsed2 = some2({
                      name: head6,
                      values: of("true")
                    });
                    return succeed8({
                      parsed: parsed2,
                      leftover: leftover2
                    });
                  }
                  if (isFalseValue(value6)) {
                    const parsed2 = some2({
                      name: head6,
                      values: of("false")
                    });
                    return succeed8({
                      parsed: parsed2,
                      leftover: leftover2
                    });
                  }
                  const parsed = some2({
                    name: head6,
                    values: empty3()
                  });
                  return succeed8({
                    parsed,
                    leftover: tail2
                  });
                }
              });
            }
            return matchLeft(tail2, {
              onEmpty: () => {
                const error5 = p(`Expected a value following option: '${self2.fullName}'`);
                return fail8(missingValue(error5));
              },
              onNonEmpty: (value6, leftover2) => {
                const parsed = some2({
                  name: head6,
                  values: of(value6)
                });
                return succeed8({
                  parsed,
                  leftover: leftover2
                });
              }
            });
          }
          if (self2.name.length > config2.autoCorrectLimit + 1 && levensteinDistance(head6, self2.fullName, config2) <= config2.autoCorrectLimit) {
            const error5 = p(`The flag '${head6}' is not recognized. Did you mean '${self2.fullName}'?`);
            return fail8(correctedFlag(error5));
          }
          const error4 = p(`Expected to find option: '${self2.fullName}'`);
          return fail8(missingFlag(error4));
        }
      })));
    }
    case "KeyValueMap": {
      const normalizedNames = map5(getNames(self2.argumentOption), (name) => normalizeCase(config2, name));
      return matchLeft(args2, {
        onEmpty: () => succeed8({
          parsed: none2(),
          leftover: args2
        }),
        onNonEmpty: (head6, tail2) => {
          const loop3 = (args3) => {
            let keyValues = empty3();
            let leftover2 = args3;
            while (isNonEmptyReadonlyArray(leftover2)) {
              const name = headNonEmpty(leftover2).trim();
              const normalizedName2 = normalizeCase(config2, name);
              if (leftover2.length >= 2 && contains2(normalizedNames, normalizedName2)) {
                const keyValue = leftover2[1].trim();
                const [key, value6] = keyValue.split("=");
                if (key !== undefined && value6 !== undefined && value6.length > 0) {
                  keyValues = append(keyValues, keyValue);
                  leftover2 = leftover2.slice(2);
                  continue;
                }
              }
              if (name.includes("=")) {
                const [key, value6] = name.split("=");
                if (key !== undefined && value6 !== undefined && value6.length > 0) {
                  keyValues = append(keyValues, name);
                  leftover2 = leftover2.slice(1);
                  continue;
                }
              }
              break;
            }
            return [keyValues, leftover2];
          };
          const normalizedName = normalizeCase(config2, head6);
          if (contains2(normalizedNames, normalizedName)) {
            const [values4, leftover2] = loop3(tail2);
            return succeed8({
              parsed: some2({
                name: head6,
                values: values4
              }),
              leftover: leftover2
            });
          }
          return succeed8({
            parsed: none2(),
            leftover: args2
          });
        }
      });
    }
    case "Variadic": {
      const normalizedNames = map5(getNames(self2.argumentOption), (name) => normalizeCase(config2, name));
      let optionName = undefined;
      let values4 = empty3();
      let unparsed = args2;
      let leftover2 = empty3();
      while (isNonEmptyReadonlyArray(unparsed)) {
        const name = headNonEmpty(unparsed);
        const normalizedName = normalizeCase(config2, name);
        if (contains2(normalizedNames, normalizedName)) {
          if (optionName === undefined) {
            optionName = name;
          }
          const value6 = unparsed[1];
          if (value6 !== undefined && value6.length > 0) {
            values4 = append(values4, value6.trim());
          }
          unparsed = unparsed.slice(2);
        } else {
          leftover2 = append(leftover2, headNonEmpty(unparsed));
          unparsed = unparsed.slice(1);
        }
      }
      const parsed = fromNullable(optionName).pipe(orElse(() => some2(self2.argumentOption.fullName)), map2((name) => ({
        name,
        values: values4
      })));
      return succeed8({
        parsed,
        leftover: leftover2
      });
    }
  }
};
var matchUnclustered = (input, tail2, options3, config2) => {
  if (isNonEmptyReadonlyArray(input)) {
    const flag = headNonEmpty(input);
    const otherFlags = tailNonEmpty(input);
    return findOptions(of(flag), options3, config2).pipe(flatMap10(([_, opts1, map1]) => {
      if (isEmpty3(map1)) {
        return fail8(unclusteredFlag(empty42, empty3(), tail2));
      }
      return matchUnclustered(otherFlags, tail2, opts1, config2).pipe(map17(([_2, opts2, map210]) => [tail2, opts2, merge11(map1, fromIterable(map210))]));
    }));
  }
  return succeed8([tail2, options3, empty10()]);
};
var merge11 = (map1, map210) => {
  if (isNonEmptyReadonlyArray(map210)) {
    const head6 = headNonEmpty(map210);
    const tail2 = tailNonEmpty(map210);
    const newMap = match2(get7(map1, head6[0]), {
      onNone: () => set4(map1, head6[0], head6[1]),
      onSome: (elems) => set4(map1, head6[0], appendAll(elems, head6[1]))
    });
    return merge11(newMap, tail2);
  }
  return map1;
};
var escape2 = (string8) => string8.replaceAll("\\", "\\\\").replaceAll("'", "'\\''").replaceAll("[", "\\[").replaceAll("]", "\\]").replaceAll(":", "\\:").replaceAll("$", "\\$").replaceAll("`", "\\`").replaceAll("(", "\\(").replaceAll(")", "\\)");
var getShortDescription2 = (self2) => {
  switch (self2._tag) {
    case "Empty":
    case "Both":
    case "OrElse": {
      return "";
    }
    case "Single": {
      return getText(getSpan(self2.description));
    }
    case "KeyValueMap":
    case "Variadic": {
      return getShortDescription2(self2.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getShortDescription2(self2.options);
    }
  }
};
var getBashCompletions2 = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty3();
    }
    case "Single": {
      const names = getNames(self2);
      const cases = join(names, "|");
      const compgen = getBashCompletions(self2.primitiveType);
      return make4(`${cases})`, `    COMPREPLY=( ${compgen} )`, `    return 0`, `    ;;`);
    }
    case "KeyValueMap":
    case "Variadic": {
      return getBashCompletions2(self2.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getBashCompletions2(self2.options);
    }
    case "Both":
    case "OrElse": {
      const left3 = getBashCompletions2(self2.left);
      const right3 = getBashCompletions2(self2.right);
      return appendAll(left3, right3);
    }
  }
};
var getFishCompletions3 = (self2) => {
  switch (self2._tag) {
    case "Empty": {
      return empty3();
    }
    case "Single": {
      const description = getShortDescription2(self2);
      const order = mapInput2(boolean, (tuple6) => !tuple6[0]);
      return pipe(prepend(self2.aliases, self2.name), map5((name) => [name.length === 1, name]), sort(order), flatMap2(([isShort, name]) => make4(isShort ? "-s" : "-l", name)), appendAll(getFishCompletions(self2.primitiveType)), appendAll(description.length === 0 ? empty3() : of(`-d '${description}'`)), join(" "), of);
    }
    case "KeyValueMap":
    case "Variadic": {
      return getFishCompletions3(self2.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getFishCompletions3(self2.options);
    }
    case "Both":
    case "OrElse": {
      return pipe(getFishCompletions3(self2.left), appendAll(getFishCompletions3(self2.right)));
    }
  }
};
var getZshCompletions3 = (self2, state = {
  conflicts: empty3(),
  multiple: false
}) => {
  switch (self2._tag) {
    case "Empty": {
      return empty3();
    }
    case "Single": {
      const names = getNames(self2);
      const description = getShortDescription2(self2);
      const possibleValues = getZshCompletions(self2.primitiveType);
      const multiple = state.multiple ? "*" : "";
      const conflicts = isNonEmptyReadonlyArray(state.conflicts) ? `(${join(state.conflicts, " ")})` : "";
      return map5(names, (name) => `${conflicts}${multiple}${name}[${escape2(description)}]${possibleValues}`);
    }
    case "KeyValueMap": {
      return getZshCompletions3(self2.argumentOption, {
        ...state,
        multiple: true
      });
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getZshCompletions3(self2.options, state);
    }
    case "Both": {
      const left3 = getZshCompletions3(self2.left, state);
      const right3 = getZshCompletions3(self2.right, state);
      return appendAll(left3, right3);
    }
    case "OrElse": {
      const leftNames = getNames(self2.left);
      const rightNames = getNames(self2.right);
      const left3 = getZshCompletions3(self2.left, {
        ...state,
        conflicts: appendAll(state.conflicts, rightNames)
      });
      const right3 = getZshCompletions3(self2.right, {
        ...state,
        conflicts: appendAll(state.conflicts, leftNames)
      });
      return appendAll(left3, right3);
    }
    case "Variadic": {
      return isSome2(self2.max) && self2.max.value > 1 ? getZshCompletions3(self2.argumentOption, {
        ...state,
        multiple: true
      }) : getZshCompletions3(self2.argumentOption, state);
    }
  }
};

// node_modules/@effect/cli/dist/esm/internal/builtInOptions.js
var setLogLevel = (level) => ({
  _tag: "SetLogLevel",
  level
});
var showCompletions = (shellType) => ({
  _tag: "ShowCompletions",
  shellType
});
var showHelp = (usage, helpDoc) => ({
  _tag: "ShowHelp",
  usage,
  helpDoc
});
var showWizard = (command) => ({
  _tag: "ShowWizard",
  command
});
var showVersion = {
  _tag: "ShowVersion"
};
var isShowHelp = (self2) => self2._tag === "ShowHelp";
var isShowWizard = (self2) => self2._tag === "ShowWizard";
var completionsOptions = /* @__PURE__ */ choiceWithValue("completions", [["sh", "bash"], ["bash", "bash"], ["fish", "fish"], ["zsh", "zsh"]]).pipe(optional4, /* @__PURE__ */ withDescription5("Generate a completion script for a specific shell."));
var logLevelOptions = /* @__PURE__ */ choiceWithValue("log-level", allLevels.map((level) => [level._tag.toLowerCase(), level])).pipe(optional4, /* @__PURE__ */ withDescription5("Sets the minimum log level for a command."));
var helpOptions = /* @__PURE__ */ boolean8("help").pipe(/* @__PURE__ */ withAlias("h"), /* @__PURE__ */ withDescription5("Show the help documentation for a command."));
var versionOptions = /* @__PURE__ */ boolean8("version").pipe(/* @__PURE__ */ withDescription5("Show the version of the application."));
var wizardOptions = /* @__PURE__ */ boolean8("wizard").pipe(/* @__PURE__ */ withDescription5("Start wizard mode for a command."));
var builtIns = /* @__PURE__ */ all11({
  completions: completionsOptions,
  logLevel: logLevelOptions,
  help: helpOptions,
  wizard: wizardOptions,
  version: versionOptions
});
var builtInOptions = (command, usage, helpDoc) => map34(builtIns, (builtIn) => {
  if (isSome2(builtIn.completions)) {
    return some2(showCompletions(builtIn.completions.value));
  }
  if (isSome2(builtIn.logLevel)) {
    return some2(setLogLevel(builtIn.logLevel.value));
  }
  if (builtIn.help) {
    return some2(showHelp(usage, helpDoc));
  }
  if (builtIn.wizard) {
    return some2(showWizard(command));
  }
  if (builtIn.version) {
    return some2(showVersion);
  }
  return none2();
});
// node_modules/effect/dist/esm/Logger.js
var withMinimumLogLevel2 = withMinimumLogLevel;
var defaultLogger2 = defaultLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;

// node_modules/effect/dist/esm/Unify.js
var unify2 = identity;

// node_modules/effect/dist/esm/SynchronizedRef.js
var make68 = makeSynchronized;
var get17 = get10;
var updateEffect2 = updateEffect;

// node_modules/@effect/cli/dist/esm/HelpDoc.js
var p2 = p;

// node_modules/@effect/cli/dist/esm/Options.js
var exports_Options = {};
__export(exports_Options, {
  wizard: () => wizard5,
  withSchema: () => withSchema4,
  withPseudoName: () => withPseudoName2,
  withFallbackPrompt: () => withFallbackPrompt2,
  withFallbackConfig: () => withFallbackConfig4,
  withDescription: () => withDescription6,
  withDefault: () => withDefault6,
  withAlias: () => withAlias2,
  text: () => text10,
  secret: () => secret6,
  repeated: () => repeated6,
  redacted: () => redacted6,
  processCommandLine: () => processCommandLine2,
  parse: () => parse7,
  orElseEither: () => orElseEither6,
  orElse: () => orElse16,
  optional: () => optional5,
  none: () => none14,
  mapTryCatch: () => mapTryCatch4,
  mapEffect: () => mapEffect9,
  map: () => map36,
  keyValueMap: () => keyValueMap2,
  isOptions: () => isOptions2,
  isBool: () => isBool3,
  integer: () => integer8,
  getUsage: () => getUsage4,
  getIdentifier: () => getIdentifier4,
  getHelp: () => getHelp6,
  float: () => float6,
  filterMap: () => filterMap10,
  fileText: () => fileText4,
  fileSchema: () => fileSchema4,
  fileParse: () => fileParse4,
  fileContent: () => fileContent4,
  file: () => file5,
  directory: () => directory4,
  date: () => date7,
  choiceWithValue: () => choiceWithValue2,
  choice: () => choice6,
  boolean: () => boolean9,
  between: () => between8,
  atMost: () => atMost4,
  atLeast: () => atLeast4,
  all: () => all12,
  OptionsTypeId: () => OptionsTypeId2
});
var OptionsTypeId2 = OptionsTypeId;
var isOptions2 = isOptions;
var all12 = all11;
var boolean9 = boolean8;
var choice6 = choice5;
var choiceWithValue2 = choiceWithValue;
var date7 = date6;
var directory4 = directory3;
var file5 = file4;
var fileContent4 = fileContent3;
var fileParse4 = fileParse3;
var fileSchema4 = fileSchema3;
var fileText4 = fileText3;
var float6 = float5;
var getHelp6 = getHelp5;
var getIdentifier4 = getIdentifier3;
var getUsage4 = getUsage3;
var integer8 = integer7;
var keyValueMap2 = keyValueMap;
var none14 = none13;
var redacted6 = redacted5;
var secret6 = secret5;
var text10 = text9;
var atMost4 = atMost3;
var atLeast4 = atLeast3;
var between8 = between7;
var filterMap10 = filterMap9;
var isBool3 = isBool2;
var map36 = map34;
var mapEffect9 = mapEffect8;
var mapTryCatch4 = mapTryCatch3;
var optional5 = optional4;
var orElse16 = orElse14;
var orElseEither6 = orElseEither5;
var parse7 = parse6;
var repeated6 = repeated5;
var processCommandLine2 = processCommandLine;
var withAlias2 = withAlias;
var withDefault6 = withDefault5;
var withFallbackConfig4 = withFallbackConfig3;
var withFallbackPrompt2 = withFallbackPrompt;
var withDescription6 = withDescription5;
var withPseudoName2 = withPseudoName;
var withSchema4 = withSchema3;
var wizard5 = wizard4;

// node_modules/@effect/cli/dist/esm/internal/commandDirective.js
var builtIn = (option6) => ({
  _tag: "BuiltIn",
  option: option6
});
var userDefined = (leftover2, value6) => ({
  _tag: "UserDefined",
  leftover: leftover2,
  value: value6
});
var isBuiltIn = (self2) => self2._tag === "BuiltIn";
var isUserDefined = (self2) => self2._tag === "UserDefined";
var map37 = /* @__PURE__ */ dual(2, (self2, f) => isUserDefined(self2) ? userDefined(self2.leftover, f(self2.value)) : self2);

// node_modules/@effect/cli/dist/esm/internal/commandDescriptor.js
var CommandDescriptorSymbolKey = "@effect/cli/CommandDescriptor";
var TypeId26 = /* @__PURE__ */ Symbol.for(CommandDescriptorSymbolKey);
var proto23 = {
  [TypeId26]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCommand = (u) => typeof u === "object" && u != null && (TypeId26 in u);
var isStandard = (self2) => self2._tag === "Standard";
var make69 = (name, options3 = none13, args2 = none11) => {
  const op = Object.create(proto23);
  op._tag = "Standard";
  op.name = name;
  op.description = empty42;
  op.options = options3;
  op.args = args2;
  return op;
};
var prompt = (name, prompt2) => {
  const op = Object.create(proto23);
  op._tag = "GetUserInput";
  op.name = name;
  op.description = empty42;
  op.prompt = prompt2;
  return op;
};
var getHelp7 = (self2, config2) => getHelpInternal4(self2, config2);
var getNames2 = (self2) => fromIterable5(getNamesInternal(self2));
var getBashCompletions3 = (self2, executable) => getBashCompletionsInternal(self2, executable);
var getFishCompletions4 = (self2, executable) => getFishCompletionsInternal(self2, executable);
var getZshCompletions4 = (self2, executable) => getZshCompletionsInternal(self2, executable);
var getSubcommands = (self2) => fromIterable6(getSubcommandsInternal(self2));
var getUsage5 = (self2) => getUsageInternal3(self2);
var map38 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect10(self2, (a) => right2(f(a))));
var mapEffect10 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto23);
  op._tag = "Map";
  op.command = self2;
  op.f = f;
  return op;
});
var parse8 = /* @__PURE__ */ dual(3, (self2, args2, config2) => parseInternal2(self2, args2, config2));
var withDescription7 = /* @__PURE__ */ dual(2, (self2, help) => withDescriptionInternal2(self2, help));
var withSubcommands = /* @__PURE__ */ dual(2, (self2, subcommands) => {
  const op = Object.create(proto23);
  op._tag = "Subcommands";
  op.parent = self2;
  op.children = map5(subcommands, ([id2, command]) => map38(command, (a) => [id2, a]));
  return op;
});
var wizard6 = /* @__PURE__ */ dual(3, (self2, prefix, config2) => wizardInternal4(self2, prefix, config2));
var getHelpInternal4 = (self2, config2) => {
  switch (self2._tag) {
    case "Standard": {
      const header = isEmpty18(self2.description) ? empty42 : sequence(h1("DESCRIPTION"), self2.description);
      const argsHelp = getHelp3(self2.args);
      const argsSection = isEmpty18(argsHelp) ? empty42 : sequence(h1("ARGUMENTS"), argsHelp);
      const options3 = config2.showBuiltIns ? all12([self2.options, builtIns]) : self2.options;
      const optionsHelp = getHelp5(options3);
      const optionsSection = isEmpty18(optionsHelp) ? empty42 : sequence(h1("OPTIONS"), optionsHelp);
      return sequence(header, sequence(argsSection, optionsSection));
    }
    case "GetUserInput": {
      return isEmpty18(self2.description) ? empty42 : sequence(h1("DESCRIPTION"), self2.description);
    }
    case "Map": {
      return getHelpInternal4(self2.command, config2);
    }
    case "Subcommands": {
      const getUsage6 = (command, preceding) => {
        switch (command._tag) {
          case "Standard":
          case "GetUserInput": {
            const usage = getSpan(getHelp2(getUsageInternal3(command)));
            const usages = append(preceding, usage);
            const finalUsage = reduce(usages, empty41, (acc, next4) => isText3(acc) && acc.value === "" ? next4 : isText3(next4) && next4.value === "" ? acc : spans([acc, space3, next4]));
            const description = getSpan(command.description);
            return of([finalUsage, description]);
          }
          case "Map": {
            return getUsage6(command.command, preceding);
          }
          case "Subcommands": {
            const parentUsage = getUsage6(command.parent, preceding);
            return match2(head(parentUsage), {
              onNone: () => flatMap2(command.children, (child) => getUsage6(child, preceding)),
              onSome: ([usage]) => {
                const childrenUsage = flatMap2(command.children, (child) => getUsage6(child, append(preceding, usage)));
                return appendAll(parentUsage, childrenUsage);
              }
            });
          }
        }
      };
      const printSubcommands = (subcommands) => {
        const maxUsageLength = reduceRight(subcommands, 0, (max9, [usage]) => Math.max(size16(usage), max9));
        const documents = map5(subcommands, ([usage, desc]) => p(spans([usage, text4(" ".repeat(maxUsageLength - size16(usage) + 2)), desc])));
        if (isNonEmptyReadonlyArray(documents)) {
          return enumeration(documents);
        }
        throw new Error("[BUG]: Subcommands.usage - received empty list of subcommands to print");
      };
      return sequence(getHelpInternal4(self2.parent, config2), sequence(h1("COMMANDS"), printSubcommands(flatMap2(self2.children, (child) => getUsage6(child, empty3())))));
    }
  }
};
var getNamesInternal = (self2) => {
  switch (self2._tag) {
    case "Standard":
    case "GetUserInput": {
      return of(self2.name);
    }
    case "Map": {
      return getNamesInternal(self2.command);
    }
    case "Subcommands": {
      return getNamesInternal(self2.parent);
    }
  }
};
var getSubcommandsInternal = (self2) => {
  const loop3 = (self3, isSubcommand) => {
    switch (self3._tag) {
      case "Standard":
      case "GetUserInput": {
        return of([self3.name, self3]);
      }
      case "Map": {
        return loop3(self3.command, isSubcommand);
      }
      case "Subcommands": {
        return isSubcommand ? loop3(self3.parent, false) : flatMap2(self3.children, (child) => loop3(child, true));
      }
    }
  };
  return loop3(self2, false);
};
var getUsageInternal3 = (self2) => {
  switch (self2._tag) {
    case "Standard": {
      return concat5(named(of(self2.name), none2()), concat5(getUsage3(self2.options), getUsage(self2.args)));
    }
    case "GetUserInput": {
      return named(of(self2.name), none2());
    }
    case "Map": {
      return getUsageInternal3(self2.command);
    }
    case "Subcommands": {
      return concat5(getUsageInternal3(self2.parent), mixed);
    }
  }
};
var parseInternal2 = (self2, args2, config2) => {
  const parseCommandLine2 = (self3, args3) => matchLeft(args3, {
    onEmpty: () => {
      const error4 = p(`Missing command name: '${self3.name}'`);
      return fail8(commandMismatch(error4));
    },
    onNonEmpty: (head6, tail2) => {
      const normalizedArgv0 = normalizeCase(config2, head6);
      const normalizedCommandName = normalizeCase(config2, self3.name);
      return succeed8(tail2).pipe(when2(() => normalizedArgv0 === normalizedCommandName), flatten7, catchTag2("NoSuchElementException", () => {
        const error4 = p(`Missing command name: '${self3.name}'`);
        return fail8(commandMismatch(error4));
      }));
    }
  });
  switch (self2._tag) {
    case "Standard": {
      const parseBuiltInArgs = (args3) => matchLeft(args3, {
        onEmpty: () => {
          const error4 = p(`Missing command name: '${self2.name}'`);
          return fail8(commandMismatch(error4));
        },
        onNonEmpty: (argv0) => {
          const normalizedArgv0 = normalizeCase(config2, argv0);
          const normalizedCommandName = normalizeCase(config2, self2.name);
          if (normalizedArgv0 === normalizedCommandName) {
            const help = getHelpInternal4(self2, config2);
            const usage = getUsageInternal3(self2);
            const options3 = builtInOptions(self2, usage, help);
            const argsWithoutCommand = drop(args3, 1);
            return processCommandLine(options3, argsWithoutCommand, config2).pipe(flatMap10((tuple6) => tuple6[2]), catchTag2("NoSuchElementException", () => {
              const error5 = p("No built-in option was matched");
              return fail8(noBuiltInMatch(error5));
            }), map17(builtIn));
          }
          const error4 = p(`Missing command name: '${self2.name}'`);
          return fail8(commandMismatch(error4));
        }
      });
      const parseUserDefinedArgs = (args3) => parseCommandLine2(self2, args3).pipe(flatMap10((commandOptionsAndArgs) => {
        const [optionsAndArgs, forcedCommandArgs] = splitForcedArgs(commandOptionsAndArgs);
        return processCommandLine(self2.options, optionsAndArgs, config2).pipe(flatMap10(([error4, commandArgs, optionsType]) => validate6(self2.args, appendAll(commandArgs, forcedCommandArgs), config2).pipe(catchAll2((e) => match2(error4, {
          onNone: () => fail8(e),
          onSome: (err) => fail8(err)
        })), map17(([argsLeftover, argsType]) => userDefined(argsLeftover, {
          name: self2.name,
          options: optionsType,
          args: argsType
        })))));
      }));
      const exhaustiveSearch = (args3) => {
        if (contains2(args3, "--help") || contains2(args3, "-h")) {
          return parseBuiltInArgs(make4(self2.name, "--help"));
        }
        if (contains2(args3, "--wizard")) {
          return parseBuiltInArgs(make4(self2.name, "--wizard"));
        }
        if (contains2(args3, "--version")) {
          return parseBuiltInArgs(make4(self2.name, "--version"));
        }
        const error4 = p(`Missing command name: '${self2.name}'`);
        return fail8(commandMismatch(error4));
      };
      return parseBuiltInArgs(args2).pipe(orElse4(() => parseUserDefinedArgs(args2)), catchSome2((e) => {
        if (isValidationError(e)) {
          if (config2.finalCheckBuiltIn) {
            return some2(exhaustiveSearch(args2).pipe(catchSome2((_) => isValidationError(_) ? some2(fail8(e)) : none2())));
          }
          return some2(fail8(e));
        }
        return none2();
      }));
    }
    case "GetUserInput": {
      return parseCommandLine2(self2, args2).pipe(zipRight3(run5(self2.prompt)), catchTag2("QuitException", (e) => die5(e)), map17((value6) => userDefined(drop(args2, 1), {
        name: self2.name,
        value: value6
      })));
    }
    case "Map": {
      return parseInternal2(self2.command, args2, config2).pipe(flatMap10((directive) => {
        if (isUserDefined(directive)) {
          return self2.f(directive.value).pipe(map17((value6) => userDefined(directive.leftover, value6)));
        }
        return succeed8(directive);
      }));
    }
    case "Subcommands": {
      const names = getNamesInternal(self2);
      const subcommands = getSubcommandsInternal(self2);
      const [parentArgs, childArgs] = span(args2, (arg) => !some3(subcommands, ([name]) => name === arg));
      const parseChildren = suspend3(() => {
        const iterator = self2.children[Symbol.iterator]();
        const loop3 = (next4) => {
          return parseInternal2(next4, childArgs, config2).pipe(catchIf2(isCommandMismatch, (e) => {
            const next5 = iterator.next();
            return next5.done ? fail8(e) : loop3(next5.value);
          }));
        };
        return loop3(iterator.next().value);
      });
      const helpDirectiveForParent = sync3(() => {
        return builtIn(showHelp(getUsageInternal3(self2), getHelpInternal4(self2, config2)));
      });
      const helpDirectiveForChild = parseChildren.pipe(flatMap10((directive) => {
        if (isBuiltIn(directive) && isShowHelp(directive.option)) {
          const parentName = getOrElse(head(names), () => "");
          const newDirective = builtIn(showHelp(concat5(named(of(parentName), none2()), directive.option.usage), directive.option.helpDoc));
          return succeed8(newDirective);
        }
        return fail8(invalidArgument(empty42));
      }));
      const wizardDirectiveForParent = sync3(() => builtIn(showWizard(self2)));
      const wizardDirectiveForChild = parseChildren.pipe(flatMap10((directive) => {
        if (isBuiltIn(directive) && isShowWizard(directive.option)) {
          return succeed8(directive);
        }
        return fail8(invalidArgument(empty42));
      }));
      return suspend3(() => parseInternal2(self2.parent, parentArgs, config2).pipe(flatMap10((directive) => {
        switch (directive._tag) {
          case "BuiltIn": {
            if (isShowHelp(directive.option)) {
              return isNonEmptyReadonlyArray(childArgs) ? orElse4(helpDirectiveForChild, () => helpDirectiveForParent) : helpDirectiveForParent;
            }
            if (isShowWizard(directive.option)) {
              return orElse4(wizardDirectiveForChild, () => wizardDirectiveForParent);
            }
            return succeed8(directive);
          }
          case "UserDefined": {
            const args3 = appendAll(directive.leftover, childArgs);
            if (isNonEmptyReadonlyArray(args3)) {
              return parseChildren.pipe(mapBoth4({
                onFailure: (err) => {
                  if (isCommandMismatch(err)) {
                    const parentName = getOrElse(head(names), () => "");
                    const childNames = map5(subcommands, ([name]) => `'${name}'`);
                    const oneOf = childNames.length === 1 ? "" : " one of";
                    const error4 = p(`Invalid subcommand for ${parentName} - use${oneOf} ${join(childNames, ", ")}`);
                    return commandMismatch(error4);
                  }
                  return err;
                },
                onSuccess: map37((subcommand) => ({
                  ...directive.value,
                  subcommand: some2(subcommand)
                }))
              }));
            }
            return succeed8(userDefined(directive.leftover, {
              ...directive.value,
              subcommand: none2()
            }));
          }
        }
      }), catchSome2(() => isEmptyReadonlyArray(args2) ? some2(helpDirectiveForParent) : none2())));
    }
  }
};
var splitForcedArgs = (args2) => {
  const [remainingArgs, forcedArgs] = span(args2, (str) => str !== "--");
  return [remainingArgs, drop(forcedArgs, 1)];
};
var withDescriptionInternal2 = (self2, description) => {
  switch (self2._tag) {
    case "Standard": {
      const helpDoc = typeof description === "string" ? p2(description) : description;
      const op = Object.create(proto23);
      op._tag = "Standard";
      op.name = self2.name;
      op.description = helpDoc;
      op.options = self2.options;
      op.args = self2.args;
      return op;
    }
    case "GetUserInput": {
      const helpDoc = typeof description === "string" ? p2(description) : description;
      const op = Object.create(proto23);
      op._tag = "GetUserInput";
      op.name = self2.name;
      op.description = helpDoc;
      op.prompt = self2.prompt;
      return op;
    }
    case "Map": {
      return mapEffect10(withDescriptionInternal2(self2.command, description), self2.f);
    }
    case "Subcommands": {
      const op = Object.create(proto23);
      op._tag = "Subcommands";
      op.parent = withDescriptionInternal2(self2.parent, description);
      op.children = self2.children.slice();
      return op;
    }
  }
};
var argsWizardHeader = /* @__PURE__ */ code("Args Wizard - ");
var optionsWizardHeader = /* @__PURE__ */ code("Options Wizard - ");
var wizardInternal4 = (self2, prefix, config2) => {
  const loop3 = (self3, commandLineRef) => {
    switch (self3._tag) {
      case "GetUserInput":
      case "Standard": {
        return gen2(function* () {
          const logCurrentCommand = get11(commandLineRef).pipe(flatMap10((commandLine) => {
            const currentCommand = p(pipe(strong(highlight("COMMAND:", cyan3)), concat4(space3), concat4(highlight(join(commandLine, " "), magenta3))));
            return log3(toAnsiText(currentCommand));
          }));
          if (isStandard(self3)) {
            yield* logCurrentCommand;
            const commandName = highlight(self3.name, magenta3);
            if (!isEmpty20(self3.options)) {
              const message = p(concat4(optionsWizardHeader, commandName));
              yield* log3(toAnsiText(message));
              const options3 = yield* wizard4(self3.options, config2);
              yield* updateAndGet3(commandLineRef, appendAll(options3));
              yield* logCurrentCommand;
            }
            if (!isEmpty19(self3.args)) {
              const message = p(concat4(argsWizardHeader, commandName));
              yield* log3(toAnsiText(message));
              const options3 = yield* wizard2(self3.args, config2);
              yield* updateAndGet3(commandLineRef, appendAll(options3));
              yield* logCurrentCommand;
            }
          }
          return yield* get11(commandLineRef);
        });
      }
      case "Map": {
        return loop3(self3.command, commandLineRef);
      }
      case "Subcommands": {
        const description = p("Select which command you would like to execute");
        const message = toAnsiText(description).trimEnd();
        const makeChoice = (title, index) => ({
          title,
          value: [title, index]
        });
        const choices = pipe(getSubcommandsInternal(self3), map5(([name], index) => makeChoice(name, index)));
        return loop3(self3.parent, commandLineRef).pipe(zipRight3(select({
          message,
          choices
        }).pipe(tap2(([name]) => update4(commandLineRef, append(name))), zipLeft2(log3()), flatMap10(([, nextIndex]) => loop3(self3.children[nextIndex], commandLineRef)))));
      }
    }
  };
  return make26(prefix).pipe(flatMap10((commandLineRef) => loop3(self2, commandLineRef).pipe(zipRight3(get11(commandLineRef)))));
};
var getShortDescription3 = (self2) => {
  switch (self2._tag) {
    case "Standard": {
      return getText(getSpan(self2.description));
    }
    case "GetUserInput": {
      return getText(getSpan(self2.description));
    }
    case "Map": {
      return getShortDescription3(self2.command);
    }
    case "Subcommands": {
      return "";
    }
  }
};
var traverseCommand = (self2, initialState3, f) => make68(initialState3).pipe(flatMap10((ref) => {
  const loop3 = (self3, parentCommands, subcommands, level) => {
    switch (self3._tag) {
      case "Standard": {
        const info3 = {
          command: self3,
          parentCommands,
          subcommands,
          level
        };
        return updateEffect2(ref, (state) => f(state, info3));
      }
      case "GetUserInput": {
        const info3 = {
          command: self3,
          parentCommands,
          subcommands,
          level
        };
        return updateEffect2(ref, (state) => f(state, info3));
      }
      case "Map": {
        return loop3(self3.command, parentCommands, subcommands, level);
      }
      case "Subcommands": {
        const parentNames = getNamesInternal(self3.parent);
        const nextSubcommands = getSubcommandsInternal(self3);
        const nextParentCommands = appendAll(parentCommands, parentNames);
        return loop3(self3.parent, parentCommands, nextSubcommands, level).pipe(zipRight3(forEach9(self3.children, (child) => loop3(child, nextParentCommands, subcommands, level + 1))));
      }
    }
  };
  return suspend3(() => loop3(self2, empty3(), empty3(), 0)).pipe(zipRight3(get17(ref)));
}));
var indentAll = /* @__PURE__ */ dual(2, (self2, indent3) => {
  const indentation = allocate(indent3 + 1).join(" ");
  return map5(self2, (line4) => `${indentation}${line4}`);
});
var getBashCompletionsInternal = (self2, executable) => traverseCommand(self2, empty3(), (state, info3) => {
  const options3 = isStandard(info3.command) ? all12([info3.command.options, builtIns]) : builtIns;
  const optionNames = getNames(options3);
  const optionCases = isStandard(info3.command) ? getBashCompletions2(info3.command.options) : empty3();
  const subcommandNames = pipe(info3.subcommands, map5(([name]) => name), sort(string3));
  const wordList = appendAll(optionNames, subcommandNames);
  const preformatted = isEmptyReadonlyArray(info3.parentCommands) ? of(info3.command.name) : pipe(info3.parentCommands, append(info3.command.name), map5((command) => command.replace("-", "__")));
  const caseName = join(preformatted, ",");
  const funcName = join(preformatted, "__");
  const funcLines = isEmptyReadonlyArray(info3.parentCommands) ? empty3() : [`${caseName})`, `    cmd="${funcName}"`, "    ;;"];
  const cmdLines = [`${funcName})`, `    opts="${join(wordList, " ")}"`, `    if [[ \${cur} == -* || \${COMP_CWORD} -eq ${info3.level + 1} ]] ; then`, '        COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )', "        return 0", "    fi", '    case "${prev}" in', ...indentAll(optionCases, 8), "    *)", "        COMPREPLY=()", "        ;;", "    esac", '    COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )', "    return 0", "    ;;"];
  const lines2 = append(state, [funcLines, cmdLines]);
  return succeed8(lines2);
}).pipe(map17((lines2) => {
  const rootCommand = unsafeGet(getNamesInternal(self2), 0);
  const scriptName = `_${rootCommand}_bash_completions`;
  const funcCases = flatMap2(lines2, ([funcLines]) => funcLines);
  const cmdCases = flatMap2(lines2, ([, cmdLines]) => cmdLines);
  return [`function ${scriptName}() {`, "    local i cur prev opts cmd", "    COMPREPLY=()", '    cur="${COMP_WORDS[COMP_CWORD]}"', '    prev="${COMP_WORDS[COMP_CWORD-1]}"', '    cmd=""', '    opts=""', '    for i in "${COMP_WORDS[@]}"; do', '        case "${cmd},${i}" in', '            ",$1")', `                cmd="${executable}"`, "                ;;", ...indentAll(funcCases, 12), "            *)", "                ;;", "        esac", "    done", '    case "${cmd}" in', ...indentAll(cmdCases, 8), "    esac", "}", `complete -F ${scriptName} -o nosort -o bashdefault -o default ${rootCommand}`];
}));
var getFishCompletionsInternal = (self2, executable) => traverseCommand(self2, empty3(), (state, info3) => {
  const baseTemplate = make4("complete", "-c", executable);
  const options3 = isStandard(info3.command) ? all11([builtIns, info3.command.options]) : builtIns;
  const optionsCompletions = getFishCompletions3(options3);
  const argsCompletions = isStandard(info3.command) ? getFishCompletions2(info3.command.args) : empty3();
  const rootCompletions = (conditionals2) => pipe(map5(optionsCompletions, (option6) => pipe(baseTemplate, appendAll(conditionals2), append(option6), join(" "))), appendAll(map5(argsCompletions, (option6) => pipe(baseTemplate, appendAll(conditionals2), append(option6), join(" ")))));
  const subcommandCompletions = (conditionals2) => map5(info3.subcommands, ([name, subcommand]) => {
    const description = getShortDescription3(subcommand);
    return pipe(baseTemplate, appendAll(conditionals2), appendAll(make4("-f", "-a", `"${name}"`)), appendAll(description.length === 0 ? empty3() : make4("-d", `'${description}'`)), join(" "));
  });
  if (isEmptyReadonlyArray(info3.parentCommands)) {
    const conditionals2 = make4("-n", '"__fish_use_subcommand"');
    return succeed8(pipe(state, appendAll(rootCompletions(conditionals2)), appendAll(subcommandCompletions(conditionals2))));
  }
  const parentConditionals = pipe(info3.parentCommands, drop(1), append(info3.command.name), map5((command) => `__fish_seen_subcommand_from ${command}`));
  const subcommandConditionals = map5(info3.subcommands, ([name]) => `not __fish_seen_subcommand_from ${name}`);
  const baseConditionals = pipe(appendAll(parentConditionals, subcommandConditionals), join("; and "));
  const conditionals = make4("-n", `"${baseConditionals}"`);
  return succeed8(pipe(state, appendAll(rootCompletions(conditionals)), appendAll(subcommandCompletions(conditionals))));
});
var getZshCompletionsInternal = (self2, executable) => traverseCommand(self2, empty3(), (state, info3) => {
  const preformatted = isEmptyReadonlyArray(info3.parentCommands) ? of(info3.command.name) : pipe(info3.parentCommands, append(info3.command.name), map5((command) => command.replace("-", "__")));
  const underscoreName = join(preformatted, "__");
  const spaceName = join(preformatted, " ");
  const subcommands = pipe(info3.subcommands, map5(([name, subcommand]) => {
    const desc = getShortDescription3(subcommand);
    return `'${name}:${desc}' \\`;
  }));
  const commands = isEmptyReadonlyArray(subcommands) ? `commands=()` : `commands=(
${join(indentAll(subcommands, 8), `
`)}
    )`;
  const handlerLines = [`(( $+functions[_${underscoreName}_commands] )) ||`, `_${underscoreName}_commands() {`, `    local commands; ${commands}`, `    _describe -t commands '${spaceName} commands' commands "$@"`, "}"];
  return succeed8(appendAll(state, handlerLines));
}).pipe(map17((handlers) => {
  const rootCommand = unsafeGet(getNamesInternal(self2), 0);
  const cases = getZshSubcommandCases(self2, empty3(), empty3());
  const scriptName = `_${rootCommand}_zsh_completions`;
  return [`#compdef ${executable}`, "", "autoload -U is-at-least", "", `function ${scriptName}() {`, "    typeset -A opt_args", "    typeset -a _arguments_options", "    local ret=1", "", "    if is-at-least 5.2; then", "        _arguments_options=(-s -S -C)", "    else", "        _arguments_options=(-s -C)", "    fi", "", '    local context curcontext="$curcontext" state line', ...indentAll(cases, 4), "}", "", ...handlers, "", `if [ "$funcstack[1]" = "${scriptName}" ]; then`, `    ${scriptName} "$@"`, "else", `    compdef ${scriptName} ${rootCommand}`, "fi"];
}));
var getZshSubcommandCases = (self2, parentCommands, subcommands) => {
  switch (self2._tag) {
    case "Standard":
    case "GetUserInput": {
      const options3 = isStandard(self2) ? all11([builtIns, self2.options]) : builtIns;
      const args2 = isStandard(self2) ? self2.args : none11;
      const optionCompletions = pipe(getZshCompletions3(options3), map5((completion) => `'${completion}' \\`));
      const argCompletions = pipe(getZshCompletions2(args2), map5((completion) => `'${completion}' \\`));
      if (isEmptyReadonlyArray(parentCommands)) {
        return ['_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), `    ":: :_${self2.name}_commands" \\`, `    "*::: :->${self2.name}" \\`, "    && ret=0"];
      }
      if (isEmptyReadonlyArray(subcommands)) {
        return [`(${self2.name})`, '_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), "    && ret=0", ";;"];
      }
      return [`(${self2.name})`, '_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), `    ":: :_${append(parentCommands, self2.name).join("__")}_commands" \\`, `    "*::: :->${self2.name}" \\`, "    && ret=0"];
    }
    case "Map": {
      return getZshSubcommandCases(self2.command, parentCommands, subcommands);
    }
    case "Subcommands": {
      const nextSubcommands = getSubcommandsInternal(self2);
      const parentNames = getNamesInternal(self2.parent);
      const parentLines = getZshSubcommandCases(self2.parent, parentCommands, appendAll(subcommands, nextSubcommands));
      const childCases = pipe(self2.children, flatMap2((child) => getZshSubcommandCases(child, appendAll(parentCommands, parentNames), subcommands)));
      const hyphenName = pipe(appendAll(parentCommands, parentNames), join("-"));
      const childLines = pipe(parentNames, flatMap2((parentName) => ["case $state in", `    (${parentName})`, `    words=($line[1] "\${words[@]}")`, "    (( CURRENT += 1 ))", `    curcontext="\${curcontext%:*:*}:${hyphenName}-command-$line[1]:"`, `    case $line[1] in`, ...indentAll(childCases, 8), "    esac", "    ;;", "esac"]), appendAll(isEmptyReadonlyArray(parentCommands) ? empty3() : of(";;")));
      return appendAll(parentLines, childLines);
    }
  }
};
var helpRequestedError = (command) => {
  const op = Object.create(proto20);
  op._tag = "HelpRequested";
  op.error = empty42;
  op.command = command;
  return op;
};

// node_modules/@effect/cli/dist/esm/internal/cliApp.js
var proto24 = {
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make70 = (config2) => {
  const op = Object.create(proto24);
  op.name = config2.name;
  op.version = config2.version;
  op.executable = config2.executable;
  op.command = config2.command;
  op.summary = config2.summary || empty41;
  op.footer = config2.footer || empty42;
  return op;
};
var run6 = /* @__PURE__ */ dual(3, (self2, args2, execute3) => contextWithEffect2((context9) => {
  const config2 = getOrElse(getOption2(context9, Tag4), () => defaultConfig);
  const [executable, filteredArgs] = splitExecutable(self2, args2);
  const prefixedArgs = appendAll(prefixCommand(self2.command), filteredArgs);
  return matchEffect2(parse8(self2.command, prefixedArgs, config2), {
    onFailure: (e) => zipRight3(printDocs(e.error), fail8(e)),
    onSuccess: unify2((directive) => {
      switch (directive._tag) {
        case "UserDefined": {
          return matchLeft(directive.leftover, {
            onEmpty: () => execute3(directive.value).pipe(catchSome2((e) => isValidationError(e) && isHelpRequested(e) ? some2(handleBuiltInOption(self2, executable, filteredArgs, showHelp(getUsage5(e.command), getHelp7(e.command, config2)), execute3, config2)) : none2())),
            onNonEmpty: (head6) => {
              const error4 = p(`Received unknown argument: '${head6}'`);
              return zipRight3(printDocs(error4), fail8(invalidValue(error4)));
            }
          });
        }
        case "BuiltIn": {
          return handleBuiltInOption(self2, executable, filteredArgs, directive.option, execute3, config2).pipe(catchSome2((e) => isValidationError(e) ? some2(zipRight3(printDocs(e.error), fail8(e))) : none2()));
        }
      }
    })
  });
}));
var splitExecutable = (self2, args2) => {
  if (self2.executable !== undefined) {
    return [self2.executable, drop(args2, 2)];
  }
  const [[runtime5, script], optionsAndArgs] = splitAt(args2, 2);
  return [`${runtime5} ${script}`, optionsAndArgs];
};
var printDocs = (error4) => error2(toAnsiText(error4));
var isQuitException = (u) => typeof u === "object" && u != null && ("_tag" in u) && u._tag === "QuitException";
var handleBuiltInOption = (self2, executable, args2, builtIn2, execute3, config2) => {
  switch (builtIn2._tag) {
    case "SetLogLevel": {
      const nextArgs = executable.split(/\s+/);
      for (let i = 0;i < args2.length; i++) {
        if (args2[i] === "--log-level" || args2[i - 1] === "--log-level") {
          continue;
        }
        nextArgs.push(args2[i]);
      }
      return run6(self2, nextArgs, execute3).pipe(withMinimumLogLevel2(builtIn2.level));
    }
    case "ShowHelp": {
      const banner = h1(code(self2.name));
      const header = p(spans([text4(`${self2.name} ${self2.version}`), isEmpty17(self2.summary) ? empty41 : spans([space3, text4("--"), space3, self2.summary])]));
      const usage = sequence(h1("USAGE"), pipe(enumerate(builtIn2.usage, config2), map5((span3) => p(concat4(text4("$ "), span3))), reduceRight(empty42, (left3, right3) => sequence(left3, right3))));
      const helpDoc = pipe(banner, sequence(header), sequence(usage), sequence(builtIn2.helpDoc), sequence(self2.footer));
      return log3(toAnsiText(helpDoc));
    }
    case "ShowCompletions": {
      const command = fromIterable(getNames2(self2.command))[0];
      switch (builtIn2.shellType) {
        case "bash": {
          return getBashCompletions3(self2.command, command).pipe(flatMap10((completions) => log3(join(completions, `
`))));
        }
        case "fish": {
          return getFishCompletions4(self2.command, command).pipe(flatMap10((completions) => log3(join(completions, `
`))));
        }
        case "zsh":
          return getZshCompletions4(self2.command, command).pipe(flatMap10((completions) => log3(join(completions, `
`))));
      }
    }
    case "ShowWizard": {
      const summary5 = isEmpty17(self2.summary) ? empty41 : spans([space3, text4("--"), space3, self2.summary]);
      const instructions = sequence(p(spans([text4("The wizard mode will assist you with constructing commands for"), space3, code(`${self2.name} (${self2.version})`), text4(".")])), p("Please answer all prompts provided by the wizard."));
      const description = descriptionList([[text4("Instructions"), instructions]]);
      const header = h1(spans([code("Wizard Mode for CLI Application:"), space3, code(self2.name), space3, code(`(${self2.version})`), summary5]));
      const help = sequence(header, description);
      const text11 = toAnsiText(help);
      const command = fromIterable(getNames2(self2.command))[0];
      const wizardPrefix = getWizardPrefix(builtIn2, command, args2);
      return log3(text11).pipe(zipRight3(wizard6(builtIn2.command, wizardPrefix, config2)), tap2((args3) => log3(toAnsiText(renderWizardArgs(args3)))), flatMap10((args3) => toggle3({
        message: "Would you like to run the command?",
        initial: true,
        active: "yes",
        inactive: "no"
      }).pipe(flatMap10((shouldRunCommand) => {
        const finalArgs = pipe(drop(args3, 1), prependAll(executable.split(/\s+/)));
        return shouldRunCommand ? log3().pipe(zipRight3(run6(self2, finalArgs, execute3))) : _void;
      }))), catchAll2((e) => {
        if (isQuitException(e)) {
          const message = p(error3(`

Quitting wizard mode...`));
          return log3(toAnsiText(message));
        }
        return fail8(e);
      }));
    }
    case "ShowVersion": {
      const help = p(self2.version);
      return log3(toAnsiText(help));
    }
  }
};
var prefixCommand = (self2) => {
  let command = self2;
  let prefix = empty3();
  while (command !== undefined) {
    switch (command._tag) {
      case "Standard": {
        prefix = of(command.name);
        command = undefined;
        break;
      }
      case "GetUserInput": {
        prefix = of(command.name);
        command = undefined;
        break;
      }
      case "Map": {
        command = command.command;
        break;
      }
      case "Subcommands": {
        command = command.parent;
        break;
      }
    }
  }
  return prefix;
};
var getWizardPrefix = (builtIn2, rootCommand, commandLineArgs) => {
  const subcommands = getSubcommands(builtIn2.command);
  const [parentArgs, childArgs] = span(commandLineArgs, (name) => !has5(subcommands, name));
  const args2 = matchLeft(childArgs, {
    onEmpty: () => filter2(parentArgs, (arg) => arg !== "--wizard"),
    onNonEmpty: (head6) => append(parentArgs, head6)
  });
  return appendAll(rootCommand.split(/\s+/), args2);
};
var renderWizardArgs = (args2) => {
  const params = pipe(filter2(args2, (param) => param.length > 0), join(" "));
  const executeMsg = text4("You may now execute your command directly with the following options and arguments:");
  return blocks([p(strong(code("Wizard Mode Complete!"))), p(executeMsg), p(concat4(text4("    "), highlight(params, cyan3)))]);
};
// node_modules/@effect/cli/dist/esm/CliConfig.js
var exports_CliConfig = {};
__export(exports_CliConfig, {
  normalizeCase: () => normalizeCase2,
  make: () => make71,
  layer: () => layer3,
  defaultLayer: () => defaultLayer2,
  defaultConfig: () => defaultConfig2,
  CliConfig: () => CliConfig
});
var CliConfig = Tag4;
var defaultConfig2 = defaultConfig;
var defaultLayer2 = defaultLayer;
var layer3 = layer;
var make71 = make67;
var normalizeCase2 = normalizeCase;
// node_modules/@effect/cli/dist/esm/Command.js
var exports_Command = {};
__export(exports_Command, {
  wizard: () => wizard8,
  withSubcommands: () => withSubcommands3,
  withHandler: () => withHandler2,
  withDescription: () => withDescription9,
  transformHandler: () => transformHandler2,
  run: () => run8,
  provideSync: () => provideSync2,
  provideEffectDiscard: () => provideEffectDiscard2,
  provideEffect: () => provideEffect2,
  provide: () => provide5,
  prompt: () => prompt3,
  make: () => make73,
  getZshCompletions: () => getZshCompletions6,
  getUsage: () => getUsage7,
  getSubcommands: () => getSubcommands3,
  getNames: () => getNames4,
  getHelp: () => getHelp9,
  getFishCompletions: () => getFishCompletions6,
  getBashCompletions: () => getBashCompletions5,
  fromDescriptor: () => fromDescriptor2,
  TypeId: () => TypeId28
});

// node_modules/@effect/cli/dist/esm/ValidationError.js
var helpRequested = helpRequestedError;

// node_modules/@effect/cli/dist/esm/internal/command.js
var CommandSymbolKey = "@effect/cli/Command";
var TypeId27 = /* @__PURE__ */ Symbol.for(CommandSymbolKey);
var parseConfig = (config2) => {
  const args2 = [];
  let argsIndex = 0;
  const options3 = [];
  let optionsIndex = 0;
  function parse9(config3) {
    const tree = {};
    for (const key in config3) {
      tree[key] = parseValue(config3[key]);
    }
    return tree;
  }
  function parseValue(value6) {
    if (isArray(value6)) {
      return {
        _tag: "Array",
        children: map5(value6, parseValue)
      };
    } else if (isArgs(value6)) {
      args2.push(value6);
      return {
        _tag: "Args",
        index: argsIndex++
      };
    } else if (isOptions(value6)) {
      options3.push(value6);
      return {
        _tag: "Options",
        index: optionsIndex++
      };
    } else {
      return {
        _tag: "ParsedConfig",
        tree: parse9(value6)
      };
    }
  }
  return {
    args: args2,
    options: options3,
    tree: parse9(config2)
  };
};
var reconstructConfigTree = (tree, args2, options3) => {
  const output = {};
  for (const key in tree) {
    output[key] = nodeValue(tree[key]);
  }
  return output;
  function nodeValue(node) {
    if (node._tag === "Args") {
      return args2[node.index];
    } else if (node._tag === "Options") {
      return options3[node.index];
    } else if (node._tag === "Array") {
      return map5(node.children, nodeValue);
    } else {
      return reconstructConfigTree(node.tree, args2, options3);
    }
  }
};
var Prototype = {
  ...CommitPrototype2,
  [TypeId27]: TypeId27,
  commit() {
    return this.tag;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var registeredDescriptors = /* @__PURE__ */ globalValue("@effect/cli/Command/registeredDescriptors", () => new WeakMap);
var getDescriptor = (self2) => registeredDescriptors.get(self2.tag) ?? self2.descriptor;
var makeProto = (descriptor3, handler, tag5, transform3 = identity) => {
  const self2 = Object.create(Prototype);
  self2.descriptor = descriptor3;
  self2.handler = handler;
  self2.transform = transform3;
  self2.tag = tag5;
  return self2;
};
var makeDerive = (self2, options3) => {
  const command = Object.create(Prototype);
  command.descriptor = options3.descriptor ?? self2.descriptor;
  command.handler = options3.handler ?? self2.handler;
  command.transform = options3.transform ? (effect4, opts) => options3.transform(self2.transform(effect4, opts), opts) : self2.transform;
  command.tag = self2.tag;
  return command;
};
var fromDescriptor = /* @__PURE__ */ dual((args2) => isCommand(args2[0]), (descriptor3, handler) => {
  const self2 = makeProto(descriptor3, handler ?? ((_) => failSync2(() => helpRequested(getDescriptor(self2)))), GenericTag(`@effect/cli/Command/(${fromIterable(getNames2(descriptor3)).join("|")})`));
  return self2;
});
var makeDescriptor = (name, config2) => {
  const {
    args: args2,
    options: options3,
    tree
  } = parseConfig(config2);
  return map38(make69(name, all11(options3), all9(args2)), ({
    args: args3,
    options: options4
  }) => reconstructConfigTree(tree, args3, options4));
};
var make72 = (name, config2 = {}, handler) => fromDescriptor(makeDescriptor(name, config2), handler);
var getHelp8 = (self2, config2) => getHelp7(self2.descriptor, config2);
var getNames3 = (self2) => getNames2(self2.descriptor);
var getBashCompletions4 = (self2, programName) => getBashCompletions3(self2.descriptor, programName);
var getFishCompletions5 = (self2, programName) => getFishCompletions4(self2.descriptor, programName);
var getZshCompletions5 = (self2, programName) => getZshCompletions4(self2.descriptor, programName);
var getSubcommands2 = (self2) => getSubcommands(self2.descriptor);
var getUsage6 = (self2) => getUsage5(self2.descriptor);
var mapDescriptor = /* @__PURE__ */ dual(2, (self2, f) => makeDerive(self2, {
  descriptor: f(self2.descriptor)
}));
var prompt2 = (name, prompt3, handler) => makeProto(map38(prompt(name, prompt3), (_) => _.value), handler, GenericTag(`@effect/cli/Prompt/${name}`));
var withHandler = /* @__PURE__ */ dual(2, (self2, handler) => makeDerive(self2, {
  handler,
  transform: identity
}));
var transformHandler = /* @__PURE__ */ dual(2, (self2, f) => makeDerive(self2, {
  transform: f
}));
var provide4 = /* @__PURE__ */ dual(2, (self2, layer4) => makeDerive(self2, {
  transform: (effect4, config2) => provide2(effect4, typeof layer4 === "function" ? layer4(config2) : layer4)
}));
var provideEffect = /* @__PURE__ */ dual(3, (self2, tag5, effect_) => makeDerive(self2, {
  transform: (self3, config2) => {
    const effect4 = typeof effect_ === "function" ? effect_(config2) : effect_;
    return provideServiceEffect2(self3, tag5, effect4);
  }
}));
var provideEffectDiscard = /* @__PURE__ */ dual(2, (self2, effect_) => makeDerive(self2, {
  transform: (self3, config2) => {
    const effect4 = typeof effect_ === "function" ? effect_(config2) : effect_;
    return zipRight3(effect4, self3);
  }
}));
var provideSync = /* @__PURE__ */ dual(3, (self2, tag5, f) => makeDerive(self2, {
  transform: (self3, config2) => {
    const service2 = typeof f === "function" ? f(config2) : f;
    return provideService2(self3, tag5, service2);
  }
}));
var withDescription8 = /* @__PURE__ */ dual(2, (self2, help) => mapDescriptor(self2, withDescription7(help)));
var withSubcommands2 = /* @__PURE__ */ dual(2, (self2, subcommands) => {
  const command = withSubcommands(self2.descriptor, map5(subcommands, (_) => [_.tag, _.descriptor]));
  const subcommandMap = reduce(subcommands, new Map, (handlers, subcommand) => {
    handlers.set(subcommand.tag, subcommand);
    registeredDescriptors.set(subcommand.tag, subcommand.descriptor);
    return handlers;
  });
  function handler(args2) {
    if (args2.subcommand._tag === "Some") {
      const [tag5, value6] = args2.subcommand.value;
      const subcommand = subcommandMap.get(tag5);
      const subcommandEffect = subcommand.transform(subcommand.handler(value6), value6);
      return provideService2(subcommandEffect, self2.tag, args2);
    }
    return self2.handler(args2);
  }
  return makeDerive(self2, {
    descriptor: command,
    handler
  });
});
var wizard7 = /* @__PURE__ */ dual(3, (self2, prefix, config2) => wizard6(self2.descriptor, prefix, config2));
var run7 = /* @__PURE__ */ dual(2, (self2, config2) => {
  const app = make70({
    ...config2,
    command: self2.descriptor
  });
  registeredDescriptors.set(self2.tag, self2.descriptor);
  const handler = (args2) => self2.transform(self2.handler(args2), args2);
  return (args2) => run6(app, args2, handler);
});

// node_modules/@effect/cli/dist/esm/Command.js
var TypeId28 = TypeId27;
var fromDescriptor2 = fromDescriptor;
var getHelp9 = getHelp8;
var getNames4 = getNames3;
var getBashCompletions5 = getBashCompletions4;
var getFishCompletions6 = getFishCompletions5;
var getZshCompletions6 = getZshCompletions5;
var getSubcommands3 = getSubcommands2;
var getUsage7 = getUsage6;
var make73 = make72;
var prompt3 = prompt2;
var provide5 = provide4;
var provideEffect2 = provideEffect;
var provideEffectDiscard2 = provideEffectDiscard;
var provideSync2 = provideSync;
var transformHandler2 = transformHandler;
var withDescription9 = withDescription8;
var withHandler2 = withHandler;
var withSubcommands3 = withSubcommands2;
var wizard8 = wizard7;
var run8 = run7;
// node_modules/@effect/cli/dist/esm/internal/configFile.js
var ConfigErrorTypeId2 = /* @__PURE__ */ Symbol.for("@effect/cli/ConfigFile/ConfigFileError");
var ConfigFileErrorProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(YieldableError2.prototype), {
  [ConfigErrorTypeId2]: ConfigErrorTypeId2
});
// node_modules/@effect/cli/dist/esm/HelpDoc/Span.js
var exports_Span = {};
__export(exports_Span, {
  weak: () => weak2,
  uri: () => uri2,
  text: () => text11,
  strong: () => strong2,
  spans: () => spans2,
  space: () => space4,
  isWeak: () => isWeak2,
  isUri: () => isUri2,
  isText: () => isText4,
  isStrong: () => isStrong2,
  isSequence: () => isSequence3,
  error: () => error4,
  empty: () => empty44,
  concat: () => concat6,
  code: () => code2
});
var isSequence3 = isSequence;
var isStrong2 = isStrong;
var isText4 = isText3;
var isUri2 = isUri;
var isWeak2 = isWeak;
var empty44 = empty41;
var space4 = space3;
var text11 = text4;
var code2 = code;
var error4 = error3;
var weak2 = weak;
var strong2 = strong;
var uri2 = uri;
var concat6 = concat4;
var spans2 = spans;
// node_modules/find-my-way-ts/dist/esm/QueryString.js
var Empty = function() {};
Empty.prototype = /* @__PURE__ */ Object.create(null);

// node_modules/@effect/platform/dist/esm/Cookies.js
var TypeId29 = /* @__PURE__ */ Symbol.for("@effect/platform/Cookies");
var CookieTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Cookies/Cookie");
var Proto3 = {
  [TypeId29]: TypeId29,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/Cookies",
      cookies: map4(this.cookies, (cookie) => cookie.toJSON())
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var CookieProto = {
  [CookieTypeId]: CookieTypeId,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/Cookies/Cookie",
      name: this.name,
      value: this.value,
      options: this.options
    };
  }
};

// node_modules/@effect/platform/dist/esm/Headers.js
var HeadersTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Headers");
var isHeaders = (u) => hasProperty(u, HeadersTypeId);
var Proto4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  [HeadersTypeId]: HeadersTypeId,
  [symbolRedactable](fiberRefs3) {
    return redact2(this, getOrDefault2(fiberRefs3, currentRedactedNames));
  }
});
var make75 = (input) => Object.assign(Object.create(Proto4), input);
var schemaFromSelf = /* @__PURE__ */ declare(isHeaders, {
  identifier: "Headers",
  equivalence: () => getEquivalence2(Equivalence2)
});
var schema = /* @__PURE__ */ transform2(/* @__PURE__ */ Record({
  key: String$,
  value: String$
}), schemaFromSelf, {
  strict: true,
  decode: (record2) => fromInput3(record2),
  encode: identity
});
var empty45 = /* @__PURE__ */ Object.create(Proto4);
var fromInput3 = (input) => {
  if (input === undefined) {
    return empty45;
  } else if (Symbol.iterator in input) {
    const out2 = Object.create(Proto4);
    for (const [k, v] of input) {
      out2[k.toLowerCase()] = v;
    }
    return out2;
  }
  const out = Object.create(Proto4);
  for (const [k, v] of Object.entries(input)) {
    if (Array.isArray(v)) {
      out[k.toLowerCase()] = v.join(", ");
    } else if (v !== undefined) {
      out[k.toLowerCase()] = v;
    }
  }
  return out;
};
var set9 = /* @__PURE__ */ dual(3, (self2, key, value6) => {
  const out = make75(self2);
  out[key.toLowerCase()] = value6;
  return out;
});
var setAll3 = /* @__PURE__ */ dual(2, (self2, headers) => make75({
  ...self2,
  ...fromInput3(headers)
}));
var merge12 = /* @__PURE__ */ dual(2, (self2, headers) => {
  const out = make75(self2);
  Object.assign(out, headers);
  return out;
});
var remove10 = /* @__PURE__ */ dual(2, (self2, key) => {
  const out = make75(self2);
  const modify6 = (key2) => {
    if (typeof key2 === "string") {
      const k = key2.toLowerCase();
      if (k in self2) {
        delete out[k];
      }
    } else {
      for (const name in self2) {
        if (key2.test(name)) {
          delete out[name];
        }
      }
    }
  };
  if (Array.isArray(key)) {
    for (let i = 0;i < key.length; i++) {
      modify6(key[i]);
    }
  } else {
    modify6(key);
  }
  return out;
});
var redact2 = /* @__PURE__ */ dual(2, (self2, key) => {
  const out = {
    ...self2
  };
  const modify6 = (key2) => {
    if (typeof key2 === "string") {
      const k = key2.toLowerCase();
      if (k in self2) {
        out[k] = make62(self2[k]);
      }
    } else {
      for (const name in self2) {
        if (key2.test(name)) {
          out[name] = make62(self2[name]);
        }
      }
    }
  };
  if (Array.isArray(key)) {
    for (let i = 0;i < key.length; i++) {
      modify6(key[i]);
    }
  } else {
    modify6(key);
  }
  return out;
});
var currentRedactedNames = /* @__PURE__ */ globalValue("@effect/platform/Headers/currentRedactedNames", () => unsafeMake8(["authorization", "cookie", "set-cookie", "x-api-key"]));

// node_modules/@effect/platform/dist/esm/UrlParams.js
var fromInput4 = (input) => {
  const parsed = fromInputNested(input);
  const out = [];
  for (let i = 0;i < parsed.length; i++) {
    if (Array.isArray(parsed[i][0])) {
      const [keys6, value6] = parsed[i];
      out.push([`${keys6[0]}[${keys6.slice(1).join("][")}]`, value6]);
    } else {
      out.push(parsed[i]);
    }
  }
  return out;
};
var fromInputNested = (input) => {
  const entries2 = Symbol.iterator in input ? fromIterable(input) : Object.entries(input);
  const out = [];
  for (const [key, value6] of entries2) {
    if (Array.isArray(value6)) {
      for (let i = 0;i < value6.length; i++) {
        if (value6[i] !== undefined) {
          out.push([key, String(value6[i])]);
        }
      }
    } else if (typeof value6 === "object") {
      const nested4 = fromInputNested(value6);
      for (const [k, v] of nested4) {
        out.push([[key, ...typeof k === "string" ? [k] : k], v]);
      }
    } else if (value6 !== undefined) {
      out.push([key, String(value6)]);
    }
  }
  return out;
};
var empty46 = [];
var setAll4 = /* @__PURE__ */ dual(2, (self2, input) => {
  const toSet4 = fromInput4(input);
  const keys6 = toSet4.map(([k]) => k);
  return appendAll(filter2(self2, ([k]) => keys6.includes(k)), toSet4);
});

// node_modules/@effect/platform/dist/esm/internal/httpBody.js
var TypeId31 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpBody");
class BodyBase {
  [TypeId31];
  constructor() {
    this[TypeId31] = TypeId31;
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  toString() {
    return format(this);
  }
}

class EmptyImpl extends BodyBase {
  _tag = "Empty";
  toJSON() {
    return {
      _id: "@effect/platform/HttpBody",
      _tag: "Empty"
    };
  }
}
var empty47 = /* @__PURE__ */ new EmptyImpl;

// node_modules/@effect/platform/dist/esm/internal/httpClientRequest.js
var TypeId32 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientRequest");
var Proto5 = {
  [TypeId32]: TypeId32,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/HttpClientRequest",
      method: this.method,
      url: this.url,
      urlParams: this.urlParams,
      hash: this.hash,
      headers: redact(this.headers),
      body: this.body.toJSON()
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeInternal(method, url2, urlParams, hash2, headers, body) {
  const self2 = Object.create(Proto5);
  self2.method = method;
  self2.url = url2;
  self2.urlParams = urlParams;
  self2.hash = hash2;
  self2.headers = headers;
  self2.body = body;
  return self2;
}
var empty48 = /* @__PURE__ */ makeInternal("GET", "", empty46, /* @__PURE__ */ none2(), empty45, empty47);
var make76 = (method) => (url2, options3) => modify6(empty48, {
  method,
  url: url2,
  ...options3 ?? undefined
});
var get19 = /* @__PURE__ */ make76("GET");
var post = /* @__PURE__ */ make76("POST");
var put = /* @__PURE__ */ make76("PUT");
var patch12 = /* @__PURE__ */ make76("PATCH");
var del = /* @__PURE__ */ make76("DELETE");
var head6 = /* @__PURE__ */ make76("HEAD");
var options3 = /* @__PURE__ */ make76("OPTIONS");
var modify6 = /* @__PURE__ */ dual(2, (self2, options4) => {
  let result = self2;
  if (options4.method) {
    result = setMethod(result, options4.method);
  }
  if (options4.url) {
    result = setUrl(result, options4.url);
  }
  if (options4.headers) {
    result = setHeaders(result, options4.headers);
  }
  if (options4.urlParams) {
    result = setUrlParams(result, options4.urlParams);
  }
  if (options4.hash) {
    result = setHash(result, options4.hash);
  }
  if (options4.body) {
    result = setBody(result, options4.body);
  }
  if (options4.accept) {
    result = accept(result, options4.accept);
  }
  if (options4.acceptJson) {
    result = acceptJson(result);
  }
  return result;
});
var setHeader = /* @__PURE__ */ dual(3, (self2, key, value6) => makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, set9(self2.headers, key, value6), self2.body));
var setHeaders = /* @__PURE__ */ dual(2, (self2, input) => makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, setAll3(self2.headers, input), self2.body));
var accept = /* @__PURE__ */ dual(2, (self2, mediaType) => setHeader(self2, "Accept", mediaType));
var acceptJson = /* @__PURE__ */ accept("application/json");
var setMethod = /* @__PURE__ */ dual(2, (self2, method) => makeInternal(method, self2.url, self2.urlParams, self2.hash, self2.headers, self2.body));
var setUrl = /* @__PURE__ */ dual(2, (self2, url2) => {
  if (typeof url2 === "string") {
    return makeInternal(self2.method, url2, self2.urlParams, self2.hash, self2.headers, self2.body);
  }
  const clone2 = new URL(url2.toString());
  const urlParams = fromInput4(clone2.searchParams);
  const hash2 = clone2.hash ? some2(clone2.hash.slice(1)) : none2();
  clone2.search = "";
  clone2.hash = "";
  return makeInternal(self2.method, clone2.toString(), urlParams, hash2, self2.headers, self2.body);
});
var setUrlParams = /* @__PURE__ */ dual(2, (self2, input) => makeInternal(self2.method, self2.url, setAll4(self2.urlParams, input), self2.hash, self2.headers, self2.body));
var setHash = /* @__PURE__ */ dual(2, (self2, hash2) => makeInternal(self2.method, self2.url, self2.urlParams, some2(hash2), self2.headers, self2.body));
var setBody = /* @__PURE__ */ dual(2, (self2, body) => {
  let headers = self2.headers;
  if (body._tag === "Empty" || body._tag === "FormData") {
    headers = remove10(headers, ["Content-type", "Content-length"]);
  } else {
    const contentType = body.contentType;
    if (contentType) {
      headers = set9(headers, "content-type", contentType);
    }
    const contentLength = body.contentLength;
    if (contentLength) {
      headers = set9(headers, "content-length", contentLength.toString());
    }
  }
  return makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, headers, body);
});

// node_modules/@effect/platform/dist/esm/internal/httpClient.js
var TypeId35 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClient");
var ClientProto = {
  [TypeId35]: TypeId35,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/HttpClient"
    };
  },
  get(url2, options4) {
    return this.execute(get19(url2, options4));
  },
  head(url2, options4) {
    return this.execute(head6(url2, options4));
  },
  post(url2, options4) {
    return this.execute(post(url2, options4));
  },
  put(url2, options4) {
    return this.execute(put(url2, options4));
  },
  patch(url2, options4) {
    return this.execute(patch12(url2, options4));
  },
  del(url2, options4) {
    return this.execute(del(url2, options4));
  },
  options(url2, options4) {
    return this.execute(options3(url2, options4));
  }
};

// node_modules/@effect/platform/dist/esm/internal/etag.js
var GeneratorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Etag/Generator");
var tag6 = /* @__PURE__ */ GenericTag("@effect/platform/Etag/Generator");
var fromFileInfo = (info3) => {
  const mtime = info3.mtime._tag === "Some" ? info3.mtime.value.getTime().toString(16) : "0";
  return `${info3.size.toString(16)}-${mtime}`;
};
var fromFileWeb = (file7) => {
  return `${file7.size.toString(16)}-${file7.lastModified.toString(16)}`;
};
var layer5 = /* @__PURE__ */ succeed10(tag6, /* @__PURE__ */ tag6.of({
  [GeneratorTypeId]: GeneratorTypeId,
  fromFileInfo(info3) {
    return sync3(() => ({
      _tag: "Strong",
      value: fromFileInfo(info3)
    }));
  },
  fromFileWeb(file7) {
    return sync3(() => ({
      _tag: "Strong",
      value: fromFileWeb(file7)
    }));
  }
}));
var layerWeak = /* @__PURE__ */ succeed10(tag6, /* @__PURE__ */ tag6.of({
  [GeneratorTypeId]: GeneratorTypeId,
  fromFileInfo(info3) {
    return sync3(() => ({
      _tag: "Weak",
      value: fromFileInfo(info3)
    }));
  },
  fromFileWeb(file7) {
    return sync3(() => ({
      _tag: "Weak",
      value: fromFileWeb(file7)
    }));
  }
}));

// node_modules/@effect/platform/dist/esm/internal/httpServer.js
var TypeId36 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServer");
var serverProto = {
  [TypeId36]: TypeId36
};

// node_modules/effect/dist/esm/internal/mailbox.js
var TypeId38 = /* @__PURE__ */ Symbol.for("effect/Mailbox");
var ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty52 = /* @__PURE__ */ empty6();
var exitEmpty = /* @__PURE__ */ exitSucceed(empty52);
var exitFalse = /* @__PURE__ */ exitSucceed(false);
var exitTrue = /* @__PURE__ */ exitSucceed(true);
var constDone = [empty52, true];

class MailboxImpl extends Class {
  scheduler;
  capacity;
  strategy;
  [TypeId38] = TypeId38;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set,
    offers: /* @__PURE__ */ new Set,
    awaiters: /* @__PURE__ */ new Set
  };
  messages = [];
  messagesChunk = /* @__PURE__ */ empty6();
  constructor(scheduler, capacity7, strategy) {
    super();
    this.scheduler = scheduler;
    this.capacity = capacity7;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable2(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll2(fromIterable2(messages)), takeRight2(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll2(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error5) {
    return this.done(exitFail(error5));
  }
  failCause(cause3) {
    return this.done(exitFailCause(cause3));
  }
  unsafeDone(exit3) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit3);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit3
    };
    return true;
  }
  shutdown = /* @__PURE__ */ sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty52;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit3) {
    return sync(() => this.unsafeDone(exit3));
  }
  end = /* @__PURE__ */ this.done(exitVoid);
  clear = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty52);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty52, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take2(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take2(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else {
        return zipRight(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException2));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop2(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop2(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : undefined;
    } else {
      return;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = /* @__PURE__ */ suspend(() => this.unsafeTake() ?? zipRight(this.awaitTake, this.take));
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size17 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some2(size17);
  }
  size = /* @__PURE__ */ sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0)
        return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (;entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0)
            return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = () => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    const taker = unsafeHead(this.state.takers);
    this.state.takers.delete(taker);
    taker(exitVoid);
  };
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll2(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty52;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of2(this.messages.pop());
    }
    return empty52;
  }
  finalize(exit3) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit3
    };
    for (const taker of openState.takers) {
      taker(exit3);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit3);
    }
    openState.awaiters.clear();
  }
}
var make80 = (capacity7) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity7 === "number" ? capacity7 : capacity7?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity7 === "number" ? "suspend" : capacity7?.strategy ?? "suspend")));
var toChannel4 = (self2) => {
  const loop3 = flatMap13(self2.takeAll, ([messages, done11]) => done11 ? messages.length === 0 ? void_5 : write(messages) : zipRight4(write(messages), loop3));
  return loop3;
};
var toStream = (self2) => fromChannel2(toChannel4(self2));

// node_modules/effect/dist/esm/Mailbox.js
var TypeId39 = TypeId38;
var isMailbox = (u) => hasProperty(u, TypeId39);
var make81 = make80;
var toChannel5 = toChannel4;
var toStream2 = toStream;

// node_modules/effect/dist/esm/FiberSet.js
var TypeId41 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
var isFiberSet = (u) => hasProperty(u, TypeId41);
var Proto6 = {
  [TypeId41]: TypeId41,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty2();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake12 = (backing, deferred) => {
  const self2 = Object.create(Proto6);
  self2.state = {
    _tag: "Open",
    backing
  };
  self2.deferred = deferred;
  return self2;
};
var make82 = () => acquireRelease2(map17(make24(), (deferred) => unsafeMake12(new Set, deferred)), (set12) => withFiberRuntime2((parent) => {
  const state = set12.state;
  if (state._tag === "Closed")
    return _void;
  set12.state = {
    _tag: "Closed"
  };
  const fibers = state.backing;
  return interruptAllAs2(fibers, combine3(parent.id(), internalFiberId)).pipe(intoDeferred2(set12.deferred));
}));
var internalFiberIdId = -1;
var internalFiberId = /* @__PURE__ */ make15(internalFiberIdId, 0);
var isInternalInterruption = /* @__PURE__ */ reduceWithContext3(undefined, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId3) => has4(ids2(fiberId3), internalFiberIdId),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeAdd = /* @__PURE__ */ dual((args2) => isFiberSet(args2[0]), (self2, fiber, options5) => {
  if (self2.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options5?.interruptAs ?? none4, internalFiberId));
    return;
  } else if (self2.state.backing.has(fiber)) {
    return;
  }
  self2.state.backing.add(fiber);
  fiber.addObserver((exit3) => {
    if (self2.state._tag === "Closed") {
      return;
    }
    self2.state.backing.delete(fiber);
    if (isFailure2(exit3) && (options5?.propagateInterruption === true ? !isInternalInterruption(exit3.cause) : !isInterruptedOnly2(exit3.cause))) {
      unsafeDone(self2.deferred, exit3);
    }
  });
});
var constInterruptedFiber = /* @__PURE__ */ function() {
  let fiber = undefined;
  return () => {
    if (fiber === undefined) {
      fiber = runFork2(interrupt7);
    }
    return fiber;
  };
}();
var runtime5 = (self2) => () => map17(runtime4(), (runtime6) => {
  const runFork4 = runFork3(runtime6);
  return (effect4, options5) => {
    if (self2.state._tag === "Closed") {
      return constInterruptedFiber();
    }
    const fiber = runFork4(effect4, options5);
    unsafeAdd(self2, fiber);
    return fiber;
  };
});
var join4 = (self2) => _await(self2.deferred);
// node_modules/@effect/platform/dist/esm/internal/httpRouter.js
var removeTrailingSlash = (path4) => path4.endsWith("/") ? path4.slice(0, -1) : path4;
var prefixPath = /* @__PURE__ */ dual(2, (self2, prefix) => {
  prefix = removeTrailingSlash(prefix);
  return self2 === "/" ? prefix : prefix + self2;
});

// node_modules/@effect/platform/dist/esm/HttpRouter.js
var prefixPath2 = prefixPath;

// node_modules/@effect/platform/dist/esm/Transferable.js
class Collector extends (/* @__PURE__ */ Tag2("@effect/platform/Transferable/Collector")()) {
}
var unsafeMakeCollector = () => {
  let tranferables = [];
  const unsafeAddAll = (transfers) => {
    tranferables.push(...transfers);
  };
  const unsafeRead = () => tranferables;
  const unsafeClear = () => {
    const prev = tranferables;
    tranferables = [];
    return prev;
  };
  return Collector.of({
    unsafeAddAll,
    addAll: (transferables) => sync3(() => unsafeAddAll(transferables)),
    unsafeRead,
    read: sync3(unsafeRead),
    unsafeClear,
    clear: sync3(unsafeClear)
  });
};

// node_modules/@effect/platform/dist/esm/internal/workerError.js
var WorkerErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/WorkerError");

// node_modules/@effect/platform/dist/esm/WorkerError.js
var WorkerErrorTypeId2 = WorkerErrorTypeId;
class WorkerError extends (/* @__PURE__ */ TaggedError2()("WorkerError", {
  reason: /* @__PURE__ */ Literal2("spawn", "decode", "send", "unknown", "encode"),
  cause: Defect
})) {
  [WorkerErrorTypeId2] = WorkerErrorTypeId2;
  static Cause = /* @__PURE__ */ Cause({
    error: this,
    defect: Defect
  });
  static encodeCause = /* @__PURE__ */ encodeSync(this.Cause);
  static decodeCause = /* @__PURE__ */ decodeSync(this.Cause);
  get message() {
    switch (this.reason) {
      case "send":
        return "An error occurred calling .postMessage";
      case "spawn":
        return "An error occurred while spawning a worker";
      case "decode":
        return "An error occurred during decoding";
      case "encode":
        return "An error occurred during encoding";
      case "unknown":
        return "An unexpected error occurred";
    }
  }
}

// node_modules/@effect/platform/dist/esm/internal/workerRunner.js
var PlatformRunnerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Runner/PlatformRunner");
var PlatformRunner = /* @__PURE__ */ GenericTag("@effect/platform/Runner/PlatformRunner");

// node_modules/@effect/platform/dist/esm/WorkerRunner.js
var PlatformRunnerTypeId2 = PlatformRunnerTypeId;
var PlatformRunner2 = PlatformRunner;

// node_modules/effect/dist/esm/internal/managedRuntime.js
var ManagedRuntimeProto = {
  ...CommitPrototype2,
  [TypeId13]: TypeId13,
  pipe() {
    return pipeArguments(this, arguments);
  },
  commit() {
    return this.runtimeEffect;
  }
};

// node_modules/@effect/rpc/dist/esm/RpcSchema.js
var StreamSchemaId = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcSchema/Stream");
var isStreamSchema = (schema2) => schema2.ast.annotations[SchemaIdAnnotationId] === StreamSchemaId;
var getStreamSchemas = (ast) => ast.annotations[StreamSchemaId] ? some2(ast.annotations[StreamSchemaId]) : none2();
var Stream = ({
  failure,
  success
}) => Object.assign(declare([success, failure], {
  decode: (success2, failure2) => parseStream(decodeUnknown2(ChunkFromSelf(success2)), decodeUnknown2(failure2)),
  encode: (success2, failure2) => parseStream(encodeUnknown(ChunkFromSelf(success2)), encodeUnknown(failure2))
}, {
  schemaId: StreamSchemaId,
  [StreamSchemaId]: {
    success,
    failure
  }
}), {
  success,
  failure
});
var isStream2 = (u) => hasProperty(u, StreamTypeId3);
var parseStream = (decodeSuccess, decodeFailure) => (u, options6, ast) => flatMap10(context3(), (context9) => {
  if (!isStream2(u))
    return fail8(new Type2(ast, u));
  return succeed8(u.pipe(mapChunksEffect2((value6) => decodeSuccess(value6, options6)), catchAll7((error5) => {
    if (isParseError(error5))
      return die11(error5);
    return matchEffect2(decodeFailure(error5, options6), {
      onFailure: die5,
      onSuccess: fail8
    });
  }), provideContext7(context9)));
});

// node_modules/@effect/rpc/dist/esm/Rpc.js
var TypeId44 = /* @__PURE__ */ Symbol.for("@effect/rpc/Rpc");
var Proto7 = {
  [TypeId44]: TypeId44,
  pipe() {
    return pipeArguments(this, arguments);
  },
  setSuccess(successSchema2) {
    return makeProto2({
      ...this,
      successSchema: successSchema2
    });
  },
  setError(errorSchema) {
    return makeProto2({
      ...this,
      errorSchema
    });
  },
  setPayload(payloadSchema) {
    return makeProto2({
      ...this,
      payloadSchema: isSchema(payloadSchema) ? payloadSchema : Struct(payloadSchema)
    });
  },
  middleware(middleware) {
    return makeProto2({
      ...this,
      middlewares: new Set([...this.middlewares, middleware])
    });
  },
  annotate(tag7, value6) {
    return makeProto2({
      ...this,
      annotations: add2(this.annotations, tag7, value6)
    });
  },
  annotateContext(context9) {
    return makeProto2({
      ...this,
      annotations: merge3(this.annotations, context9)
    });
  }
};
var makeProto2 = (options6) => {
  const self2 = Object.assign(Object.create(Proto7), options6);
  self2.key = `@effect/rpc/Rpc/${options6._tag}`;
  return self2;
};
var constEmptyStruct = /* @__PURE__ */ Struct({});
var make86 = (tag7, options6) => {
  const successSchema2 = options6?.success ?? Void;
  const errorSchema = options6?.error ?? Never;
  return makeProto2({
    _tag: tag7,
    payloadSchema: isSchema(options6?.payload) ? options6?.payload : options6?.payload ? Struct(options6?.payload) : constEmptyStruct,
    successSchema: options6?.stream ? Stream({
      success: successSchema2,
      failure: errorSchema
    }) : successSchema2,
    errorSchema: options6?.stream ? Never : errorSchema,
    annotations: empty5(),
    middlewares: new Set
  });
};
var exitSchemaCache = /* @__PURE__ */ globalValue("@effect/rpc/Rpc/exitSchemaCache", () => new WeakMap);
var exitSchema = (self2) => {
  if (exitSchemaCache.has(self2)) {
    return exitSchemaCache.get(self2);
  }
  const rpc = self2;
  const streamSchemas = getStreamSchemas(rpc.successSchema.ast);
  const schema2 = Exit({
    success: isSome2(streamSchemas) ? Void : rpc.successSchema,
    failure: isSome2(streamSchemas) ? Union2(streamSchemas.value.failure, rpc.errorSchema) : rpc.errorSchema,
    defect: Defect
  });
  exitSchemaCache.set(self2, schema2);
  return schema2;
};
var ForkTypeId = /* @__PURE__ */ Symbol.for("@effect/rpc/Rpc/Fork");
var isFork = (u) => (ForkTypeId in u);

// node_modules/@effect/rpc/dist/esm/RpcMessage.js
var RequestId = (id2) => typeof id2 === "bigint" ? id2 : BigInt(id2);

// node_modules/msgpackr/unpack.js
var decoder2;
try {
  decoder2 = new TextDecoder;
} catch (error5) {}
var src;
var srcEnd;
var position = 0;
var EMPTY_ARRAY = [];
var strings = EMPTY_ARRAY;
var stringPosition = 0;
var currentUnpackr = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var dataView;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};

class C1Type {
}
var C1 = new C1Type;
C1.name = "MessagePack 0xC1";
var sequentialMode = false;
var inlineObjectReadThreshold = 2;
var readStruct;
var onLoadedStructures;
var onSaveState;
try {
  new Function("");
} catch (error5) {
  inlineObjectReadThreshold = Infinity;
}

class Unpackr {
  constructor(options6) {
    if (options6) {
      if (options6.useRecords === false && options6.mapsAsObjects === undefined)
        options6.mapsAsObjects = true;
      if (options6.sequential && options6.trusted !== false) {
        options6.trusted = true;
        if (!options6.structures && options6.useRecords != false) {
          options6.structures = [];
          if (!options6.maxSharedStructures)
            options6.maxSharedStructures = 0;
        }
      }
      if (options6.structures)
        options6.structures.sharedLength = options6.structures.length;
      else if (options6.getStructures) {
        (options6.structures = []).uninitialized = true;
        options6.structures.sharedLength = 0;
      }
      if (options6.int64AsNumber) {
        options6.int64AsType = "number";
      }
    }
    Object.assign(this, options6);
  }
  unpack(source, options6) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.unpack(source, options6) : Unpackr.prototype.unpack.call(defaultOptions, source, options6);
      });
    }
    if (!source.buffer && source.constructor === ArrayBuffer)
      source = typeof Buffer !== "undefined" ? Buffer.from(source) : new Uint8Array(source);
    if (typeof options6 === "object") {
      srcEnd = options6.end || source.length;
      position = options6.start || 0;
    } else {
      position = 0;
      srcEnd = options6 > -1 ? options6 : source.length;
    }
    stringPosition = 0;
    srcStringEnd = 0;
    srcString = null;
    strings = EMPTY_ARRAY;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error5) {
      src = null;
      if (source instanceof Uint8Array)
        throw error5;
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof Unpackr) {
      currentUnpackr = this;
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead(options6);
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentUnpackr = defaultOptions;
      if (!currentStructures || currentStructures.length > 0)
        currentStructures = [];
    }
    return checkedRead(options6);
  }
  unpackMultiple(source, forEach14) {
    let values4, lastPosition = 0;
    try {
      sequentialMode = true;
      let size17 = source.length;
      let value6 = this ? this.unpack(source, size17) : defaultUnpackr.unpack(source, size17);
      if (forEach14) {
        if (forEach14(value6, lastPosition, position) === false)
          return;
        while (position < size17) {
          lastPosition = position;
          if (forEach14(checkedRead(), lastPosition, position) === false) {
            return;
          }
        }
      } else {
        values4 = [value6];
        while (position < size17) {
          lastPosition = position;
          values4.push(checkedRead());
        }
        return values4;
      }
    } catch (error5) {
      error5.lastPosition = lastPosition;
      error5.values = values4;
      throw error5;
    } finally {
      sequentialMode = false;
      clearSource();
    }
  }
  _mergeStructures(loadedStructures, existingStructures) {
    if (onLoadedStructures)
      loadedStructures = onLoadedStructures.call(this, loadedStructures);
    loadedStructures = loadedStructures || [];
    if (Object.isFrozen(loadedStructures))
      loadedStructures = loadedStructures.map((structure2) => structure2.slice(0));
    for (let i = 0, l = loadedStructures.length;i < l; i++) {
      let structure2 = loadedStructures[i];
      if (structure2) {
        structure2.isShared = true;
        if (i >= 32)
          structure2.highByte = i - 32 >> 5;
      }
    }
    loadedStructures.sharedLength = loadedStructures.length;
    for (let id2 in existingStructures || []) {
      if (id2 >= 0) {
        let structure2 = loadedStructures[id2];
        let existing = existingStructures[id2];
        if (existing) {
          if (structure2)
            (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id2] = structure2;
          loadedStructures[id2] = existing;
        }
      }
    }
    return this.structures = loadedStructures;
  }
  decode(source, options6) {
    return this.unpack(source, options6);
  }
}
function checkedRead(options6) {
  try {
    if (!currentUnpackr.trusted && !sequentialMode) {
      let sharedLength = currentStructures.sharedLength || 0;
      if (sharedLength < currentStructures.length)
        currentStructures.length = sharedLength;
    }
    let result;
    if (currentUnpackr.randomAccessStructure && src[position] < 64 && src[position] >= 32 && readStruct) {
      result = readStruct(src, position, srcEnd, currentUnpackr);
      src = null;
      if (!(options6 && options6.lazy) && result)
        result = result.toJSON();
      position = srcEnd;
    } else
      result = read3();
    if (bundledStrings) {
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (sequentialMode)
      currentStructures.restoreStructures = null;
    if (position == srcEnd) {
      if (currentStructures && currentStructures.restoreStructures)
        restoreStructures();
      currentStructures = null;
      src = null;
      if (referenceMap)
        referenceMap = null;
    } else if (position > srcEnd) {
      throw new Error("Unexpected end of MessagePack data");
    } else if (!sequentialMode) {
      let jsonView;
      try {
        jsonView = JSON.stringify(result, (_, value6) => typeof value6 === "bigint" ? `${value6}n` : value6).slice(0, 100);
      } catch (error5) {
        jsonView = "(JSON view not available " + error5 + ")";
      }
      throw new Error("Data read, but end of buffer not reached " + jsonView);
    }
    return result;
  } catch (error5) {
    if (currentStructures && currentStructures.restoreStructures)
      restoreStructures();
    clearSource();
    if (error5 instanceof RangeError || error5.message.startsWith("Unexpected end of buffer") || position > srcEnd) {
      error5.incomplete = true;
    }
    throw error5;
  }
}
function restoreStructures() {
  for (let id2 in currentStructures.restoreStructures) {
    currentStructures[id2] = currentStructures.restoreStructures[id2];
  }
  currentStructures.restoreStructures = null;
}
function read3() {
  let token = src[position++];
  if (token < 160) {
    if (token < 128) {
      if (token < 64)
        return token;
      else {
        let structure2 = currentStructures[token & 63] || currentUnpackr.getStructures && loadStructures()[token & 63];
        if (structure2) {
          if (!structure2.read) {
            structure2.read = createStructureReader(structure2, token & 63);
          }
          return structure2.read();
        } else
          return token;
      }
    } else if (token < 144) {
      token -= 128;
      if (currentUnpackr.mapsAsObjects) {
        let object = {};
        for (let i = 0;i < token; i++) {
          let key = readKey();
          if (key === "__proto__")
            key = "__proto_";
          object[key] = read3();
        }
        return object;
      } else {
        let map39 = new Map;
        for (let i = 0;i < token; i++) {
          map39.set(read3(), read3());
        }
        return map39;
      }
    } else {
      token -= 144;
      let array9 = new Array(token);
      for (let i = 0;i < token; i++) {
        array9[i] = read3();
      }
      if (currentUnpackr.freezeData)
        return Object.freeze(array9);
      return array9;
    }
  } else if (token < 192) {
    let length4 = token - 160;
    if (srcStringEnd >= position) {
      return srcString.slice(position - srcStringStart, (position += length4) - srcStringStart);
    }
    if (srcStringEnd == 0 && srcEnd < 140) {
      let string8 = length4 < 16 ? shortStringInJS(length4) : longStringInJS(length4);
      if (string8 != null)
        return string8;
    }
    return readFixedString(length4);
  } else {
    let value6;
    switch (token) {
      case 192:
        return null;
      case 193:
        if (bundledStrings) {
          value6 = read3();
          if (value6 > 0)
            return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value6);
          else
            return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value6);
        }
        return C1;
      case 194:
        return false;
      case 195:
        return true;
      case 196:
        value6 = src[position++];
        if (value6 === undefined)
          throw new Error("Unexpected end of buffer");
        return readBin(value6);
      case 197:
        value6 = dataView.getUint16(position);
        position += 2;
        return readBin(value6);
      case 198:
        value6 = dataView.getUint32(position);
        position += 4;
        return readBin(value6);
      case 199:
        return readExt(src[position++]);
      case 200:
        value6 = dataView.getUint16(position);
        position += 2;
        return readExt(value6);
      case 201:
        value6 = dataView.getUint32(position);
        position += 4;
        return readExt(value6);
      case 202:
        value6 = dataView.getFloat32(position);
        if (currentUnpackr.useFloat32 > 2) {
          let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
          position += 4;
          return (multiplier * value6 + (value6 > 0 ? 0.5 : -0.5) >> 0) / multiplier;
        }
        position += 4;
        return value6;
      case 203:
        value6 = dataView.getFloat64(position);
        position += 8;
        return value6;
      case 204:
        return src[position++];
      case 205:
        value6 = dataView.getUint16(position);
        position += 2;
        return value6;
      case 206:
        value6 = dataView.getUint32(position);
        position += 4;
        return value6;
      case 207:
        if (currentUnpackr.int64AsType === "number") {
          value6 = dataView.getUint32(position) * 4294967296;
          value6 += dataView.getUint32(position + 4);
        } else if (currentUnpackr.int64AsType === "string") {
          value6 = dataView.getBigUint64(position).toString();
        } else if (currentUnpackr.int64AsType === "auto") {
          value6 = dataView.getBigUint64(position);
          if (value6 <= BigInt(2) << BigInt(52))
            value6 = Number(value6);
        } else
          value6 = dataView.getBigUint64(position);
        position += 8;
        return value6;
      case 208:
        return dataView.getInt8(position++);
      case 209:
        value6 = dataView.getInt16(position);
        position += 2;
        return value6;
      case 210:
        value6 = dataView.getInt32(position);
        position += 4;
        return value6;
      case 211:
        if (currentUnpackr.int64AsType === "number") {
          value6 = dataView.getInt32(position) * 4294967296;
          value6 += dataView.getUint32(position + 4);
        } else if (currentUnpackr.int64AsType === "string") {
          value6 = dataView.getBigInt64(position).toString();
        } else if (currentUnpackr.int64AsType === "auto") {
          value6 = dataView.getBigInt64(position);
          if (value6 >= BigInt(-2) << BigInt(52) && value6 <= BigInt(2) << BigInt(52))
            value6 = Number(value6);
        } else
          value6 = dataView.getBigInt64(position);
        position += 8;
        return value6;
      case 212:
        value6 = src[position++];
        if (value6 == 114) {
          return recordDefinition(src[position++] & 63);
        } else {
          let extension = currentExtensions[value6];
          if (extension) {
            if (extension.read) {
              position++;
              return extension.read(read3());
            } else if (extension.noBuffer) {
              position++;
              return extension();
            } else
              return extension(src.subarray(position, ++position));
          } else
            throw new Error("Unknown extension " + value6);
        }
      case 213:
        value6 = src[position];
        if (value6 == 114) {
          position++;
          return recordDefinition(src[position++] & 63, src[position++]);
        } else
          return readExt(2);
      case 214:
        return readExt(4);
      case 215:
        return readExt(8);
      case 216:
        return readExt(16);
      case 217:
        value6 = src[position++];
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString8(value6);
      case 218:
        value6 = dataView.getUint16(position);
        position += 2;
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString16(value6);
      case 219:
        value6 = dataView.getUint32(position);
        position += 4;
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString32(value6);
      case 220:
        value6 = dataView.getUint16(position);
        position += 2;
        return readArray(value6);
      case 221:
        value6 = dataView.getUint32(position);
        position += 4;
        return readArray(value6);
      case 222:
        value6 = dataView.getUint16(position);
        position += 2;
        return readMap(value6);
      case 223:
        value6 = dataView.getUint32(position);
        position += 4;
        return readMap(value6);
      default:
        if (token >= 224)
          return token - 256;
        if (token === undefined) {
          let error5 = new Error("Unexpected end of MessagePack data");
          error5.incomplete = true;
          throw error5;
        }
        throw new Error("Unknown MessagePack token " + token);
    }
  }
}
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure2, firstId) {
  function readObject() {
    if (readObject.count++ > inlineObjectReadThreshold) {
      let readObject2 = structure2.read = new Function("r", "return function(){return " + (currentUnpackr.freezeData ? "Object.freeze" : "") + "({" + structure2.map((key) => key === "__proto__" ? "__proto_:r()" : validName.test(key) ? key + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "})}")(read3);
      if (structure2.highByte === 0)
        structure2.read = createSecondByteReader(firstId, structure2.read);
      return readObject2();
    }
    let object = {};
    for (let i = 0, l = structure2.length;i < l; i++) {
      let key = structure2[i];
      if (key === "__proto__")
        key = "__proto_";
      object[key] = read3();
    }
    if (currentUnpackr.freezeData)
      return Object.freeze(object);
    return object;
  }
  readObject.count = 0;
  if (structure2.highByte === 0) {
    return createSecondByteReader(firstId, readObject);
  }
  return readObject;
}
var createSecondByteReader = (firstId, read0) => {
  return function() {
    let highByte = src[position++];
    if (highByte === 0)
      return read0();
    let id2 = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);
    let structure2 = currentStructures[id2] || loadStructures()[id2];
    if (!structure2) {
      throw new Error("Record id is not defined for " + id2);
    }
    if (!structure2.read)
      structure2.read = createStructureReader(structure2, firstId);
    return structure2.read();
  };
};
function loadStructures() {
  let loadedStructures = saveState(() => {
    src = null;
    return currentUnpackr.getStructures();
  });
  return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);
}
var readFixedString = readStringJS;
var readString8 = readStringJS;
var readString16 = readStringJS;
var readString32 = readStringJS;
var isNativeAccelerationEnabled = false;
function setExtractor(extractStrings) {
  isNativeAccelerationEnabled = true;
  readFixedString = readString2(1);
  readString8 = readString2(2);
  readString16 = readString2(3);
  readString32 = readString2(5);
  function readString2(headerLength) {
    return function readString(length4) {
      let string8 = strings[stringPosition++];
      if (string8 == null) {
        if (bundledStrings)
          return readStringJS(length4);
        let byteOffset = src.byteOffset;
        let extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer);
        if (typeof extraction == "string") {
          string8 = extraction;
          strings = EMPTY_ARRAY;
        } else {
          strings = extraction;
          stringPosition = 1;
          srcStringEnd = 1;
          string8 = strings[0];
          if (string8 === undefined)
            throw new Error("Unexpected end of buffer");
        }
      }
      let srcStringLength = string8.length;
      if (srcStringLength <= length4) {
        position += length4;
        return string8;
      }
      srcString = string8;
      srcStringStart = position;
      srcStringEnd = position + srcStringLength;
      position += length4;
      return string8.slice(0, length4);
    };
  }
}
function readStringJS(length4) {
  let result;
  if (length4 < 16) {
    if (result = shortStringInJS(length4))
      return result;
  }
  if (length4 > 64 && decoder2)
    return decoder2.decode(src.subarray(position, position += length4));
  const end6 = position + length4;
  const units = [];
  result = "";
  while (position < end6) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
function readString2(source, start3, length4) {
  let existingSrc = src;
  src = source;
  position = start3;
  try {
    return readStringJS(length4);
  } finally {
    src = existingSrc;
  }
}
function readArray(length4) {
  let array9 = new Array(length4);
  for (let i = 0;i < length4; i++) {
    array9[i] = read3();
  }
  if (currentUnpackr.freezeData)
    return Object.freeze(array9);
  return array9;
}
function readMap(length4) {
  if (currentUnpackr.mapsAsObjects) {
    let object = {};
    for (let i = 0;i < length4; i++) {
      let key = readKey();
      if (key === "__proto__")
        key = "__proto_";
      object[key] = read3();
    }
    return object;
  } else {
    let map39 = new Map;
    for (let i = 0;i < length4; i++) {
      map39.set(read3(), read3());
    }
    return map39;
  }
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length4) {
  let start3 = position;
  let bytes = new Array(length4);
  for (let i = 0;i < length4; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start3;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length4) {
  if (length4 < 4) {
    if (length4 < 2) {
      if (length4 === 0)
        return "";
      else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length4 < 3)
        return fromCharCode(a, b);
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length4 < 6) {
      if (length4 === 4)
        return fromCharCode(a, b, c, d);
      else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length4 < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position -= 6;
        return;
      }
      if (length4 < 7)
        return fromCharCode(a, b, c, d, e, f);
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length4 < 10) {
        if (length4 === 8)
          return fromCharCode(a, b, c, d, e, f, g, h);
        else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length4 < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length4 < 11)
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length4 < 14) {
          if (length4 === 12)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length4 < 15)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readOnlyJSString() {
  let token = src[position++];
  let length4;
  if (token < 192) {
    length4 = token - 160;
  } else {
    switch (token) {
      case 217:
        length4 = src[position++];
        break;
      case 218:
        length4 = dataView.getUint16(position);
        position += 2;
        break;
      case 219:
        length4 = dataView.getUint32(position);
        position += 4;
        break;
      default:
        throw new Error("Expected string");
    }
  }
  return readStringJS(length4);
}
function readBin(length4) {
  return currentUnpackr.copyBuffers ? Uint8Array.prototype.slice.call(src, position, position += length4) : src.subarray(position, position += length4);
}
function readExt(length4) {
  let type2 = src[position++];
  if (currentExtensions[type2]) {
    let end6;
    return currentExtensions[type2](src.subarray(position, end6 = position += length4), (readPosition) => {
      position = readPosition;
      try {
        return read3();
      } finally {
        position = end6;
      }
    });
  } else
    throw new Error("Unknown extension type " + type2);
}
var keyCache = new Array(4096);
function readKey() {
  let length4 = src[position++];
  if (length4 >= 160 && length4 < 192) {
    length4 = length4 - 160;
    if (srcStringEnd >= position)
      return srcString.slice(position - srcStringStart, (position += length4) - srcStringStart);
    else if (!(srcStringEnd == 0 && srcEnd < 180))
      return readFixedString(length4);
  } else {
    position--;
    return asSafeString(read3());
  }
  let key = (length4 << 5 ^ (length4 > 1 ? dataView.getUint16(position) : length4 > 0 ? src[position] : 0)) & 4095;
  let entry = keyCache[key];
  let checkPosition = position;
  let end6 = position + length4 - 3;
  let chunk4;
  let i = 0;
  if (entry && entry.bytes == length4) {
    while (checkPosition < end6) {
      chunk4 = dataView.getUint32(checkPosition);
      if (chunk4 != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
      checkPosition += 4;
    }
    end6 += 3;
    while (checkPosition < end6) {
      chunk4 = src[checkPosition++];
      if (chunk4 != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
    }
    if (checkPosition === end6) {
      position = checkPosition;
      return entry.string;
    }
    end6 -= 3;
    checkPosition = position;
  }
  entry = [];
  keyCache[key] = entry;
  entry.bytes = length4;
  while (checkPosition < end6) {
    chunk4 = dataView.getUint32(checkPosition);
    entry.push(chunk4);
    checkPosition += 4;
  }
  end6 += 3;
  while (checkPosition < end6) {
    chunk4 = src[checkPosition++];
    entry.push(chunk4);
  }
  let string8 = length4 < 16 ? shortStringInJS(length4) : longStringInJS(length4);
  if (string8 != null)
    return entry.string = string8;
  return entry.string = readFixedString(length4);
}
function asSafeString(property) {
  if (typeof property === "string")
    return property;
  if (typeof property === "number" || typeof property === "boolean" || typeof property === "bigint")
    return property.toString();
  if (property == null)
    return property + "";
  if (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every((item) => ["string", "number", "boolean", "bigint"].includes(typeof item))) {
    return property.flat().toString();
  }
  throw new Error(`Invalid property type for record: ${typeof property}`);
}
var recordDefinition = (id2, highByte) => {
  let structure2 = read3().map(asSafeString);
  let firstByte = id2;
  if (highByte !== undefined) {
    id2 = id2 < 32 ? -((highByte << 5) + id2) : (highByte << 5) + id2;
    structure2.highByte = highByte;
  }
  let existingStructure = currentStructures[id2];
  if (existingStructure && (existingStructure.isShared || sequentialMode)) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id2] = existingStructure;
  }
  currentStructures[id2] = structure2;
  structure2.read = createStructureReader(structure2, firstByte);
  return structure2.read();
};
currentExtensions[0] = () => {};
currentExtensions[0].noBuffer = true;
currentExtensions[66] = (data) => {
  let length4 = data.length;
  let value6 = BigInt(data[0] & 128 ? data[0] - 256 : data[0]);
  for (let i = 1;i < length4; i++) {
    value6 <<= BigInt(8);
    value6 += BigInt(data[i]);
  }
  return value6;
};
var errors2 = { Error, TypeError, ReferenceError };
currentExtensions[101] = () => {
  let data = read3();
  return (errors2[data[0]] || Error)(data[1], { cause: data[2] });
};
currentExtensions[105] = (data) => {
  if (currentUnpackr.structuredClone === false)
    throw new Error("Structured clone extension is disabled");
  let id2 = dataView.getUint32(position - 4);
  if (!referenceMap)
    referenceMap = new Map;
  let token = src[position];
  let target;
  if (token >= 144 && token < 160 || token == 220 || token == 221)
    target = [];
  else if (token >= 128 && token < 144 || token == 222 || token == 223)
    target = new Map;
  else if ((token >= 199 && token <= 201 || token >= 212 && token <= 216) && src[position + 1] === 115)
    target = new Set;
  else
    target = {};
  let refEntry = { target };
  referenceMap.set(id2, refEntry);
  let targetProperties = read3();
  if (!refEntry.used) {
    return refEntry.target = targetProperties;
  } else {
    Object.assign(target, targetProperties);
  }
  if (target instanceof Map)
    for (let [k, v] of targetProperties.entries())
      target.set(k, v);
  if (target instanceof Set)
    for (let i of Array.from(targetProperties))
      target.add(i);
  return target;
};
currentExtensions[112] = (data) => {
  if (currentUnpackr.structuredClone === false)
    throw new Error("Structured clone extension is disabled");
  let id2 = dataView.getUint32(position - 4);
  let refEntry = referenceMap.get(id2);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[115] = () => new Set(read3());
var typedArrays = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((type2) => type2 + "Array");
var glbl = typeof globalThis === "object" ? globalThis : window;
currentExtensions[116] = (data) => {
  let typeCode = data[0];
  let buffer4 = Uint8Array.prototype.slice.call(data, 1).buffer;
  let typedArrayName = typedArrays[typeCode];
  if (!typedArrayName) {
    if (typeCode === 16)
      return buffer4;
    if (typeCode === 17)
      return new DataView(buffer4);
    throw new Error("Could not find typed array for code " + typeCode);
  }
  return new glbl[typedArrayName](buffer4);
};
currentExtensions[120] = () => {
  let data = read3();
  return new RegExp(data[0], data[1]);
};
var TEMP_BUNDLE = [];
currentExtensions[98] = (data) => {
  let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
  let dataPosition = position;
  position += dataSize - data.length;
  bundledStrings = TEMP_BUNDLE;
  bundledStrings = [readOnlyJSString(), readOnlyJSString()];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read3();
};
currentExtensions[255] = (data) => {
  if (data.length == 4)
    return new Date((data[0] * 16777216 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000);
  else if (data.length == 8)
    return new Date(((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1e6 + ((data[3] & 3) * 4294967296 + data[4] * 16777216 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000);
  else if (data.length == 12)
    return new Date(((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1e6 + ((data[4] & 128 ? -281474976710656 : 0) + data[6] * 1099511627776 + data[7] * 4294967296 + data[8] * 16777216 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000);
  else
    return new Date("invalid");
};
function saveState(callback) {
  if (onSaveState)
    onSaveState();
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedStringPosition = stringPosition;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedStrings = strings;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedStructuresContents = currentStructures.slice(0, currentStructures.length);
  let savedPackr = currentUnpackr;
  let savedSequentialMode = sequentialMode;
  let value6 = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  stringPosition = savedStringPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  strings = savedStrings;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);
  currentUnpackr = savedPackr;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value6;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
var mult10 = new Array(147);
for (let i = 0;i < 256; i++) {
  mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
}
var defaultUnpackr = new Unpackr({ useRecords: false });
var unpack = defaultUnpackr.unpack;
var unpackMultiple = defaultUnpackr.unpackMultiple;
var decode7 = defaultUnpackr.unpack;
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function setReadStruct(updatedReadStruct, loadedStructs, saveState2) {
  readStruct = updatedReadStruct;
  onLoadedStructures = loadedStructs;
  onSaveState = saveState2;
}
// node_modules/msgpackr/pack.js
var textEncoder;
try {
  textEncoder = new TextEncoder;
} catch (error5) {}
var extensions;
var extensionClasses;
var hasNodeBuffer = typeof Buffer !== "undefined";
var ByteArrayAllocate = hasNodeBuffer ? function(length4) {
  return Buffer.allocUnsafeSlow(length4);
} : Uint8Array;
var ByteArray = hasNodeBuffer ? Buffer : Uint8Array;
var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
var target;
var keysTarget;
var targetView;
var position2 = 0;
var safeEnd;
var bundledStrings2 = null;
var writeStructSlots;
var MAX_BUNDLE_SIZE = 21760;
var hasNonLatin = /[\u0080-\uFFFF]/;
var RECORD_SYMBOL = Symbol("record-id");

class Packr extends Unpackr {
  constructor(options6) {
    super(options6);
    this.offset = 0;
    let typeBuffer;
    let start3;
    let hasSharedUpdate;
    let structures;
    let referenceMap2;
    let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string8, position3) {
      return target.utf8Write(string8, position3, target.byteLength - position3);
    } : textEncoder && textEncoder.encodeInto ? function(string8, position3) {
      return textEncoder.encodeInto(string8, target.subarray(position3)).written;
    } : false;
    let packr = this;
    if (!options6)
      options6 = {};
    let isSequential2 = options6 && options6.sequential;
    let hasSharedStructures = options6.structures || options6.saveStructures;
    let maxSharedStructures = options6.maxSharedStructures;
    if (maxSharedStructures == null)
      maxSharedStructures = hasSharedStructures ? 32 : 0;
    if (maxSharedStructures > 8160)
      throw new Error("Maximum maxSharedStructure is 8160");
    if (options6.structuredClone && options6.moreTypes == undefined) {
      this.moreTypes = true;
    }
    let maxOwnStructures = options6.maxOwnStructures;
    if (maxOwnStructures == null)
      maxOwnStructures = hasSharedStructures ? 32 : 64;
    if (!this.structures && options6.useRecords != false)
      this.structures = [];
    let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;
    let sharedLimitId = maxSharedStructures + 64;
    let maxStructureId = maxSharedStructures + maxOwnStructures + 64;
    if (maxStructureId > 8256) {
      throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
    }
    let recordIdsToRemove = [];
    let transitionsCount = 0;
    let serializationsSinceTransitionRebuild = 0;
    this.pack = this.encode = function(value6, encodeOptions) {
      if (!target) {
        target = new ByteArrayAllocate(8192);
        targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));
        position2 = 0;
      }
      safeEnd = target.length - 10;
      if (safeEnd - position2 < 2048) {
        target = new ByteArrayAllocate(target.length);
        targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));
        safeEnd = target.length - 10;
        position2 = 0;
      } else
        position2 = position2 + 7 & 2147483640;
      start3 = position2;
      if (encodeOptions & RESERVE_START_SPACE)
        position2 += encodeOptions & 255;
      referenceMap2 = packr.structuredClone ? new Map : null;
      if (packr.bundleStrings && typeof value6 !== "string") {
        bundledStrings2 = [];
        bundledStrings2.size = Infinity;
      } else
        bundledStrings2 = null;
      structures = packr.structures;
      if (structures) {
        if (structures.uninitialized)
          structures = packr._mergeStructures(packr.getStructures());
        let sharedLength = structures.sharedLength || 0;
        if (sharedLength > maxSharedStructures) {
          throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + structures.sharedLength);
        }
        if (!structures.transitions) {
          structures.transitions = Object.create(null);
          for (let i = 0;i < sharedLength; i++) {
            let keys6 = structures[i];
            if (!keys6)
              continue;
            let nextTransition, transition = structures.transitions;
            for (let j = 0, l = keys6.length;j < l; j++) {
              let key = keys6[j];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = Object.create(null);
              }
              transition = nextTransition;
            }
            transition[RECORD_SYMBOL] = i + 64;
          }
          this.lastNamedStructuresLength = sharedLength;
        }
        if (!isSequential2) {
          structures.nextId = sharedLength + 64;
        }
      }
      if (hasSharedUpdate)
        hasSharedUpdate = false;
      let encodingError;
      try {
        if (packr.randomAccessStructure && value6 && value6.constructor && value6.constructor === Object)
          writeStruct(value6);
        else
          pack2(value6);
        let lastBundle = bundledStrings2;
        if (bundledStrings2)
          writeBundles(start3, pack2, 0);
        if (referenceMap2 && referenceMap2.idsToInsert) {
          let idsToInsert = referenceMap2.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
          let i = idsToInsert.length;
          let incrementPosition = -1;
          while (lastBundle && i > 0) {
            let insertionPoint = idsToInsert[--i].offset + start3;
            if (insertionPoint < lastBundle.stringsPosition + start3 && incrementPosition === -1)
              incrementPosition = 0;
            if (insertionPoint > lastBundle.position + start3) {
              if (incrementPosition >= 0)
                incrementPosition += 6;
            } else {
              if (incrementPosition >= 0) {
                targetView.setUint32(lastBundle.position + start3, targetView.getUint32(lastBundle.position + start3) + incrementPosition);
                incrementPosition = -1;
              }
              lastBundle = lastBundle.previous;
              i++;
            }
          }
          if (incrementPosition >= 0 && lastBundle) {
            targetView.setUint32(lastBundle.position + start3, targetView.getUint32(lastBundle.position + start3) + incrementPosition);
          }
          position2 += idsToInsert.length * 6;
          if (position2 > safeEnd)
            makeRoom(position2);
          packr.offset = position2;
          let serialized = insertIds(target.subarray(start3, position2), idsToInsert);
          referenceMap2 = null;
          return serialized;
        }
        packr.offset = position2;
        if (encodeOptions & REUSE_BUFFER_MODE) {
          target.start = start3;
          target.end = position2;
          return target;
        }
        return target.subarray(start3, position2);
      } catch (error5) {
        encodingError = error5;
        throw error5;
      } finally {
        if (structures) {
          resetStructures();
          if (hasSharedUpdate && packr.saveStructures) {
            let sharedLength = structures.sharedLength || 0;
            let returnBuffer = target.subarray(start3, position2);
            let newSharedData = prepareStructures(structures, packr);
            if (!encodingError) {
              if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
                return packr.pack(value6, encodeOptions);
              }
              packr.lastNamedStructuresLength = sharedLength;
              if (target.length > 1073741824)
                target = null;
              return returnBuffer;
            }
          }
        }
        if (target.length > 1073741824)
          target = null;
        if (encodeOptions & RESET_BUFFER_MODE)
          position2 = start3;
      }
    };
    const resetStructures = () => {
      if (serializationsSinceTransitionRebuild < 10)
        serializationsSinceTransitionRebuild++;
      let sharedLength = structures.sharedLength || 0;
      if (structures.length > sharedLength && !isSequential2)
        structures.length = sharedLength;
      if (transitionsCount > 1e4) {
        structures.transitions = null;
        serializationsSinceTransitionRebuild = 0;
        transitionsCount = 0;
        if (recordIdsToRemove.length > 0)
          recordIdsToRemove = [];
      } else if (recordIdsToRemove.length > 0 && !isSequential2) {
        for (let i = 0, l = recordIdsToRemove.length;i < l; i++) {
          recordIdsToRemove[i][RECORD_SYMBOL] = 0;
        }
        recordIdsToRemove = [];
      }
    };
    const packArray = (value6) => {
      var length4 = value6.length;
      if (length4 < 16) {
        target[position2++] = 144 | length4;
      } else if (length4 < 65536) {
        target[position2++] = 220;
        target[position2++] = length4 >> 8;
        target[position2++] = length4 & 255;
      } else {
        target[position2++] = 221;
        targetView.setUint32(position2, length4);
        position2 += 4;
      }
      for (let i = 0;i < length4; i++) {
        pack2(value6[i]);
      }
    };
    const pack2 = (value6) => {
      if (position2 > safeEnd)
        target = makeRoom(position2);
      var type2 = typeof value6;
      var length4;
      if (type2 === "string") {
        let strLength = value6.length;
        if (bundledStrings2 && strLength >= 4 && strLength < 4096) {
          if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
            let extStart;
            let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
            if (position2 + maxBytes2 > safeEnd)
              target = makeRoom(position2 + maxBytes2);
            let lastBundle;
            if (bundledStrings2.position) {
              lastBundle = bundledStrings2;
              target[position2] = 200;
              position2 += 3;
              target[position2++] = 98;
              extStart = position2 - start3;
              position2 += 4;
              writeBundles(start3, pack2, 0);
              targetView.setUint16(extStart + start3 - 3, position2 - start3 - extStart);
            } else {
              target[position2++] = 214;
              target[position2++] = 98;
              extStart = position2 - start3;
              position2 += 4;
            }
            bundledStrings2 = ["", ""];
            bundledStrings2.previous = lastBundle;
            bundledStrings2.size = 0;
            bundledStrings2.position = extStart;
          }
          let twoByte = hasNonLatin.test(value6);
          bundledStrings2[twoByte ? 0 : 1] += value6;
          target[position2++] = 193;
          pack2(twoByte ? -strLength : strLength);
          return;
        }
        let headerSize;
        if (strLength < 32) {
          headerSize = 1;
        } else if (strLength < 256) {
          headerSize = 2;
        } else if (strLength < 65536) {
          headerSize = 3;
        } else {
          headerSize = 5;
        }
        let maxBytes = strLength * 3;
        if (position2 + maxBytes > safeEnd)
          target = makeRoom(position2 + maxBytes);
        if (strLength < 64 || !encodeUtf8) {
          let i, c1, c2, strPosition = position2 + headerSize;
          for (i = 0;i < strLength; i++) {
            c1 = value6.charCodeAt(i);
            if (c1 < 128) {
              target[strPosition++] = c1;
            } else if (c1 < 2048) {
              target[strPosition++] = c1 >> 6 | 192;
              target[strPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value6.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target[strPosition++] = c1 >> 18 | 240;
              target[strPosition++] = c1 >> 12 & 63 | 128;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            } else {
              target[strPosition++] = c1 >> 12 | 224;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            }
          }
          length4 = strPosition - position2 - headerSize;
        } else {
          length4 = encodeUtf8(value6, position2 + headerSize);
        }
        if (length4 < 32) {
          target[position2++] = 160 | length4;
        } else if (length4 < 256) {
          if (headerSize < 2) {
            target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length4);
          }
          target[position2++] = 217;
          target[position2++] = length4;
        } else if (length4 < 65536) {
          if (headerSize < 3) {
            target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length4);
          }
          target[position2++] = 218;
          target[position2++] = length4 >> 8;
          target[position2++] = length4 & 255;
        } else {
          if (headerSize < 5) {
            target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length4);
          }
          target[position2++] = 219;
          targetView.setUint32(position2, length4);
          position2 += 4;
        }
        position2 += length4;
      } else if (type2 === "number") {
        if (value6 >>> 0 === value6) {
          if (value6 < 32 || value6 < 128 && this.useRecords === false || value6 < 64 && !this.randomAccessStructure) {
            target[position2++] = value6;
          } else if (value6 < 256) {
            target[position2++] = 204;
            target[position2++] = value6;
          } else if (value6 < 65536) {
            target[position2++] = 205;
            target[position2++] = value6 >> 8;
            target[position2++] = value6 & 255;
          } else {
            target[position2++] = 206;
            targetView.setUint32(position2, value6);
            position2 += 4;
          }
        } else if (value6 >> 0 === value6) {
          if (value6 >= -32) {
            target[position2++] = 256 + value6;
          } else if (value6 >= -128) {
            target[position2++] = 208;
            target[position2++] = value6 + 256;
          } else if (value6 >= -32768) {
            target[position2++] = 209;
            targetView.setInt16(position2, value6);
            position2 += 2;
          } else {
            target[position2++] = 210;
            targetView.setInt32(position2, value6);
            position2 += 4;
          }
        } else {
          let useFloat32;
          if ((useFloat32 = this.useFloat32) > 0 && value6 < 4294967296 && value6 >= -2147483648) {
            target[position2++] = 202;
            targetView.setFloat32(position2, value6);
            let xShifted;
            if (useFloat32 < 4 || (xShifted = value6 * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
              position2 += 4;
              return;
            } else
              position2--;
          }
          target[position2++] = 203;
          targetView.setFloat64(position2, value6);
          position2 += 8;
        }
      } else if (type2 === "object" || type2 === "function") {
        if (!value6)
          target[position2++] = 192;
        else {
          if (referenceMap2) {
            let referee = referenceMap2.get(value6);
            if (referee) {
              if (!referee.id) {
                let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                referee.id = idsToInsert.push(referee);
              }
              target[position2++] = 214;
              target[position2++] = 112;
              targetView.setUint32(position2, referee.id);
              position2 += 4;
              return;
            } else
              referenceMap2.set(value6, { offset: position2 - start3 });
          }
          let constructor = value6.constructor;
          if (constructor === Object) {
            writeObject(value6);
          } else if (constructor === Array) {
            packArray(value6);
          } else if (constructor === Map) {
            if (this.mapAsEmptyObject)
              target[position2++] = 128;
            else {
              length4 = value6.size;
              if (length4 < 16) {
                target[position2++] = 128 | length4;
              } else if (length4 < 65536) {
                target[position2++] = 222;
                target[position2++] = length4 >> 8;
                target[position2++] = length4 & 255;
              } else {
                target[position2++] = 223;
                targetView.setUint32(position2, length4);
                position2 += 4;
              }
              for (let [key, entryValue] of value6) {
                pack2(key);
                pack2(entryValue);
              }
            }
          } else {
            for (let i = 0, l = extensions.length;i < l; i++) {
              let extensionClass = extensionClasses[i];
              if (value6 instanceof extensionClass) {
                let extension = extensions[i];
                if (extension.write) {
                  if (extension.type) {
                    target[position2++] = 212;
                    target[position2++] = extension.type;
                    target[position2++] = 0;
                  }
                  let writeResult = extension.write.call(this, value6);
                  if (writeResult === value6) {
                    if (Array.isArray(value6)) {
                      packArray(value6);
                    } else {
                      writeObject(value6);
                    }
                  } else {
                    pack2(writeResult);
                  }
                  return;
                }
                let currentTarget = target;
                let currentTargetView = targetView;
                let currentPosition = position2;
                target = null;
                let result;
                try {
                  result = extension.pack.call(this, value6, (size17) => {
                    target = currentTarget;
                    currentTarget = null;
                    position2 += size17;
                    if (position2 > safeEnd)
                      makeRoom(position2);
                    return {
                      target,
                      targetView,
                      position: position2 - size17
                    };
                  }, pack2);
                } finally {
                  if (currentTarget) {
                    target = currentTarget;
                    targetView = currentTargetView;
                    position2 = currentPosition;
                    safeEnd = target.length - 10;
                  }
                }
                if (result) {
                  if (result.length + position2 > safeEnd)
                    makeRoom(result.length + position2);
                  position2 = writeExtensionData(result, target, position2, extension.type);
                }
                return;
              }
            }
            if (Array.isArray(value6)) {
              packArray(value6);
            } else {
              if (value6.toJSON) {
                const json3 = value6.toJSON();
                if (json3 !== value6)
                  return pack2(json3);
              }
              if (type2 === "function")
                return pack2(this.writeFunction && this.writeFunction(value6));
              writeObject(value6);
            }
          }
        }
      } else if (type2 === "boolean") {
        target[position2++] = value6 ? 195 : 194;
      } else if (type2 === "bigint") {
        if (value6 < 9223372036854776000 && value6 >= -9223372036854776000) {
          target[position2++] = 211;
          targetView.setBigInt64(position2, value6);
        } else if (value6 < 18446744073709552000 && value6 > 0) {
          target[position2++] = 207;
          targetView.setBigUint64(position2, value6);
        } else {
          if (this.largeBigIntToFloat) {
            target[position2++] = 203;
            targetView.setFloat64(position2, Number(value6));
          } else if (this.largeBigIntToString) {
            return pack2(value6.toString());
          } else if ((this.useBigIntExtension || this.moreTypes) && value6 < BigInt(2) ** BigInt(1023) && value6 > -(BigInt(2) ** BigInt(1023))) {
            target[position2++] = 199;
            position2++;
            target[position2++] = 66;
            let bytes = [];
            let alignedSign;
            do {
              let byte = value6 & BigInt(255);
              alignedSign = (byte & BigInt(128)) === (value6 < BigInt(0) ? BigInt(128) : BigInt(0));
              bytes.push(byte);
              value6 >>= BigInt(8);
            } while (!((value6 === BigInt(0) || value6 === BigInt(-1)) && alignedSign));
            target[position2 - 2] = bytes.length;
            for (let i = bytes.length;i > 0; ) {
              target[position2++] = Number(bytes[--i]);
            }
            return;
          } else {
            throw new RangeError(value6 + " was too large to fit in MessagePack 64-bit integer format, use" + " useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set" + " largeBigIntToString to convert to string");
          }
        }
        position2 += 8;
      } else if (type2 === "undefined") {
        if (this.encodeUndefinedAsNil)
          target[position2++] = 192;
        else {
          target[position2++] = 212;
          target[position2++] = 0;
          target[position2++] = 0;
        }
      } else {
        throw new Error("Unknown type: " + type2);
      }
    };
    const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? (object) => {
      let keys6;
      if (this.skipValues) {
        keys6 = [];
        for (let key2 in object) {
          if ((typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key2)) && !this.skipValues.includes(object[key2]))
            keys6.push(key2);
        }
      } else {
        keys6 = Object.keys(object);
      }
      let length4 = keys6.length;
      if (length4 < 16) {
        target[position2++] = 128 | length4;
      } else if (length4 < 65536) {
        target[position2++] = 222;
        target[position2++] = length4 >> 8;
        target[position2++] = length4 & 255;
      } else {
        target[position2++] = 223;
        targetView.setUint32(position2, length4);
        position2 += 4;
      }
      let key;
      if (this.coercibleKeyAsNumber) {
        for (let i = 0;i < length4; i++) {
          key = keys6[i];
          let num = Number(key);
          pack2(isNaN(num) ? key : num);
          pack2(object[key]);
        }
      } else {
        for (let i = 0;i < length4; i++) {
          pack2(key = keys6[i]);
          pack2(object[key]);
        }
      }
    } : (object) => {
      target[position2++] = 222;
      let objectOffset = position2 - start3;
      position2 += 2;
      let size17 = 0;
      for (let key in object) {
        if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
          pack2(key);
          pack2(object[key]);
          size17++;
        }
      }
      if (size17 > 65535) {
        throw new Error("Object is too large to serialize with fast 16-bit map size," + ' use the "variableMapSize" option to serialize this object');
      }
      target[objectOffset++ + start3] = size17 >> 8;
      target[objectOffset + start3] = size17 & 255;
    };
    const writeRecord = this.useRecords === false ? writePlainObject : options6.progressiveRecords && !useTwoByteRecords ? (object) => {
      let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));
      let objectOffset = position2++ - start3;
      let wroteKeys;
      for (let key in object) {
        if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
          nextTransition = transition[key];
          if (nextTransition)
            transition = nextTransition;
          else {
            let keys6 = Object.keys(object);
            let lastTransition = transition;
            transition = structures.transitions;
            let newTransitions = 0;
            for (let i = 0, l = keys6.length;i < l; i++) {
              let key2 = keys6[i];
              nextTransition = transition[key2];
              if (!nextTransition) {
                nextTransition = transition[key2] = Object.create(null);
                newTransitions++;
              }
              transition = nextTransition;
            }
            if (objectOffset + start3 + 1 == position2) {
              position2--;
              newRecord(transition, keys6, newTransitions);
            } else
              insertNewRecord(transition, keys6, objectOffset, newTransitions);
            wroteKeys = true;
            transition = lastTransition[key];
          }
          pack2(object[key]);
        }
      }
      if (!wroteKeys) {
        let recordId = transition[RECORD_SYMBOL];
        if (recordId)
          target[objectOffset + start3] = recordId;
        else
          insertNewRecord(transition, Object.keys(object), objectOffset, 0);
      }
    } : (object) => {
      let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));
      let newTransitions = 0;
      for (let key in object)
        if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
          nextTransition = transition[key];
          if (!nextTransition) {
            nextTransition = transition[key] = Object.create(null);
            newTransitions++;
          }
          transition = nextTransition;
        }
      let recordId = transition[RECORD_SYMBOL];
      if (recordId) {
        if (recordId >= 96 && useTwoByteRecords) {
          target[position2++] = ((recordId -= 96) & 31) + 96;
          target[position2++] = recordId >> 5;
        } else
          target[position2++] = recordId;
      } else {
        newRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);
      }
      for (let key in object)
        if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
          pack2(object[key]);
        }
    };
    const checkUseRecords = typeof this.useRecords == "function" && this.useRecords;
    const writeObject = checkUseRecords ? (object) => {
      checkUseRecords(object) ? writeRecord(object) : writePlainObject(object);
    } : writeRecord;
    const makeRoom = (end6) => {
      let newSize;
      if (end6 > 16777216) {
        if (end6 - start3 > MAX_BUFFER_SIZE)
          throw new Error("Packed buffer would be larger than maximum buffer size");
        newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end6 - start3) * (end6 > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
      } else
        newSize = (Math.max(end6 - start3 << 2, target.length - 1) >> 12) + 1 << 12;
      let newBuffer = new ByteArrayAllocate(newSize);
      targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));
      end6 = Math.min(end6, target.length);
      if (target.copy)
        target.copy(newBuffer, 0, start3, end6);
      else
        newBuffer.set(target.slice(start3, end6));
      position2 -= start3;
      start3 = 0;
      safeEnd = newBuffer.length - 10;
      return target = newBuffer;
    };
    const newRecord = (transition, keys6, newTransitions) => {
      let recordId = structures.nextId;
      if (!recordId)
        recordId = 64;
      if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys6)) {
        recordId = structures.nextOwnId;
        if (!(recordId < maxStructureId))
          recordId = sharedLimitId;
        structures.nextOwnId = recordId + 1;
      } else {
        if (recordId >= maxStructureId)
          recordId = sharedLimitId;
        structures.nextId = recordId + 1;
      }
      let highByte = keys6.highByte = recordId >= 96 && useTwoByteRecords ? recordId - 96 >> 5 : -1;
      transition[RECORD_SYMBOL] = recordId;
      transition.__keys__ = keys6;
      structures[recordId - 64] = keys6;
      if (recordId < sharedLimitId) {
        keys6.isShared = true;
        structures.sharedLength = recordId - 63;
        hasSharedUpdate = true;
        if (highByte >= 0) {
          target[position2++] = (recordId & 31) + 96;
          target[position2++] = highByte;
        } else {
          target[position2++] = recordId;
        }
      } else {
        if (highByte >= 0) {
          target[position2++] = 213;
          target[position2++] = 114;
          target[position2++] = (recordId & 31) + 96;
          target[position2++] = highByte;
        } else {
          target[position2++] = 212;
          target[position2++] = 114;
          target[position2++] = recordId;
        }
        if (newTransitions)
          transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
        if (recordIdsToRemove.length >= maxOwnStructures)
          recordIdsToRemove.shift()[RECORD_SYMBOL] = 0;
        recordIdsToRemove.push(transition);
        pack2(keys6);
      }
    };
    const insertNewRecord = (transition, keys6, insertionOffset, newTransitions) => {
      let mainTarget = target;
      let mainPosition = position2;
      let mainSafeEnd = safeEnd;
      let mainStart = start3;
      target = keysTarget;
      position2 = 0;
      start3 = 0;
      if (!target)
        keysTarget = target = new ByteArrayAllocate(8192);
      safeEnd = target.length - 10;
      newRecord(transition, keys6, newTransitions);
      keysTarget = target;
      let keysPosition = position2;
      target = mainTarget;
      position2 = mainPosition;
      safeEnd = mainSafeEnd;
      start3 = mainStart;
      if (keysPosition > 1) {
        let newEnd = position2 + keysPosition - 1;
        if (newEnd > safeEnd)
          makeRoom(newEnd);
        let insertionPosition = insertionOffset + start3;
        target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position2);
        target.set(keysTarget.slice(0, keysPosition), insertionPosition);
        position2 = newEnd;
      } else {
        target[insertionOffset + start3] = keysTarget[0];
      }
    };
    const writeStruct = (object) => {
      let newPosition = writeStructSlots(object, target, start3, position2, structures, makeRoom, (value6, newPosition2, notifySharedUpdate) => {
        if (notifySharedUpdate)
          return hasSharedUpdate = true;
        position2 = newPosition2;
        let startTarget = target;
        pack2(value6);
        resetStructures();
        if (startTarget !== target) {
          return { position: position2, targetView, target };
        }
        return position2;
      }, this);
      if (newPosition === 0)
        return writeObject(object);
      position2 = newPosition;
    };
  }
  useBuffer(buffer4) {
    target = buffer4;
    target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));
    position2 = 0;
  }
  set position(value6) {
    position2 = value6;
  }
  get position() {
    return position2;
  }
  clearSharedData() {
    if (this.structures)
      this.structures = [];
    if (this.typedStructs)
      this.typedStructs = [];
  }
}
extensionClasses = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, DataView, C1Type];
extensions = [{
  pack(date8, allocateForWrite, pack2) {
    let seconds2 = date8.getTime() / 1000;
    if ((this.useTimestamp32 || date8.getMilliseconds() === 0) && seconds2 >= 0 && seconds2 < 4294967296) {
      let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(6);
      target2[position3++] = 214;
      target2[position3++] = 255;
      targetView2.setUint32(position3, seconds2);
    } else if (seconds2 > 0 && seconds2 < 4294967296) {
      let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(10);
      target2[position3++] = 215;
      target2[position3++] = 255;
      targetView2.setUint32(position3, date8.getMilliseconds() * 4000000 + (seconds2 / 1000 / 4294967296 >> 0));
      targetView2.setUint32(position3 + 4, seconds2);
    } else if (isNaN(seconds2)) {
      if (this.onInvalidDate) {
        allocateForWrite(0);
        return pack2(this.onInvalidDate());
      }
      let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(3);
      target2[position3++] = 212;
      target2[position3++] = 255;
      target2[position3++] = 255;
    } else {
      let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(15);
      target2[position3++] = 199;
      target2[position3++] = 12;
      target2[position3++] = 255;
      targetView2.setUint32(position3, date8.getMilliseconds() * 1e6);
      targetView2.setBigInt64(position3 + 4, BigInt(Math.floor(seconds2)));
    }
  }
}, {
  pack(set13, allocateForWrite, pack2) {
    if (this.setAsEmptyObject) {
      allocateForWrite(0);
      return pack2({});
    }
    let array9 = Array.from(set13);
    let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target2[position3++] = 212;
      target2[position3++] = 115;
      target2[position3++] = 0;
    }
    pack2(array9);
  }
}, {
  pack(error5, allocateForWrite, pack2) {
    let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target2[position3++] = 212;
      target2[position3++] = 101;
      target2[position3++] = 0;
    }
    pack2([error5.name, error5.message, error5.cause]);
  }
}, {
  pack(regex, allocateForWrite, pack2) {
    let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target2[position3++] = 212;
      target2[position3++] = 120;
      target2[position3++] = 0;
    }
    pack2([regex.source, regex.flags]);
  }
}, {
  pack(arrayBuffer, allocateForWrite) {
    if (this.moreTypes)
      writeExtBuffer(arrayBuffer, 16, allocateForWrite);
    else
      writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
  }
}, {
  pack(typedArray, allocateForWrite) {
    let constructor = typedArray.constructor;
    if (constructor !== ByteArray && this.moreTypes)
      writeExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);
    else
      writeBuffer(typedArray, allocateForWrite);
  }
}, {
  pack(arrayBuffer, allocateForWrite) {
    if (this.moreTypes)
      writeExtBuffer(arrayBuffer, 17, allocateForWrite);
    else
      writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
  }
}, {
  pack(c1, allocateForWrite) {
    let { target: target2, position: position3 } = allocateForWrite(1);
    target2[position3] = 193;
  }
}];
function writeExtBuffer(typedArray, type2, allocateForWrite, encode5) {
  let length4 = typedArray.byteLength;
  if (length4 + 1 < 256) {
    var { target: target2, position: position3 } = allocateForWrite(4 + length4);
    target2[position3++] = 199;
    target2[position3++] = length4 + 1;
  } else if (length4 + 1 < 65536) {
    var { target: target2, position: position3 } = allocateForWrite(5 + length4);
    target2[position3++] = 200;
    target2[position3++] = length4 + 1 >> 8;
    target2[position3++] = length4 + 1 & 255;
  } else {
    var { target: target2, position: position3, targetView: targetView2 } = allocateForWrite(7 + length4);
    target2[position3++] = 201;
    targetView2.setUint32(position3, length4 + 1);
    position3 += 4;
  }
  target2[position3++] = 116;
  target2[position3++] = type2;
  if (!typedArray.buffer)
    typedArray = new Uint8Array(typedArray);
  target2.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position3);
}
function writeBuffer(buffer4, allocateForWrite) {
  let length4 = buffer4.byteLength;
  var target2, position3;
  if (length4 < 256) {
    var { target: target2, position: position3 } = allocateForWrite(length4 + 2);
    target2[position3++] = 196;
    target2[position3++] = length4;
  } else if (length4 < 65536) {
    var { target: target2, position: position3 } = allocateForWrite(length4 + 3);
    target2[position3++] = 197;
    target2[position3++] = length4 >> 8;
    target2[position3++] = length4 & 255;
  } else {
    var { target: target2, position: position3, targetView: targetView2 } = allocateForWrite(length4 + 5);
    target2[position3++] = 198;
    targetView2.setUint32(position3, length4);
    position3 += 4;
  }
  target2.set(buffer4, position3);
}
function writeExtensionData(result, target2, position3, type2) {
  let length4 = result.length;
  switch (length4) {
    case 1:
      target2[position3++] = 212;
      break;
    case 2:
      target2[position3++] = 213;
      break;
    case 4:
      target2[position3++] = 214;
      break;
    case 8:
      target2[position3++] = 215;
      break;
    case 16:
      target2[position3++] = 216;
      break;
    default:
      if (length4 < 256) {
        target2[position3++] = 199;
        target2[position3++] = length4;
      } else if (length4 < 65536) {
        target2[position3++] = 200;
        target2[position3++] = length4 >> 8;
        target2[position3++] = length4 & 255;
      } else {
        target2[position3++] = 201;
        target2[position3++] = length4 >> 24;
        target2[position3++] = length4 >> 16 & 255;
        target2[position3++] = length4 >> 8 & 255;
        target2[position3++] = length4 & 255;
      }
  }
  target2[position3++] = type2;
  target2.set(result, position3);
  position3 += length4;
  return position3;
}
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 6;
  let lastEnd = serialized.length - distanceToMove;
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    let id2 = nextId.id;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 6;
    let position3 = offset + distanceToMove;
    serialized[position3++] = 214;
    serialized[position3++] = 105;
    serialized[position3++] = id2 >> 24;
    serialized[position3++] = id2 >> 16 & 255;
    serialized[position3++] = id2 >> 8 & 255;
    serialized[position3++] = id2 & 255;
    lastEnd = offset;
  }
  return serialized;
}
function writeBundles(start3, pack2, incrementPosition) {
  if (bundledStrings2.length > 0) {
    targetView.setUint32(bundledStrings2.position + start3, position2 + incrementPosition - bundledStrings2.position - start3);
    bundledStrings2.stringsPosition = position2 - start3;
    let writeStrings = bundledStrings2;
    bundledStrings2 = null;
    pack2(writeStrings[0]);
    pack2(writeStrings[1]);
  }
}
function prepareStructures(structures, packr) {
  structures.isCompatible = (existingStructures) => {
    let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;
    if (!compatible)
      packr._mergeStructures(existingStructures);
    return compatible;
  };
  return structures;
}
function setWriteStructSlots(writeSlots, makeStructures) {
  writeStructSlots = writeSlots;
  prepareStructures = makeStructures;
}
var defaultPackr = new Packr({ useRecords: false });
var pack2 = defaultPackr.pack;
var encode5 = defaultPackr.pack;
var REUSE_BUFFER_MODE = 512;
var RESET_BUFFER_MODE = 1024;
var RESERVE_START_SPACE = 2048;
// node_modules/msgpackr/struct.js
var ASCII = 3;
var NUMBER = 0;
var UTF8 = 2;
var OBJECT_DATA = 1;
var DATE = 16;
var TYPE_NAMES = ["num", "object", "string", "ascii"];
TYPE_NAMES[DATE] = "date";
var float32Headers = [false, true, true, false, false, true, true, false];
var evalSupported;
try {
  new Function("");
  evalSupported = true;
} catch (error5) {}
var updatedPosition;
var hasNodeBuffer2 = typeof Buffer !== "undefined";
var textEncoder2;
var currentSource;
try {
  textEncoder2 = new TextEncoder;
} catch (error5) {}
var encodeUtf8 = hasNodeBuffer2 ? function(target2, string8, position3) {
  return target2.utf8Write(string8, position3, target2.byteLength - position3);
} : textEncoder2 && textEncoder2.encodeInto ? function(target2, string8, position3) {
  return textEncoder2.encodeInto(string8, target2.subarray(position3)).written;
} : false;
var TYPE = Symbol("type");
var PARENT = Symbol("parent");
setWriteStructSlots(writeStruct, prepareStructures2);
function writeStruct(object, target2, encodingStart, position3, structures, makeRoom, pack3, packr) {
  let typedStructs = packr.typedStructs || (packr.typedStructs = []);
  let targetView2 = target2.dataView;
  let refsStartPosition = (typedStructs.lastStringStart || 100) + position3;
  let safeEnd2 = target2.length - 10;
  let start3 = position3;
  if (position3 > safeEnd2) {
    target2 = makeRoom(position3);
    targetView2 = target2.dataView;
    position3 -= encodingStart;
    start3 -= encodingStart;
    refsStartPosition -= encodingStart;
    encodingStart = 0;
    safeEnd2 = target2.length - 10;
  }
  let refOffset, refPosition = refsStartPosition;
  let transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));
  let nextId = typedStructs.nextId || typedStructs.length;
  let headerSize = nextId < 15 ? 1 : nextId < 240 ? 2 : nextId < 61440 ? 3 : nextId < 15728640 ? 4 : 0;
  if (headerSize === 0)
    return 0;
  position3 += headerSize;
  let queuedReferences = [];
  let usedAscii0;
  let keyIndex = 0;
  for (let key in object) {
    let value6 = object[key];
    let nextTransition = transition[key];
    if (!nextTransition) {
      transition[key] = nextTransition = {
        key,
        parent: transition,
        enumerationOffset: 0,
        ascii0: null,
        ascii8: null,
        num8: null,
        string16: null,
        object16: null,
        num32: null,
        float64: null,
        date64: null
      };
    }
    if (position3 > safeEnd2) {
      target2 = makeRoom(position3);
      targetView2 = target2.dataView;
      position3 -= encodingStart;
      start3 -= encodingStart;
      refsStartPosition -= encodingStart;
      refPosition -= encodingStart;
      encodingStart = 0;
      safeEnd2 = target2.length - 10;
    }
    switch (typeof value6) {
      case "number":
        let number6 = value6;
        if (nextId < 200 || !nextTransition.num64) {
          if (number6 >> 0 === number6 && number6 < 536870912 && number6 > -520093696) {
            if (number6 < 246 && number6 >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number6 < 32 && !nextTransition.num32)) {
              transition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);
              target2[position3++] = number6;
            } else {
              transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);
              targetView2.setUint32(position3, number6, true);
              position3 += 4;
            }
            break;
          } else if (number6 < 4294967296 && number6 >= -2147483648) {
            targetView2.setFloat32(position3, number6, true);
            if (float32Headers[target2[position3 + 3] >>> 5]) {
              let xShifted;
              if ((xShifted = number6 * mult10[(target2[position3 + 3] & 127) << 1 | target2[position3 + 2] >> 7]) >> 0 === xShifted) {
                transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);
                position3 += 4;
                break;
              }
            }
          }
        }
        transition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);
        targetView2.setFloat64(position3, number6, true);
        position3 += 8;
        break;
      case "string":
        let strLength = value6.length;
        refOffset = refPosition - refsStartPosition;
        if ((strLength << 2) + refPosition > safeEnd2) {
          target2 = makeRoom((strLength << 2) + refPosition);
          targetView2 = target2.dataView;
          position3 -= encodingStart;
          start3 -= encodingStart;
          refsStartPosition -= encodingStart;
          refPosition -= encodingStart;
          encodingStart = 0;
          safeEnd2 = target2.length - 10;
        }
        if (strLength > 65280 + refOffset >> 2) {
          queuedReferences.push(key, value6, position3 - start3);
          break;
        }
        let isNotAscii;
        let strStart = refPosition;
        if (strLength < 64) {
          let i, c1, c2;
          for (i = 0;i < strLength; i++) {
            c1 = value6.charCodeAt(i);
            if (c1 < 128) {
              target2[refPosition++] = c1;
            } else if (c1 < 2048) {
              isNotAscii = true;
              target2[refPosition++] = c1 >> 6 | 192;
              target2[refPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value6.charCodeAt(i + 1)) & 64512) === 56320) {
              isNotAscii = true;
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target2[refPosition++] = c1 >> 18 | 240;
              target2[refPosition++] = c1 >> 12 & 63 | 128;
              target2[refPosition++] = c1 >> 6 & 63 | 128;
              target2[refPosition++] = c1 & 63 | 128;
            } else {
              isNotAscii = true;
              target2[refPosition++] = c1 >> 12 | 224;
              target2[refPosition++] = c1 >> 6 & 63 | 128;
              target2[refPosition++] = c1 & 63 | 128;
            }
          }
        } else {
          refPosition += encodeUtf8(target2, value6, refPosition);
          isNotAscii = refPosition - strStart > strLength;
        }
        if (refOffset < 160 || refOffset < 246 && (nextTransition.ascii8 || nextTransition.string8)) {
          if (isNotAscii) {
            if (!(transition = nextTransition.string8)) {
              if (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {
                transition.__type = UTF8;
                nextTransition.ascii8 = null;
                nextTransition.string8 = transition;
                pack3(null, 0, true);
              } else {
                transition = createTypeTransition(nextTransition, UTF8, 1);
              }
            }
          } else if (refOffset === 0 && !usedAscii0) {
            usedAscii0 = true;
            transition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);
            break;
          } else if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))
            transition = createTypeTransition(nextTransition, ASCII, 1);
          target2[position3++] = refOffset;
        } else {
          transition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);
          targetView2.setUint16(position3, refOffset, true);
          position3 += 2;
        }
        break;
      case "object":
        if (value6) {
          if (value6.constructor === Date) {
            transition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);
            targetView2.setFloat64(position3, value6.getTime(), true);
            position3 += 8;
          } else {
            queuedReferences.push(key, value6, keyIndex);
          }
          break;
        } else {
          nextTransition = anyType(nextTransition, position3, targetView2, -10);
          if (nextTransition) {
            transition = nextTransition;
            position3 = updatedPosition;
          } else
            queuedReferences.push(key, value6, keyIndex);
        }
        break;
      case "boolean":
        transition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);
        target2[position3++] = value6 ? 249 : 248;
        break;
      case "undefined":
        nextTransition = anyType(nextTransition, position3, targetView2, -9);
        if (nextTransition) {
          transition = nextTransition;
          position3 = updatedPosition;
        } else
          queuedReferences.push(key, value6, keyIndex);
        break;
      default:
        queuedReferences.push(key, value6, keyIndex);
    }
    keyIndex++;
  }
  for (let i = 0, l = queuedReferences.length;i < l; ) {
    let key = queuedReferences[i++];
    let value6 = queuedReferences[i++];
    let propertyIndex = queuedReferences[i++];
    let nextTransition = transition[key];
    if (!nextTransition) {
      transition[key] = nextTransition = {
        key,
        parent: transition,
        enumerationOffset: propertyIndex - keyIndex,
        ascii0: null,
        ascii8: null,
        num8: null,
        string16: null,
        object16: null,
        num32: null,
        float64: null
      };
    }
    let newPosition;
    if (value6) {
      let size17;
      refOffset = refPosition - refsStartPosition;
      if (refOffset < 65280) {
        transition = nextTransition.object16;
        if (transition)
          size17 = 2;
        else if (transition = nextTransition.object32)
          size17 = 4;
        else {
          transition = createTypeTransition(nextTransition, OBJECT_DATA, 2);
          size17 = 2;
        }
      } else {
        transition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);
        size17 = 4;
      }
      newPosition = pack3(value6, refPosition);
      if (typeof newPosition === "object") {
        refPosition = newPosition.position;
        targetView2 = newPosition.targetView;
        target2 = newPosition.target;
        refsStartPosition -= encodingStart;
        position3 -= encodingStart;
        start3 -= encodingStart;
        encodingStart = 0;
      } else
        refPosition = newPosition;
      if (size17 === 2) {
        targetView2.setUint16(position3, refOffset, true);
        position3 += 2;
      } else {
        targetView2.setUint32(position3, refOffset, true);
        position3 += 4;
      }
    } else {
      transition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);
      targetView2.setInt16(position3, value6 === null ? -10 : -9, true);
      position3 += 2;
    }
    keyIndex++;
  }
  let recordId = transition[RECORD_SYMBOL];
  if (recordId == null) {
    recordId = packr.typedStructs.length;
    let structure2 = [];
    let nextTransition = transition;
    let key, type2;
    while ((type2 = nextTransition.__type) !== undefined) {
      let size17 = nextTransition.__size;
      nextTransition = nextTransition.__parent;
      key = nextTransition.key;
      let property = [type2, size17, key];
      if (nextTransition.enumerationOffset)
        property.push(nextTransition.enumerationOffset);
      structure2.push(property);
      nextTransition = nextTransition.parent;
    }
    structure2.reverse();
    transition[RECORD_SYMBOL] = recordId;
    packr.typedStructs[recordId] = structure2;
    pack3(null, 0, true);
  }
  switch (headerSize) {
    case 1:
      if (recordId >= 16)
        return 0;
      target2[start3] = recordId + 32;
      break;
    case 2:
      if (recordId >= 256)
        return 0;
      target2[start3] = 56;
      target2[start3 + 1] = recordId;
      break;
    case 3:
      if (recordId >= 65536)
        return 0;
      target2[start3] = 57;
      targetView2.setUint16(start3 + 1, recordId, true);
      break;
    case 4:
      if (recordId >= 16777216)
        return 0;
      targetView2.setUint32(start3, (recordId << 8) + 58, true);
      break;
  }
  if (position3 < refsStartPosition) {
    if (refsStartPosition === refPosition)
      return position3;
    target2.copyWithin(position3, refsStartPosition, refPosition);
    refPosition += position3 - refsStartPosition;
    typedStructs.lastStringStart = position3 - start3;
  } else if (position3 > refsStartPosition) {
    if (refsStartPosition === refPosition)
      return position3;
    typedStructs.lastStringStart = position3 - start3;
    return writeStruct(object, target2, encodingStart, start3, structures, makeRoom, pack3, packr);
  }
  return refPosition;
}
function anyType(transition, position3, targetView2, value6) {
  let nextTransition;
  if (nextTransition = transition.ascii8 || transition.num8) {
    targetView2.setInt8(position3, value6, true);
    updatedPosition = position3 + 1;
    return nextTransition;
  }
  if (nextTransition = transition.string16 || transition.object16) {
    targetView2.setInt16(position3, value6, true);
    updatedPosition = position3 + 2;
    return nextTransition;
  }
  if (nextTransition = transition.num32) {
    targetView2.setUint32(position3, 3758096640 + value6, true);
    updatedPosition = position3 + 4;
    return nextTransition;
  }
  if (nextTransition = transition.num64) {
    targetView2.setFloat64(position3, NaN, true);
    targetView2.setInt8(position3, value6);
    updatedPosition = position3 + 8;
    return nextTransition;
  }
  updatedPosition = position3;
  return;
}
function createTypeTransition(transition, type2, size17) {
  let typeName = TYPE_NAMES[type2] + (size17 << 3);
  let newTransition = transition[typeName] || (transition[typeName] = Object.create(null));
  newTransition.__type = type2;
  newTransition.__size = size17;
  newTransition.__parent = transition;
  return newTransition;
}
function onLoadedStructures2(sharedData) {
  if (!(sharedData instanceof Map))
    return sharedData;
  let typed = sharedData.get("typed") || [];
  if (Object.isFrozen(typed))
    typed = typed.map((structure2) => structure2.slice(0));
  let named2 = sharedData.get("named");
  let transitions = Object.create(null);
  for (let i = 0, l = typed.length;i < l; i++) {
    let structure2 = typed[i];
    let transition = transitions;
    for (let [type2, size17, key] of structure2) {
      let nextTransition = transition[key];
      if (!nextTransition) {
        transition[key] = nextTransition = {
          key,
          parent: transition,
          enumerationOffset: 0,
          ascii0: null,
          ascii8: null,
          num8: null,
          string16: null,
          object16: null,
          num32: null,
          float64: null,
          date64: null
        };
      }
      transition = createTypeTransition(nextTransition, type2, size17);
    }
    transition[RECORD_SYMBOL] = i;
  }
  typed.transitions = transitions;
  this.typedStructs = typed;
  this.lastTypedStructuresLength = typed.length;
  return named2;
}
var sourceSymbol = Symbol.for("source");
function readStruct2(src2, position3, srcEnd2, unpackr) {
  let recordId = src2[position3++] - 32;
  if (recordId >= 24) {
    switch (recordId) {
      case 24:
        recordId = src2[position3++];
        break;
      case 25:
        recordId = src2[position3++] + (src2[position3++] << 8);
        break;
      case 26:
        recordId = src2[position3++] + (src2[position3++] << 8) + (src2[position3++] << 16);
        break;
      case 27:
        recordId = src2[position3++] + (src2[position3++] << 8) + (src2[position3++] << 16) + (src2[position3++] << 24);
        break;
    }
  }
  let structure2 = unpackr.typedStructs && unpackr.typedStructs[recordId];
  if (!structure2) {
    src2 = Uint8Array.prototype.slice.call(src2, position3, srcEnd2);
    srcEnd2 -= position3;
    position3 = 0;
    if (!unpackr.getStructures)
      throw new Error(`Reference to shared structure ${recordId} without getStructures method`);
    unpackr._mergeStructures(unpackr.getStructures());
    if (!unpackr.typedStructs)
      throw new Error("Could not find any shared typed structures");
    unpackr.lastTypedStructuresLength = unpackr.typedStructs.length;
    structure2 = unpackr.typedStructs[recordId];
    if (!structure2)
      throw new Error("Could not find typed structure " + recordId);
  }
  var construct = structure2.construct;
  var fullConstruct = structure2.fullConstruct;
  if (!construct) {
    construct = structure2.construct = function LazyObject() {};
    fullConstruct = structure2.fullConstruct = function LoadedObject() {};
    fullConstruct.prototype = unpackr.structPrototype ?? {};
    var prototype = construct.prototype = unpackr.structPrototype ? Object.create(unpackr.structPrototype) : {};
    let properties = [];
    let currentOffset = 0;
    let lastRefProperty;
    for (let i = 0, l = structure2.length;i < l; i++) {
      let definition = structure2[i];
      let [type2, size17, key, enumerationOffset] = definition;
      if (key === "__proto__")
        key = "__proto_";
      let property = {
        key,
        offset: currentOffset
      };
      if (enumerationOffset)
        properties.splice(i + enumerationOffset, 0, property);
      else
        properties.push(property);
      let getRef;
      switch (size17) {
        case 0:
          getRef = () => 0;
          break;
        case 1:
          getRef = (source, position4) => {
            let ref = source.bytes[position4 + property.offset];
            return ref >= 246 ? toConstant(ref) : ref;
          };
          break;
        case 2:
          getRef = (source, position4) => {
            let src3 = source.bytes;
            let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
            let ref = dataView2.getUint16(position4 + property.offset, true);
            return ref >= 65280 ? toConstant(ref & 255) : ref;
          };
          break;
        case 4:
          getRef = (source, position4) => {
            let src3 = source.bytes;
            let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
            let ref = dataView2.getUint32(position4 + property.offset, true);
            return ref >= 4294967040 ? toConstant(ref & 255) : ref;
          };
          break;
      }
      property.getRef = getRef;
      currentOffset += size17;
      let get22;
      switch (type2) {
        case ASCII:
          if (lastRefProperty && !lastRefProperty.next)
            lastRefProperty.next = property;
          lastRefProperty = property;
          property.multiGetCount = 0;
          get22 = function(source) {
            let src3 = source.bytes;
            let position4 = source.position;
            let refStart = currentOffset + position4;
            let ref = getRef(source, position4);
            if (typeof ref !== "number")
              return ref;
            let end6, next4 = property.next;
            while (next4) {
              end6 = next4.getRef(source, position4);
              if (typeof end6 === "number")
                break;
              else
                end6 = null;
              next4 = next4.next;
            }
            if (end6 == null)
              end6 = source.bytesEnd - refStart;
            if (source.srcString) {
              return source.srcString.slice(ref, end6);
            }
            return readString2(src3, ref + refStart, end6 - ref);
          };
          break;
        case UTF8:
        case OBJECT_DATA:
          if (lastRefProperty && !lastRefProperty.next)
            lastRefProperty.next = property;
          lastRefProperty = property;
          get22 = function(source) {
            let position4 = source.position;
            let refStart = currentOffset + position4;
            let ref = getRef(source, position4);
            if (typeof ref !== "number")
              return ref;
            let src3 = source.bytes;
            let end6, next4 = property.next;
            while (next4) {
              end6 = next4.getRef(source, position4);
              if (typeof end6 === "number")
                break;
              else
                end6 = null;
              next4 = next4.next;
            }
            if (end6 == null)
              end6 = source.bytesEnd - refStart;
            if (type2 === UTF8) {
              return src3.toString("utf8", ref + refStart, end6 + refStart);
            } else {
              currentSource = source;
              try {
                return unpackr.unpack(src3, { start: ref + refStart, end: end6 + refStart });
              } finally {
                currentSource = null;
              }
            }
          };
          break;
        case NUMBER:
          switch (size17) {
            case 4:
              get22 = function(source) {
                let src3 = source.bytes;
                let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
                let position4 = source.position + property.offset;
                let value6 = dataView2.getInt32(position4, true);
                if (value6 < 536870912) {
                  if (value6 > -520093696)
                    return value6;
                  if (value6 > -536870912)
                    return toConstant(value6 & 255);
                }
                let fValue = dataView2.getFloat32(position4, true);
                let multiplier = mult10[(src3[position4 + 3] & 127) << 1 | src3[position4 + 2] >> 7];
                return (multiplier * fValue + (fValue > 0 ? 0.5 : -0.5) >> 0) / multiplier;
              };
              break;
            case 8:
              get22 = function(source) {
                let src3 = source.bytes;
                let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
                let value6 = dataView2.getFloat64(source.position + property.offset, true);
                if (isNaN(value6)) {
                  let byte = src3[source.position + property.offset];
                  if (byte >= 246)
                    return toConstant(byte);
                }
                return value6;
              };
              break;
            case 1:
              get22 = function(source) {
                let src3 = source.bytes;
                let value6 = src3[source.position + property.offset];
                return value6 < 246 ? value6 : toConstant(value6);
              };
              break;
          }
          break;
        case DATE:
          get22 = function(source) {
            let src3 = source.bytes;
            let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
            return new Date(dataView2.getFloat64(source.position + property.offset, true));
          };
          break;
      }
      property.get = get22;
    }
    if (evalSupported) {
      let objectLiteralProperties = [];
      let args2 = [];
      let i = 0;
      let hasInheritedProperties;
      for (let property of properties) {
        if (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {
          hasInheritedProperties = true;
          continue;
        }
        Object.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });
        let valueFunction = "v" + i++;
        args2.push(valueFunction);
        objectLiteralProperties.push("o[" + JSON.stringify(property.key) + "]=" + valueFunction + "(s)");
      }
      if (hasInheritedProperties) {
        objectLiteralProperties.push("__proto__:this");
      }
      let toObject = new Function(...args2, "var c=this;return function(s){var o=new c();" + objectLiteralProperties.join(";") + ";return o;}").apply(fullConstruct, properties.map((prop) => prop.get));
      Object.defineProperty(prototype, "toJSON", {
        value(omitUnderscoredProperties) {
          return toObject.call(this, this[sourceSymbol]);
        }
      });
    } else {
      Object.defineProperty(prototype, "toJSON", {
        value(omitUnderscoredProperties) {
          let resolved = {};
          for (let i = 0, l = properties.length;i < l; i++) {
            let key = properties[i].key;
            resolved[key] = this[key];
          }
          return resolved;
        }
      });
    }
  }
  var instance = new construct;
  instance[sourceSymbol] = {
    bytes: src2,
    position: position3,
    srcString: "",
    bytesEnd: srcEnd2
  };
  return instance;
}
function toConstant(code3) {
  switch (code3) {
    case 246:
      return null;
    case 247:
      return;
    case 248:
      return false;
    case 249:
      return true;
  }
  throw new Error("Unknown constant");
}
function withSource(get22) {
  return function() {
    return get22(this[sourceSymbol]);
  };
}
function saveState2() {
  if (currentSource) {
    currentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);
    currentSource.position = 0;
    currentSource.bytesEnd = currentSource.bytes.length;
  }
}
function prepareStructures2(structures, packr) {
  if (packr.typedStructs) {
    let structMap = new Map;
    structMap.set("named", structures);
    structMap.set("typed", packr.typedStructs);
    structures = structMap;
  }
  let lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;
  structures.isCompatible = (existing) => {
    let compatible = true;
    if (existing instanceof Map) {
      let named2 = existing.get("named") || [];
      if (named2.length !== (packr.lastNamedStructuresLength || 0))
        compatible = false;
      let typed = existing.get("typed") || [];
      if (typed.length !== lastTypedStructuresLength)
        compatible = false;
    } else if (existing instanceof Array || Array.isArray(existing)) {
      if (existing.length !== (packr.lastNamedStructuresLength || 0))
        compatible = false;
    }
    if (!compatible)
      packr._mergeStructures(existing);
    return compatible;
  };
  packr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;
  return structures;
}
setReadStruct(readStruct2, onLoadedStructures2, saveState2);
// node_modules/msgpackr/node-index.js
var nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === "true";
if (!nativeAccelerationDisabled) {
  let extractor;
  try {
    if (true)
      extractor = require_msgpackr_extract();
    else
      ;
    if (extractor)
      setExtractor(extractor.extractStrings);
  } catch (error5) {}
}

// node_modules/@effect/rpc/dist/esm/RpcServer.js
var makeNoSerialization = /* @__PURE__ */ fnUntraced2(function* (group6, options6) {
  const enableTracing = options6.disableTracing !== true;
  const enableSpanPropagation = options6.disableSpanPropagation !== true;
  const supportsAck = options6.disableClientAcks !== true;
  const spanPrefix = options6.spanPrefix ?? "RpcServer";
  const concurrency = options6.concurrency ?? "unbounded";
  const context9 = yield* context3();
  const scope5 = get3(context9, Scope);
  const fiberSet = yield* make82();
  const runFork4 = yield* runtime5(fiberSet)().pipe(interruptible4);
  const concurrencySemaphore = concurrency === "unbounded" ? undefined : yield* makeSemaphore2(concurrency);
  const clients = new Map;
  let isShutdown7 = false;
  const shutdownLatch = unsafeMakeLatch2(false);
  yield* addFinalizer2(scope5, fiberIdWith2((fiberId3) => {
    isShutdown7 = true;
    for (const client of clients.values()) {
      client.ended = true;
      if (client.fibers.size === 0) {
        runFork4(endClient(client));
        continue;
      }
      for (const fiber of client.fibers.values()) {
        fiber.unsafeInterruptAsFork(fiberId3);
      }
    }
    if (clients.size === 0) {
      return _void;
    }
    return shutdownLatch.await;
  }));
  const disconnect3 = (clientId) => fiberIdWith2((fiberId3) => {
    const client = clients.get(clientId);
    if (!client)
      return _void;
    for (const fiber of client.fibers.values()) {
      fiber.unsafeInterruptAsFork(fiberId3);
    }
    clients.delete(clientId);
    return _void;
  });
  const write3 = (clientId, message) => catchAllDefect2(withFiberRuntime2((requestFiber) => {
    if (isShutdown7)
      return interrupt7;
    let client = clients.get(clientId);
    if (!client) {
      client = {
        id: clientId,
        latches: new Map,
        fibers: new Map,
        ended: false
      };
      clients.set(clientId, client);
    } else if (client.ended) {
      return interrupt7;
    }
    switch (message._tag) {
      case "Request": {
        return handleRequest(requestFiber, client, message);
      }
      case "Ack": {
        const latch = client.latches.get(message.requestId);
        return latch ? latch.open : _void;
      }
      case "Interrupt": {
        const fiber = client.fibers.get(message.requestId);
        return fiber ? interruptFork(fiber) : options6.onFromServer({
          _tag: "Exit",
          clientId,
          requestId: message.requestId,
          exit: interrupt4(none4)
        });
      }
      case "Eof": {
        client.ended = true;
        if (client.fibers.size > 0)
          return _void;
        return endClient(client);
      }
      default: {
        return sendDefect(client, `Unknown request tag: ${message._tag}`);
      }
    }
  }), (defect) => sendDefect(clients.get(clientId), defect));
  const endClient = (client) => {
    clients.delete(client.id);
    const write4 = options6.onFromServer({
      _tag: "ClientEnd",
      clientId: client.id
    });
    if (isShutdown7 && clients.size === 0) {
      return zipRight3(write4, shutdownLatch.open);
    }
    return write4;
  };
  const handleRequest = (requestFiber, client, request2) => {
    if (client.fibers.has(request2.id)) {
      return interrupt7;
    }
    const rpc = group6.requests.get(request2.tag);
    const entry = context9.unsafeMap.get(rpc?.key);
    if (!rpc || !entry) {
      const write4 = catchAllDefect2(options6.onFromServer({
        _tag: "Exit",
        clientId: client.id,
        requestId: request2.id,
        exit: die3(`Unknown request tag: ${request2.tag}`)
      }), (defect) => sendDefect(client, defect));
      if (!client.ended || client.fibers.size > 0)
        return write4;
      return zipRight3(write4, endClient(client));
    }
    const isStream3 = isStreamSchema(rpc.successSchema);
    const result = entry.handler(request2.payload, request2.headers);
    const isFork2 = isFork(result);
    const streamOrEffect = isFork2 ? result.value : result;
    let responded = false;
    let effect4 = uninterruptible2(matchCauseEffect3(interruptible4(applyMiddleware(rpc, context9, request2.payload, request2.headers, isStream3 ? streamEffect(client, request2, streamOrEffect) : streamOrEffect)), {
      onSuccess: (value6) => {
        responded = true;
        return options6.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: succeed4(value6)
        });
      },
      onFailure: (cause3) => {
        responded = true;
        return options6.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: failCause4(cause3)
        });
      }
    }));
    if (enableTracing) {
      const parentSpan2 = requestFiber.currentContext.unsafeMap.get(ParentSpan.key);
      effect4 = withSpan2(effect4, `${spanPrefix}.${request2.tag}`, {
        captureStackTrace: false,
        parent: enableSpanPropagation ? {
          _tag: "ExternalSpan",
          traceId: request2.traceId,
          spanId: request2.spanId,
          sampled: request2.sampled,
          context: empty5()
        } : undefined,
        links: enableSpanPropagation && parentSpan2 ? [{
          _tag: "SpanLink",
          span: parentSpan2,
          attributes: {}
        }] : undefined
      });
    }
    if (!isFork2 && concurrencySemaphore) {
      effect4 = concurrencySemaphore.withPermits(1)(effect4);
    }
    const runtime6 = make47({
      context: merge3(entry.context, requestFiber.currentContext),
      fiberRefs: requestFiber.getFiberRefs(),
      runtimeFlags: defaultRuntime2.runtimeFlags
    });
    const fiber = runFork3(runtime6, effect4);
    unsafeAdd(fiberSet, fiber);
    client.fibers.set(request2.id, fiber);
    fiber.addObserver((exit3) => {
      if (!responded && exit3._tag === "Failure") {
        unsafeAdd(fiberSet, runFork3(runtime6, options6.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: interrupt4(none4)
        })));
      }
      client.fibers.delete(request2.id);
      client.latches.delete(request2.id);
      if (client.ended && client.fibers.size === 0) {
        unsafeAdd(fiberSet, runFork3(runtime6, endClient(client)));
      }
    });
    return _void;
  };
  const streamEffect = (client, request2, stream6) => {
    let latch = client.latches.get(request2.id);
    if (supportsAck && !latch) {
      latch = unsafeMakeLatch2(false);
      client.latches.set(request2.id, latch);
    }
    if (isEffect2(stream6)) {
      let done11 = false;
      return stream6.pipe(flatMap10((mailbox) => whileLoop2({
        while: () => !done11,
        body: constant(flatMap10(mailbox.takeAll, ([chunk4, done_]) => {
          done11 = done_;
          if (!isNonEmpty(chunk4))
            return _void;
          const write4 = options6.onFromServer({
            _tag: "Chunk",
            clientId: client.id,
            requestId: request2.id,
            values: toReadonlyArray(chunk4)
          });
          if (!latch)
            return write4;
          latch.unsafeClose();
          return zipRight3(write4, latch.await);
        })),
        step: constVoid
      })), scoped2);
    }
    return runForEachChunk2(stream6, (chunk4) => {
      if (!isNonEmpty(chunk4))
        return _void;
      const write4 = options6.onFromServer({
        _tag: "Chunk",
        clientId: client.id,
        requestId: request2.id,
        values: toReadonlyArray(chunk4)
      });
      if (!latch)
        return write4;
      latch.unsafeClose();
      return zipRight3(write4, latch.await);
    });
  };
  const sendDefect = (client, defect) => suspend3(() => {
    const shouldEnd = client.ended && client.fibers.size === 0;
    const write4 = options6.onFromServer({
      _tag: "Defect",
      clientId: client.id,
      defect
    });
    if (!shouldEnd)
      return write4;
    return zipRight3(write4, endClient(client));
  });
  return identity({
    write: write3,
    disconnect: disconnect3
  });
});
var applyMiddleware = (rpc, context9, payload, headers, handler) => {
  if (rpc.middlewares.size === 0) {
    return handler;
  }
  const options6 = {
    rpc,
    payload,
    headers
  };
  for (const tag7 of rpc.middlewares) {
    if (tag7.wrap) {
      const middleware = unsafeGet3(context9, tag7);
      handler = middleware({
        ...options6,
        next: handler
      });
    } else if (tag7.optional) {
      const middleware = unsafeGet3(context9, tag7);
      const previous2 = handler;
      handler = matchEffect2(middleware(options6), {
        onFailure: () => previous2,
        onSuccess: tag7.provides !== undefined ? (value6) => provideService2(previous2, tag7.provides, value6) : (_) => previous2
      });
    } else {
      const middleware = unsafeGet3(context9, tag7);
      handler = tag7.provides !== undefined ? provideServiceEffect2(handler, tag7.provides, middleware(options6)) : zipRight3(middleware(options6), handler);
    }
  }
  return handler;
};

// node_modules/effect/dist/esm/internal/pool.js
var PoolTypeId = /* @__PURE__ */ Symbol.for("effect/Pool");
var poolVariance = {
  _E: (_) => _,
  _A: (_) => _
};
class PoolImpl extends Class {
  scope;
  acquire;
  concurrency;
  minSize;
  maxSize;
  strategy;
  targetUtilization;
  [PoolTypeId];
  isShuttingDown = false;
  semaphore;
  items = /* @__PURE__ */ new Set;
  available = /* @__PURE__ */ new Set;
  availableLatch = /* @__PURE__ */ unsafeMakeLatch(false);
  invalidated = /* @__PURE__ */ new Set;
  waiters = 0;
  constructor(scope5, acquire, concurrency, minSize, maxSize, strategy, targetUtilization) {
    super();
    this.scope = scope5;
    this.acquire = acquire;
    this.concurrency = concurrency;
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.strategy = strategy;
    this.targetUtilization = targetUtilization;
    this[PoolTypeId] = poolVariance;
    this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
  }
  allocate = /* @__PURE__ */ acquireUseRelease(/* @__PURE__ */ scopeMake(), (scope5) => this.acquire.pipe(scopeExtend(scope5), exit, flatMap8((exit3) => {
    const item = {
      exit: exit3,
      finalizer: catchAllCause(scope5.close(exit3), reportUnhandledError),
      refCount: 0,
      disableReclaim: false
    };
    this.items.add(item);
    this.available.add(item);
    return as(exit3._tag === "Success" ? this.strategy.onAcquire(item) : zipRight(item.finalizer, this.strategy.onAcquire(item)), item);
  })), (scope5, exit3) => exit3._tag === "Failure" ? scope5.close(exit3) : void_);
  get currentUsage() {
    let count5 = this.waiters;
    for (const item of this.items) {
      count5 += item.refCount;
    }
    return count5;
  }
  get targetSize() {
    if (this.isShuttingDown)
      return 0;
    const utilization = this.currentUsage / this.targetUtilization;
    const target2 = Math.ceil(utilization / this.concurrency);
    return Math.min(Math.max(this.minSize, target2), this.maxSize);
  }
  get activeSize() {
    return this.items.size - this.invalidated.size;
  }
  resizeLoop = /* @__PURE__ */ suspend(() => {
    if (this.activeSize >= this.targetSize) {
      return void_;
    }
    const toAcquire = this.targetSize - this.activeSize;
    return this.strategy.reclaim(this).pipe(flatMap8(match2({
      onNone: () => this.allocate,
      onSome: succeed
    })), replicateEffect(toAcquire, {
      concurrency: toAcquire
    }), zipLeft(this.availableLatch.open), flatMap8((items) => items.some((_) => _.exit._tag === "Failure") ? void_ : this.resizeLoop));
  });
  resizeSemaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  resize = /* @__PURE__ */ this.resizeSemaphore.withPermits(1)(this.resizeLoop);
  getPoolItem = /* @__PURE__ */ uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight(scopeTag), flatMap8((scope5) => suspend(() => {
    this.waiters++;
    if (this.isShuttingDown) {
      return interrupt2;
    } else if (this.targetSize > this.activeSize) {
      const self2 = this;
      return flatMap8(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn(interruptible2(this.resize), this.scope)), function loop() {
        if (self2.isShuttingDown) {
          return interrupt2;
        } else if (self2.available.size > 0) {
          return succeed(unsafeHead(self2.available));
        }
        self2.availableLatch.unsafeClose();
        return flatMap8(self2.availableLatch.await, loop);
      });
    }
    return succeed(unsafeHead(this.available));
  }).pipe(ensuring(sync(() => this.waiters--)), tap((item) => {
    if (item.exit._tag === "Failure") {
      this.items.delete(item);
      this.invalidated.delete(item);
      this.available.delete(item);
      return this.semaphore.release(1);
    }
    item.refCount++;
    this.available.delete(item);
    if (item.refCount < this.concurrency) {
      this.available.add(item);
    }
    return scope5.addFinalizer(() => zipRight(suspend(() => {
      item.refCount--;
      if (this.invalidated.has(item)) {
        return this.invalidatePoolItem(item);
      }
      this.available.add(item);
      return exitVoid;
    }), this.semaphore.release(1)));
  }), onInterrupt(() => this.semaphore.release(1))))));
  commit() {
    return this.get;
  }
  get = /* @__PURE__ */ flatMap8(/* @__PURE__ */ suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_) => _.exit);
  invalidate(item) {
    return suspend(() => {
      if (this.isShuttingDown)
        return void_;
      for (const poolItem of this.items) {
        if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
          poolItem.disableReclaim = true;
          return uninterruptible(this.invalidatePoolItem(poolItem));
        }
      }
      return void_;
    });
  }
  invalidatePoolItem(poolItem) {
    return suspend(() => {
      if (!this.items.has(poolItem)) {
        return void_;
      } else if (poolItem.refCount === 0) {
        this.items.delete(poolItem);
        this.available.delete(poolItem);
        this.invalidated.delete(poolItem);
        return zipRight(poolItem.finalizer, forkIn(interruptible2(this.resize), this.scope));
      }
      this.invalidated.add(poolItem);
      this.available.delete(poolItem);
      return void_;
    });
  }
  get shutdown() {
    return suspend(() => {
      if (this.isShuttingDown)
        return void_;
      this.isShuttingDown = true;
      const size17 = this.items.size;
      const semaphore = unsafeMakeSemaphore(size17);
      return forEachSequentialDiscard(this.items, (item) => {
        if (item.refCount > 0) {
          item.finalizer = zipLeft(item.finalizer, semaphore.release(1));
          this.invalidated.add(item);
          return semaphore.take(1);
        }
        this.items.delete(item);
        this.available.delete(item);
        this.invalidated.delete(item);
        return item.finalizer;
      }).pipe(zipRight(this.semaphore.releaseAll), zipRight(this.availableLatch.open), zipRight(semaphore.take(size17)));
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var reportUnhandledError = (cause3) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause3, unhandledLogLevel);
  }
  return void_;
});

// node_modules/@effect/platform/dist/esm/internal/worker.js
var PlatformWorkerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/PlatformWorker");
var PlatformWorker = /* @__PURE__ */ GenericTag("@effect/platform/Worker/PlatformWorker");
var WorkerManagerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/WorkerManager");
var WorkerManager = /* @__PURE__ */ GenericTag("@effect/platform/Worker/WorkerManager");
var Spawner = /* @__PURE__ */ GenericTag("@effect/platform/Worker/Spawner");
var makeManager = /* @__PURE__ */ gen2(function* () {
  const platform = yield* PlatformWorker;
  let idCounter = 0;
  return WorkerManager.of({
    [WorkerManagerTypeId]: WorkerManagerTypeId,
    spawn({
      encode: encode7,
      initialMessage
    }) {
      return gen2(function* () {
        const id2 = idCounter++;
        let requestIdCounter = 0;
        const requestMap = new Map;
        const collector = unsafeMakeCollector();
        const wrappedEncode = encode7 ? (message) => zipRight3(collector.clear, provideService2(encode7(message), Collector, collector)) : succeed8;
        const readyLatch = yield* make24();
        const backing = yield* platform.spawn(id2);
        yield* backing.run((message) => {
          if (message[0] === 0) {
            return complete(readyLatch, _void);
          }
          return handleMessage(message[1]);
        }).pipe(onError2((cause3) => forEach9(requestMap.values(), (mailbox) => (DeferredTypeId2 in mailbox) ? failCause2(mailbox, cause3) : mailbox.failCause(cause3))), tapErrorCause2(logWarning2), retry(spaced2(1000)), annotateLogs2({
          package: "@effect/platform",
          module: "Worker"
        }), interruptible4, forkScoped2);
        yield* addFinalizer3(() => zipRight3(forEach9(requestMap.values(), (mailbox) => (DeferredTypeId2 in mailbox) ? interrupt3(mailbox) : mailbox.end, {
          discard: true
        }), sync3(() => requestMap.clear())));
        const handleMessage = (response) => suspend3(() => {
          const mailbox = requestMap.get(response[0]);
          if (!mailbox)
            return _void;
          switch (response[1]) {
            case 0: {
              return DeferredTypeId2 in mailbox ? succeed2(mailbox, response[2][0]) : mailbox.offerAll(response[2]);
            }
            case 1: {
              if (response.length === 2) {
                return DeferredTypeId2 in mailbox ? interrupt3(mailbox) : mailbox.end;
              }
              return DeferredTypeId2 in mailbox ? succeed2(mailbox, response[2][0]) : zipRight3(mailbox.offerAll(response[2]), mailbox.end);
            }
            case 2:
            case 3: {
              if (response[1] === 2) {
                return DeferredTypeId2 in mailbox ? fail3(mailbox, response[2]) : mailbox.fail(response[2]);
              }
              const cause3 = WorkerError.decodeCause(response[2]);
              return DeferredTypeId2 in mailbox ? failCause2(mailbox, cause3) : mailbox.failCause(cause3);
            }
          }
        });
        const executeAcquire = (request2, makeMailbox) => withFiberRuntime2((fiber) => {
          const context9 = fiber.getFiberRef(currentContext2);
          const span3 = getOption2(context9, ParentSpan).pipe(filter((span4) => span4._tag === "Span"));
          const id3 = requestIdCounter++;
          return makeMailbox.pipe(tap2((mailbox) => {
            requestMap.set(id3, mailbox);
            return wrappedEncode(request2).pipe(tap2((payload) => backing.send([id3, 0, payload, span3._tag === "Some" ? [span3.value.traceId, span3.value.spanId, span3.value.sampled] : undefined], collector.unsafeRead())), catchAllCause2((cause3) => isMailbox(mailbox) ? mailbox.failCause(cause3) : failCause2(mailbox, cause3)));
          }), map17((mailbox) => ({
            id: id3,
            mailbox
          })));
        });
        const executeRelease = ({
          id: id3
        }, exit3) => {
          const release = sync3(() => requestMap.delete(id3));
          return isFailure2(exit3) ? zipRight3(orDie2(backing.send([id3, 1])), release) : release;
        };
        const execute4 = (request2) => fromChannel4(acquireUseRelease4(executeAcquire(request2, make81()), ({
          mailbox
        }) => toChannel5(mailbox), executeRelease));
        const executeEffect = (request2) => acquireUseRelease2(executeAcquire(request2, make24()), ({
          mailbox
        }) => _await(mailbox), executeRelease);
        yield* _await(readyLatch);
        if (initialMessage) {
          yield* sync3(initialMessage).pipe(flatMap10(executeEffect), mapError2((cause3) => new WorkerError({
            reason: "spawn",
            cause: cause3
          })));
        }
        return {
          id: id2,
          execute: execute4,
          executeEffect
        };
      });
    }
  });
});
var layerManager = /* @__PURE__ */ effect(WorkerManager, makeManager);
var makePlatform = () => (options6) => PlatformWorker.of({
  [PlatformWorkerTypeId]: PlatformWorkerTypeId,
  spawn(id2) {
    return gen2(function* () {
      const spawn = yield* Spawner;
      let currentPort;
      const buffer4 = [];
      const run10 = (handler) => uninterruptibleMask3((restore) => gen2(function* () {
        const scope5 = yield* scope2;
        const port2 = yield* options6.setup({
          worker: spawn(id2),
          scope: scope5
        });
        currentPort = port2;
        yield* addFinalizer2(scope5, sync3(() => {
          currentPort = undefined;
        }));
        const runtime6 = (yield* runtime4()).pipe(updateContext3(omit2(Scope)));
        const fiberSet = yield* make82();
        const runFork4 = runFork3(runtime6);
        yield* options6.listen({
          port: port2,
          scope: scope5,
          emit(data) {
            unsafeAdd(fiberSet, runFork4(handler(data)));
          },
          deferred: fiberSet.deferred
        });
        if (buffer4.length > 0) {
          for (const [message, transfers] of buffer4) {
            port2.postMessage([0, message], transfers);
          }
          buffer4.length = 0;
        }
        return yield* restore(join4(fiberSet));
      }).pipe(scoped2));
      const send = (message, transfers) => try_2({
        try: () => {
          if (currentPort === undefined) {
            buffer4.push([message, transfers]);
          } else {
            currentPort.postMessage([0, message], transfers);
          }
        },
        catch: (cause3) => new WorkerError({
          reason: "send",
          cause: cause3
        })
      });
      return {
        run: run10,
        send
      };
    });
  }
});

// node_modules/@effect/platform/dist/esm/Worker.js
var makePlatform2 = makePlatform;
var PlatformWorker2 = PlatformWorker;
var layerManager2 = layerManager;

// node_modules/@effect/rpc/dist/esm/RpcClient.js
var requestIdCounter = /* @__PURE__ */ BigInt(0);
var makeNoSerialization2 = /* @__PURE__ */ fnUntraced2(function* (group6, options6) {
  const spanPrefix = options6?.spanPrefix ?? "RpcClient";
  const supportsAck = options6?.supportsAck ?? true;
  const disableTracing = options6?.disableTracing ?? false;
  const generateRequestId = options6?.generateRequestId ?? (() => requestIdCounter++);
  const context9 = yield* context3();
  const scope5 = get3(context9, Scope);
  const entries2 = new Map;
  let isShutdown7 = false;
  yield* addFinalizer2(scope5, fiberIdWith2((fiberId3) => {
    isShutdown7 = true;
    return clearEntries(interrupt4(fiberId3));
  }));
  const clearEntries = fnUntraced2(function* (exit3) {
    for (const [id2, entry] of entries2) {
      entries2.delete(id2);
      if (entry._tag === "Mailbox") {
        yield* entry.mailbox.done(exit3);
      } else {
        entry.resume(exit3);
      }
    }
  });
  const onRequest = (rpc) => {
    const isStream3 = isStreamSchema(rpc.successSchema);
    const middleware = getRpcClientMiddleware(rpc);
    return (payload, options7) => {
      const headers = options7?.headers ? fromInput3(options7.headers) : empty45;
      if (!isStream3) {
        const effect4 = useSpan2(`${spanPrefix}.${rpc._tag}`, {
          captureStackTrace: false
        }, (span3) => onEffectRequest(rpc, middleware, span3, "make" in rpc.payloadSchema ? rpc.payloadSchema.make(payload ?? {}) : {}, headers, options7?.context ?? empty5(), options7?.discard ?? false));
        return disableTracing ? withTracerEnabled2(effect4, false) : effect4;
      }
      const mailbox = suspend3(() => onStreamRequest(rpc, middleware, payload ? rpc.payloadSchema.make(payload) : {}, headers, options7?.streamBufferSize ?? 16, options7?.context ?? empty5()));
      if (options7?.asMailbox)
        return mailbox;
      return unwrapScoped6(map17(mailbox, toStream2));
    };
  };
  const onEffectRequest = (rpc, middleware, span3, payload, headers, context10, discard2) => withFiberRuntime2((parentFiber) => {
    if (isShutdown7) {
      return interrupt7;
    }
    const id2 = generateRequestId();
    const send = middleware({
      _tag: "Request",
      id: id2,
      tag: rpc._tag,
      payload,
      traceId: span3.traceId,
      spanId: span3.spanId,
      sampled: span3.sampled,
      headers: merge12(parentFiber.getFiberRef(currentHeaders), headers)
    });
    if (discard2) {
      return flatMap10(send, (message) => options6.onFromClient({
        message,
        context: context10,
        discard: discard2
      }));
    }
    const runtime6 = make47({
      context: parentFiber.currentContext,
      fiberRefs: parentFiber.getFiberRefs(),
      runtimeFlags: defaultRuntime2.runtimeFlags
    });
    let fiber;
    return onInterrupt2(async((resume2) => {
      const entry = {
        _tag: "Effect",
        rpc,
        context: context10,
        resume(exit3) {
          resume2(exit3);
          if (fiber && !fiber.unsafePoll()) {
            parentFiber.currentScheduler.scheduleTask(() => {
              fiber.unsafeInterruptAsFork(parentFiber.id());
            }, 0);
          }
        }
      };
      entries2.set(id2, entry);
      fiber = send.pipe(flatMap10((request2) => options6.onFromClient({
        message: request2,
        context: context10,
        discard: discard2
      })), withParentSpan2(span3), runFork3(runtime6));
      fiber.addObserver((exit3) => {
        if (exit3._tag === "Failure") {
          return resume2(exit3);
        }
      });
    }), (interruptors3) => {
      entries2.delete(id2);
      const ids3 = Array.from(interruptors3).flatMap((id3) => Array.from(toSet2(id3)));
      return zipRight3(interrupt6(fiber), sendInterrupt(id2, ids3, context10));
    });
  });
  const onStreamRequest = fnUntraced2(function* (rpc, middleware, payload, headers, streamBufferSize, context10) {
    if (isShutdown7) {
      return yield* interrupt7;
    }
    const span3 = yield* makeSpanScoped2(`${spanPrefix}.${rpc._tag}`, {
      captureStackTrace: false
    }).pipe(disableTracing ? withTracerEnabled2(false) : identity);
    const fiber = getOrThrow2(getCurrentFiber2());
    const id2 = generateRequestId();
    const scope6 = unsafeGet3(fiber.currentContext, Scope);
    yield* addFinalizerExit(scope6, (exit3) => {
      if (!entries2.has(id2))
        return _void;
      entries2.delete(id2);
      return sendInterrupt(id2, isFailure2(exit3) ? Array.from(interruptors2(exit3.cause)).flatMap((id3) => Array.from(toSet2(id3))) : [], context10);
    });
    const mailbox = yield* make81(streamBufferSize);
    entries2.set(id2, {
      _tag: "Mailbox",
      rpc,
      mailbox,
      scope: scope6,
      context: context10
    });
    yield* middleware({
      _tag: "Request",
      id: id2,
      tag: rpc._tag,
      traceId: span3.traceId,
      payload,
      spanId: span3.spanId,
      sampled: span3.sampled,
      headers: merge12(fiber.getFiberRef(currentHeaders), headers)
    }).pipe(flatMap10((request2) => options6.onFromClient({
      message: request2,
      context: context10,
      discard: false
    })), withParentSpan2(span3), catchAllCause2((error5) => mailbox.failCause(error5)), interruptible4, forkIn2(scope6));
    return mailbox;
  });
  const getRpcClientMiddleware = (rpc) => {
    const middlewares = [];
    for (const tag7 of rpc.middlewares.values()) {
      const middleware = context9.unsafeMap.get(`${tag7.key}/Client`);
      if (!middleware)
        continue;
      middlewares.push(middleware);
    }
    return middlewares.length === 0 ? succeed8 : function(request2) {
      let i = 0;
      return map17(whileLoop2({
        while: () => i < middlewares.length,
        body: () => middlewares[i]({
          rpc,
          request: request2
        }),
        step(nextRequest) {
          request2 = nextRequest;
          i++;
        }
      }), () => request2);
    };
  };
  const sendInterrupt = (requestId, interruptors3, context10) => async((resume2) => {
    const parentFiber = getOrThrow2(getCurrentFiber2());
    const runtime6 = make47({
      context: parentFiber.currentContext,
      fiberRefs: parentFiber.getFiberRefs(),
      runtimeFlags: defaultRuntime2.runtimeFlags
    });
    const fiber = options6.onFromClient({
      message: {
        _tag: "Interrupt",
        requestId,
        interruptors: interruptors3
      },
      context: context10,
      discard: false
    }).pipe(timeout2(1000), runFork3(runtime6));
    fiber.addObserver(() => {
      resume2(_void);
    });
  });
  const write3 = (message) => {
    switch (message._tag) {
      case "Chunk": {
        const requestId = message.requestId;
        const entry = entries2.get(requestId);
        if (!entry || entry._tag !== "Mailbox")
          return _void;
        return entry.mailbox.offerAll(message.values).pipe(supportsAck ? zipRight3(options6.onFromClient({
          message: {
            _tag: "Ack",
            requestId: message.requestId
          },
          context: entry.context,
          discard: false
        })) : identity, catchAllCause2((cause3) => entry.mailbox.done(failCause4(cause3))));
      }
      case "Exit": {
        const requestId = message.requestId;
        const entry = entries2.get(requestId);
        if (!entry)
          return _void;
        entries2.delete(requestId);
        if (entry._tag === "Effect") {
          entry.resume(message.exit);
          return _void;
        }
        return entry.mailbox.done(asVoid2(message.exit));
      }
      case "Defect": {
        return clearEntries(die3(message.defect));
      }
      case "ClientEnd": {
        return _void;
      }
    }
  };
  const client = {};
  for (const rpc of group6.requests.values()) {
    client[rpc._tag] = onRequest(rpc);
  }
  return {
    client,
    write: write3
  };
});
var currentHeaders = /* @__PURE__ */ globalValue("@effect/rpc/RpcClient/currentHeaders", () => unsafeMake8(empty45));

// node_modules/@effect/cluster/dist/esm/EntityId.js
var EntityId = /* @__PURE__ */ NonEmptyTrimmedString.pipe(/* @__PURE__ */ brand("EntityId"));

// node_modules/@effect/cluster/dist/esm/EntityType.js
var EntityType = /* @__PURE__ */ NonEmptyTrimmedString.pipe(/* @__PURE__ */ brand("EntityType"));

// node_modules/@effect/cluster/dist/esm/ShardId.js
var ShardId = /* @__PURE__ */ Int.pipe(/* @__PURE__ */ brand("ShardId"), /* @__PURE__ */ annotations2({
  pretty: () => (shardId) => `ShardId(${shardId})`
}));

// node_modules/@effect/cluster/dist/esm/EntityAddress.js
var SymbolKey = "@effect/cluster/EntityAddress";
var TypeId46 = /* @__PURE__ */ Symbol.for(SymbolKey);

class EntityAddress extends (/* @__PURE__ */ Class5(SymbolKey)({
  shardId: ShardId,
  entityType: EntityType,
  entityId: EntityId
})) {
  [TypeId46] = TypeId46;
  [symbol]() {
    return cached(this)(string2(`${this.shardId}:${this.entityType}:${this.entityId}`));
  }
}
var EntityAddressFromSelf = /* @__PURE__ */ typeSchema(EntityAddress);

// node_modules/@effect/cluster/dist/esm/RunnerAddress.js
var SymbolKey2 = "@effect/cluster/RunnerAddress";
var TypeId47 = /* @__PURE__ */ Symbol.for(SymbolKey2);

class RunnerAddress extends (/* @__PURE__ */ Class5(SymbolKey2)({
  host: NonEmptyString,
  port: Int
})) {
  [TypeId47] = TypeId47;
  [symbol]() {
    return cached(this)(string2(this.toString()));
  }
  toString() {
    return `RunnerAddress(${this.host}:${this.port})`;
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
}

// node_modules/@effect/cluster/dist/esm/Snowflake.js
var TypeId48 = /* @__PURE__ */ Symbol.for("@effect/cluster/Snowflake");
var Snowflake = (input) => typeof input === "string" ? BigInt(input) : input;
var SnowflakeFromString = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ brand(TypeId48));
var constEpochMillis = /* @__PURE__ */ Date.UTC(2025, 0, 1);
var sinceUnixEpoch = constEpochMillis - /* @__PURE__ */ Date.UTC(1970, 0, 1);
var constBigInt12 = /* @__PURE__ */ BigInt(12);
var constBigInt22 = /* @__PURE__ */ BigInt(22);
var make91 = (options6) => BigInt(options6.timestamp - constEpochMillis) << constBigInt22 | BigInt(options6.machineId % 1024) << constBigInt12 | BigInt(options6.sequence % 4096);
var makeGenerator = /* @__PURE__ */ gen2(function* () {
  let machineId = Math.floor(Math.random() * 1024);
  const clock3 = yield* clock2;
  let sequence2 = 0;
  let sequenceAt = clock3.unsafeCurrentTimeMillis();
  return identity({
    setMachineId: (newMachineId) => sync3(() => {
      machineId = newMachineId;
    }),
    unsafeNext() {
      let now2 = clock3.unsafeCurrentTimeMillis();
      if (now2 < sequenceAt) {
        now2 = sequenceAt;
      } else if (now2 > sequenceAt) {
        sequence2 = 0;
        sequenceAt = now2;
      } else if (sequence2 >= 1024) {
        sequenceAt++;
        sequence2 = 0;
      }
      return make91({
        machineId,
        sequence: sequence2++,
        timestamp: sequenceAt
      });
    }
  });
});

class Generator2 extends (/* @__PURE__ */ Tag2("@effect/cluster/Snowflake/Generator")()) {
}
var layerGenerator = /* @__PURE__ */ effect(Generator2, makeGenerator);

// node_modules/@effect/cluster/dist/esm/ClusterError.js
var TypeId49 = /* @__PURE__ */ Symbol.for("@effect/cluster/ClusterError");

class EntityNotAssignedToRunner extends (/* @__PURE__ */ TaggedError2()("EntityNotAssignedToRunner", {
  address: EntityAddress
})) {
  [TypeId49] = TypeId49;
  static is(u) {
    return hasProperty(u, TypeId49) && isTagged(u, "EntityNotAssignedToRunner");
  }
}

class EntityNotManagedByRunner extends (/* @__PURE__ */ TaggedError2()("EntityNotManagedByRunner", {
  address: EntityAddress
})) {
  [TypeId49] = TypeId49;
  static is(u) {
    return hasProperty(u, TypeId49) && isTagged(u, "EntityNotManagedByRunner");
  }
}

class MalformedMessage extends (/* @__PURE__ */ TaggedError2()("MalformedMessage", {
  cause: Defect
})) {
  [TypeId49] = TypeId49;
  static is(u) {
    return hasProperty(u, TypeId49) && isTagged(u, "MalformedMessage");
  }
  static refail = /* @__PURE__ */ mapError2((cause3) => new MalformedMessage({
    cause: cause3
  }));
}
class RunnerUnavailable extends (/* @__PURE__ */ TaggedError2()("RunnerUnavailable", {
  address: RunnerAddress
})) {
  [TypeId49] = TypeId49;
  static is(u) {
    return hasProperty(u, TypeId49) && isTagged(u, "RunnerUnavailable");
  }
}

class MailboxFull extends (/* @__PURE__ */ TaggedError2()("MailboxFull", {
  address: EntityAddress
})) {
  [TypeId49] = TypeId49;
  static is(u) {
    return hasProperty(u, TypeId49) && isTagged(u, "MailboxFull");
  }
}

class AlreadyProcessingMessage extends (/* @__PURE__ */ TaggedError2()("AlreadyProcessingMessage", {
  envelopeId: SnowflakeFromString,
  address: EntityAddress
})) {
  [TypeId49] = TypeId49;
  static is(u) {
    return hasProperty(u, TypeId49) && isTagged(u, "AlreadyProcessingMessage");
  }
}

// node_modules/@effect/cluster/dist/esm/ClusterSchema.js
class Persisted extends (/* @__PURE__ */ Reference2()("@effect/cluster/ClusterSchema/Persisted", {
  defaultValue: constFalse
})) {
}

// node_modules/effect/dist/esm/PrimaryKey.js
var symbol4 = /* @__PURE__ */ Symbol.for("effect/PrimaryKey");
var value6 = (self2) => self2[symbol4]();

// node_modules/@effect/cluster/dist/esm/Envelope.js
var TypeId50 = /* @__PURE__ */ Symbol.for("@effect/cluster/Envelope");

class AckChunk extends (/* @__PURE__ */ TaggedClass3("@effect/cluster/Envelope/AckChunk")("AckChunk", {
  id: SnowflakeFromString,
  address: EntityAddress,
  requestId: SnowflakeFromString,
  replyId: SnowflakeFromString
})) {
  [TypeId50] = TypeId50;
  withRequestId(requestId) {
    return new AckChunk({
      ...this,
      requestId
    });
  }
}

class Interrupt2 extends (/* @__PURE__ */ TaggedClass3("@effect/cluster/Envelope/Interrupt")("Interrupt", {
  id: SnowflakeFromString,
  address: EntityAddress,
  requestId: SnowflakeFromString
})) {
  [TypeId50] = TypeId50;
  withRequestId(requestId) {
    return new Interrupt2({
      ...this,
      requestId
    });
  }
}
var isEnvelope = (u) => hasProperty(u, TypeId50);
var makeRequest = (options6) => ({
  [TypeId50]: TypeId50,
  _tag: "Request",
  requestId: options6.requestId,
  tag: options6.tag,
  address: options6.address,
  payload: options6.payload,
  headers: options6.headers,
  traceId: options6.traceId,
  spanId: options6.spanId,
  sampled: options6.sampled
});
var RequestFromSelf = /* @__PURE__ */ declare((u) => isEnvelope(u) && u._tag === "Request", {
  identifier: "Envelope"
});
var PartialEncodedRequest = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Request"),
  requestId: SnowflakeFromString,
  address: EntityAddress,
  tag: String$,
  payload: Unknown,
  headers: schema,
  traceId: String$,
  spanId: String$,
  sampled: Boolean$
});
var PartialEncoded = /* @__PURE__ */ Union2(PartialEncodedRequest, AckChunk, Interrupt2);
var PartialEncodedRequestFromSelf = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Request"),
  requestId: /* @__PURE__ */ typeSchema(SnowflakeFromString),
  address: EntityAddressFromSelf,
  tag: String$,
  payload: Unknown,
  headers: schemaFromSelf,
  traceId: String$,
  spanId: String$,
  sampled: Boolean$
});
var primaryKey = (envelope) => {
  if (envelope._tag !== "Request" || !hasProperty(envelope.payload, symbol4)) {
    return null;
  }
  const value7 = value6(envelope.payload);
  return `${envelope.address.entityType}/${envelope.address.entityId}/${envelope.tag}/${value7}`;
};

// node_modules/@effect/cluster/dist/esm/Message.js
class IncomingRequest extends (/* @__PURE__ */ TaggedClass("IncomingRequest")) {
}

class IncomingRequestLocal extends (/* @__PURE__ */ TaggedClass("IncomingRequestLocal")) {
}

class IncomingEnvelope extends (/* @__PURE__ */ TaggedClass("IncomingEnvelope")) {
}

class OutgoingRequest extends (/* @__PURE__ */ TaggedClass("OutgoingRequest")) {
  encodedCache;
}

class OutgoingEnvelope extends (/* @__PURE__ */ TaggedClass("OutgoingEnvelope")) {
}
var serialize2 = (message) => {
  if (message._tag !== "OutgoingRequest") {
    return succeed8(message.envelope);
  }
  return suspend3(() => message.encodedCache ? succeed8(message.encodedCache) : serializeRequest(message));
};
var serializeEnvelope = (message) => flatMap10(serialize2(message), (envelope) => MalformedMessage.refail(encode4(PartialEncoded)(envelope)));
var serializeRequest = (self2) => {
  const rpc = self2.rpc;
  return encode4(rpc.payloadSchema)(self2.envelope.payload).pipe(locally(currentContext2, self2.context), MalformedMessage.refail, map17((payload) => ({
    ...self2.envelope,
    payload
  })));
};

// node_modules/@effect/cluster/dist/esm/DeliverAt.js
var symbol5 = /* @__PURE__ */ Symbol.for("@effect/cluster/DeliverAt");
var isDeliverAt = (self2) => hasProperty(self2, symbol5);
var toMillis2 = (self2) => {
  if (isDeliverAt(self2)) {
    return self2[symbol5]().epochMillis;
  }
  return null;
};

// node_modules/@effect/cluster/dist/esm/Reply.js
var TypeId51 = /* @__PURE__ */ Symbol.for("@effect/cluster/Reply");
var isReply = (u) => hasProperty(u, TypeId51);

class ReplyWithContext extends (/* @__PURE__ */ TaggedClass("ReplyWithContext")) {
  static fromDefect(options6) {
    return new ReplyWithContext({
      reply: new WithExit({
        requestId: options6.requestId,
        id: options6.id,
        exit: die3(encodeSync(Defect)(options6.defect))
      }),
      context: empty5(),
      rpc: neverRpc
    });
  }
}
var neverRpc = /* @__PURE__ */ make86("Never", {
  success: Never,
  error: Never,
  payload: {}
});
var schemaCache = /* @__PURE__ */ new WeakMap;
var Reply = (rpc) => {
  if (schemaCache.has(rpc)) {
    return schemaCache.get(rpc);
  }
  const schema2 = Union2(WithExit.schema(rpc), Chunk.schema(rpc));
  schemaCache.set(rpc, schema2);
  return schema2;
};
var Encoded = /* @__PURE__ */ Union2(/* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("WithExit"),
  requestId: String$,
  id: String$,
  exit: Unknown
}), /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Chunk"),
  requestId: String$,
  id: String$,
  sequence: Number$,
  values: /* @__PURE__ */ Array$(Unknown)
}));

class Chunk extends (/* @__PURE__ */ TaggedClass("Chunk")) {
  [TypeId51] = TypeId51;
  static emptyFrom(requestId) {
    return new Chunk({
      requestId,
      id: Snowflake(BigInt(0)),
      sequence: 0,
      values: [undefined]
    });
  }
  static schemaFromSelf = /* @__PURE__ */ declare((u) => isReply(u) && u._tag === "Chunk");
  static schema(rpc) {
    const successSchema2 = rpc.successSchema.success;
    if (!successSchema2) {
      return Never;
    }
    return transform2(Struct({
      _tag: Literal2("Chunk"),
      requestId: SnowflakeFromString,
      id: SnowflakeFromString,
      sequence: Number$,
      values: NonEmptyArray(successSchema2)
    }), Chunk.schemaFromSelf, {
      decode: (encoded) => new Chunk(encoded),
      encode: identity
    });
  }
  withRequestId(requestId) {
    return new Chunk({
      ...this,
      requestId
    });
  }
}

class WithExit extends (/* @__PURE__ */ TaggedClass("WithExit")) {
  [TypeId51] = TypeId51;
  static schema(rpc) {
    return transform2(Struct({
      _tag: Literal2("WithExit"),
      requestId: SnowflakeFromString,
      id: SnowflakeFromString,
      exit: exitSchema(rpc)
    }), declare((u) => isReply(u) && u._tag === "WithExit"), {
      decode: (encoded) => new WithExit(encoded),
      encode: identity
    });
  }
  withRequestId(requestId) {
    return new WithExit({
      ...this,
      requestId
    });
  }
}
var serialize3 = (self2) => {
  const schema2 = Reply(self2.rpc);
  return MalformedMessage.refail(locally(encode4(schema2)(self2.reply), currentContext2, self2.context));
};

// node_modules/@effect/cluster/dist/esm/MessageStorage.js
class MessageStorage extends (/* @__PURE__ */ Tag2("@effect/cluster/MessageStorage")()) {
}
var SaveResult = /* @__PURE__ */ taggedEnum();
var SaveResultEncoded = /* @__PURE__ */ taggedEnum();
var make92 = (storage) => sync3(() => {
  const replyHandlers = new Map;
  return MessageStorage.of({
    ...storage,
    registerReplyHandler: (message) => sync3(() => {
      replyHandlers.set(message.envelope.requestId, message._tag === "IncomingRequest" ? message.respond : (reply) => message.respond(reply.reply));
    }),
    saveReply(reply) {
      return flatMap10(storage.saveReply(reply), () => {
        const handler = replyHandlers.get(reply.reply.requestId);
        if (!handler) {
          return _void;
        } else if (reply.reply._tag === "WithExit") {
          replyHandlers.delete(reply.reply.requestId);
        }
        return handler(reply);
      });
    }
  });
});
var makeEncoded = /* @__PURE__ */ fnUntraced2(function* (encoded) {
  const snowflakeGen = yield* Generator2;
  const clock3 = yield* clock2;
  const storage = yield* make92({
    saveRequest: (message) => serializeEnvelope(message).pipe(flatMap10((envelope) => encoded.saveEnvelope({
      envelope,
      primaryKey: primaryKey(message.envelope),
      deliverAt: toMillis2(message.envelope.payload)
    })), flatMap10((result) => {
      if (result._tag === "Success" || result.lastReceivedReply._tag === "None") {
        return succeed8(result);
      }
      const duplicate = result;
      const schema2 = Reply(message.rpc);
      return decode6(schema2)(result.lastReceivedReply.value).pipe(locally(currentContext2, message.context), MalformedMessage.refail, map17((reply) => SaveResult.Duplicate({
        originalId: duplicate.originalId,
        lastReceivedReply: some2(reply)
      })));
    })),
    saveEnvelope: (message) => serializeEnvelope(message).pipe(flatMap10((envelope) => encoded.saveEnvelope({
      envelope,
      primaryKey: null,
      deliverAt: null
    })), asVoid4),
    saveReply: (reply) => flatMap10(serialize3(reply), encoded.saveReply),
    repliesFor: fnUntraced2(function* (messages) {
      const requestIds = empty3();
      const map39 = new Map;
      for (const message of messages) {
        const id2 = String(message.envelope.requestId);
        requestIds.push(id2);
        map39.set(id2, message);
      }
      if (requestIds.length === 0)
        return [];
      const encodedReplies = yield* encoded.repliesFor(requestIds);
      return yield* decodeReplies(map39, encodedReplies);
    }),
    unprocessedMessages: (shardIds) => {
      const shards = Array.from(shardIds);
      if (shards.length === 0)
        return succeed8([]);
      return flatMap10(suspend3(() => encoded.unprocessedMessages(shards, clock3.unsafeCurrentTimeMillis())), decodeMessages);
    },
    unprocessedMessagesById(messageIds) {
      const ids3 = Array.from(messageIds);
      if (ids3.length === 0)
        return succeed8([]);
      return flatMap10(suspend3(() => encoded.unprocessedMessagesById(ids3, clock3.unsafeCurrentTimeMillis())), decodeMessages);
    },
    resetAddress: (address) => encoded.resetAddress(address),
    resetShards: (shardIds) => encoded.resetShards(Array.from(shardIds))
  });
  const decodeMessages = (envelopes) => {
    const messages = [];
    let index = 0;
    const decodeMessage = catchAll2(suspend3(() => {
      const envelope = envelopes[index];
      if (!envelope)
        return succeed8(undefined);
      return decodeEnvelopeWithReply(envelope);
    }), (error5) => {
      const envelope = envelopes[index];
      return storage.saveReply(ReplyWithContext.fromDefect({
        id: snowflakeGen.unsafeNext(),
        requestId: Snowflake(envelope.envelope.requestId),
        defect: error5.toString()
      })).pipe(forkDaemon2, asVoid4);
    });
    return as3(whileLoop2({
      while: () => index < envelopes.length,
      body: () => decodeMessage,
      step: (message) => {
        const envelope = envelopes[index++];
        if (!message)
          return;
        messages.push(message.envelope._tag === "Request" ? new IncomingRequest({
          envelope: message.envelope,
          lastSentReply: envelope.lastSentReply,
          respond: storage.saveReply
        }) : new IncomingEnvelope({
          envelope: message.envelope
        }));
      }
    }), messages);
  };
  const decodeReplies = (messages, encodedReplies) => {
    const replies = [];
    const ignoredRequests = new Set;
    let index = 0;
    const decodeReply = catchAll2(suspend3(() => {
      const reply = encodedReplies[index];
      if (ignoredRequests.has(reply.requestId))
        return _void;
      const message = messages.get(reply.requestId);
      if (!message)
        return _void;
      const schema2 = Reply(message.rpc);
      return decode6(schema2)(reply).pipe(locally(currentContext2, message.context));
    }), (error5) => {
      const reply = encodedReplies[index];
      ignoredRequests.add(reply.requestId);
      return succeed8(new WithExit({
        id: snowflakeGen.unsafeNext(),
        requestId: Snowflake(reply.requestId),
        exit: die3(error5)
      }));
    });
    return as3(whileLoop2({
      while: () => index < encodedReplies.length,
      body: () => decodeReply,
      step: (reply) => {
        index++;
        if (reply)
          replies.push(reply);
      }
    }), replies);
  };
  return storage;
});
var noop = /* @__PURE__ */ globalValue("@effect/cluster/MessageStorage/noop", () => runSync(make92({
  saveRequest: () => succeed8(SaveResult.Success()),
  saveEnvelope: () => _void,
  saveReply: () => _void,
  repliesFor: () => succeed8([]),
  unprocessedMessages: () => succeed8([]),
  unprocessedMessagesById: () => succeed8([]),
  resetAddress: () => _void,
  resetShards: () => _void
})));

class MemoryDriver extends (/* @__PURE__ */ Service()("@effect/cluster/MessageStorage/MemoryDriver", {
  dependencies: [layerGenerator],
  effect: /* @__PURE__ */ gen2(function* () {
    const requests = new Map;
    const requestsByPrimaryKey = new Map;
    const unprocessed = new Set;
    const replyIds = new Set;
    const journal = [];
    const cursors = new WeakMap;
    const unprocessedWith = (predicate) => {
      const messages = [];
      for (const envelope of unprocessed) {
        if (!predicate(envelope)) {
          continue;
        }
        if (envelope._tag === "Request") {
          const entry = requests.get(envelope.requestId);
          messages.push({
            envelope,
            lastSentReply: fromNullable(entry?.replies[entry.replies.length - 1])
          });
        } else {
          messages.push({
            envelope,
            lastSentReply: none2()
          });
        }
      }
      return messages;
    };
    const replyLatch = yield* makeLatch2();
    const encoded = {
      saveEnvelope: ({
        envelope,
        primaryKey: primaryKey2
      }) => sync3(() => {
        const existing = primaryKey2 ? requestsByPrimaryKey.get(primaryKey2) : envelope._tag === "Request" && requests.get(envelope.requestId);
        if (existing) {
          return SaveResultEncoded.Duplicate({
            originalId: Snowflake(existing.envelope.requestId),
            lastReceivedReply: existing.lastReceivedChunk
          });
        }
        if (envelope._tag === "Request") {
          const entry = {
            envelope,
            replies: [],
            lastReceivedChunk: none2()
          };
          requests.set(envelope.requestId, entry);
          if (primaryKey2) {
            requestsByPrimaryKey.set(primaryKey2, entry);
          }
          unprocessed.add(envelope);
        } else if (envelope._tag === "AckChunk") {
          const entry = requests.get(envelope.requestId);
          if (entry) {
            entry.lastReceivedChunk = findFirst2(entry.replies, (r) => r._tag === "Chunk" && r.id === envelope.replyId).pipe(orElse(() => entry.lastReceivedChunk));
          }
        }
        journal.push(envelope);
        return SaveResultEncoded.Success();
      }),
      saveReply: (reply) => sync3(() => {
        const entry = requests.get(reply.requestId);
        if (!entry || replyIds.has(reply.id))
          return;
        if (reply._tag === "WithExit") {
          unprocessed.delete(entry.envelope);
        }
        entry.replies.push(reply);
        replyIds.add(reply.id);
        replyLatch.unsafeOpen();
      }),
      repliesFor: (requestIds) => sync3(() => {
        const replies = empty3();
        for (const requestId of requestIds) {
          const request2 = requests.get(requestId);
          if (!request2)
            continue;
          else if (isNone2(request2.lastReceivedChunk)) {
            replies.push(...request2.replies);
            continue;
          }
          const sequence2 = request2.lastReceivedChunk.value.sequence;
          for (const reply of request2.replies) {
            if (reply._tag === "Chunk" && reply.sequence <= sequence2) {
              continue;
            }
            replies.push(reply);
          }
        }
        return replies;
      }),
      unprocessedMessages: (shardIds) => sync3(() => {
        if (unprocessed.size === 0)
          return [];
        const messages = empty3();
        let index = journal.indexOf(unsafeHead(unprocessed));
        for (;index < journal.length; index++) {
          const envelope = journal[index];
          if (!shardIds.includes(envelope.address.shardId)) {
            continue;
          }
          if (envelope._tag === "Request") {
            const entry = requests.get(envelope.requestId);
            messages.push({
              envelope,
              lastSentReply: last(entry.replies)
            });
          } else {
            messages.push({
              envelope,
              lastSentReply: none2()
            });
          }
        }
        return messages;
      }),
      unprocessedMessagesById: (ids3) => sync3(() => {
        const envelopeIds = new Set;
        for (const id2 of ids3) {
          envelopeIds.add(String(id2));
        }
        return unprocessedWith((envelope) => envelopeIds.has(envelope.requestId));
      }),
      resetAddress: () => _void,
      resetShards: () => _void
    };
    const storage = yield* makeEncoded(encoded);
    return {
      storage,
      encoded,
      requests,
      requestsByPrimaryKey,
      unprocessed,
      replyIds,
      journal,
      cursors
    };
  })
})) {
}
var layerMemory = /* @__PURE__ */ effect(MessageStorage, map17(MemoryDriver, (_) => _.storage)).pipe(/* @__PURE__ */ provideMerge2(MemoryDriver.Default));
var EnvelopeWithReply = /* @__PURE__ */ Struct({
  envelope: PartialEncoded,
  lastSentReply: /* @__PURE__ */ OptionFromSelf(Encoded)
});
var decodeEnvelopeWithReply = /* @__PURE__ */ decode6(EnvelopeWithReply);

// node_modules/@effect/cluster/dist/esm/ShardingConfig.js
class ShardingConfig extends (/* @__PURE__ */ Tag2("@effect/cluster/ShardingConfig")()) {
}
var defaultRunnerAddress = /* @__PURE__ */ RunnerAddress.make({
  host: "localhost",
  port: 34431
});
var defaults = {
  runnerAddress: /* @__PURE__ */ some2(defaultRunnerAddress),
  serverVersion: 1,
  numberOfShards: 300,
  shardManagerAddress: /* @__PURE__ */ RunnerAddress.make({
    host: "localhost",
    port: 8080
  }),
  shardManagerUnavailableTimeout: /* @__PURE__ */ minutes(10),
  entityMailboxCapacity: 4096,
  entityMaxIdleTime: /* @__PURE__ */ minutes(1),
  entityTerminationTimeout: /* @__PURE__ */ seconds(15),
  entityMessagePollInterval: /* @__PURE__ */ seconds(10),
  entityReplyPollInterval: /* @__PURE__ */ millis(200),
  sendRetryInterval: /* @__PURE__ */ millis(100),
  refreshAssignmentsInterval: /* @__PURE__ */ minutes(5),
  simulateRemoteSerialization: true
};
var config2 = /* @__PURE__ */ all8({
  runnerAddress: /* @__PURE__ */ all8({
    host: string7("host").pipe(withDefault2(defaultRunnerAddress.host), withDescription2("The hostname or IP address of the runner.")),
    port: integer2("port").pipe(withDefault2(defaultRunnerAddress.port), withDescription2("The port used for inter-runner communication."))
  }).pipe(/* @__PURE__ */ map30((options6) => RunnerAddress.make(options6)), option4),
  serverVersion: /* @__PURE__ */ integer2("serverVersion").pipe(/* @__PURE__ */ withDefault2(defaults.serverVersion), /* @__PURE__ */ withDescription2("The version of the current runner.")),
  numberOfShards: /* @__PURE__ */ integer2("numberOfShards").pipe(/* @__PURE__ */ withDefault2(defaults.numberOfShards), /* @__PURE__ */ withDescription2("The number of shards to allocate to a runner.")),
  shardManagerAddress: /* @__PURE__ */ all8({
    host: string7("shardManagerHost").pipe(withDefault2(defaults.shardManagerAddress.host), withDescription2("The host of the shard manager.")),
    port: integer2("shardManagerPort").pipe(withDefault2(defaults.shardManagerAddress.port), withDescription2("The port of the shard manager."))
  }).pipe(/* @__PURE__ */ map30((options6) => RunnerAddress.make(options6))),
  shardManagerUnavailableTimeout: /* @__PURE__ */ duration3("shardManagerUnavailableTimeout").pipe(/* @__PURE__ */ withDefault2(defaults.shardManagerUnavailableTimeout), /* @__PURE__ */ withDescription2("If the shard is unavilable for this duration, all the shard assignments will be reset.")),
  entityMailboxCapacity: /* @__PURE__ */ integer2("entityMailboxCapacity").pipe(/* @__PURE__ */ withDefault2(defaults.entityMailboxCapacity), /* @__PURE__ */ withDescription2("The default capacity of the mailbox for entities.")),
  entityMaxIdleTime: /* @__PURE__ */ duration3("entityMaxIdleTime").pipe(/* @__PURE__ */ withDefault2(defaults.entityMaxIdleTime), /* @__PURE__ */ withDescription2("The maximum duration of inactivity (i.e. without receiving a message) after which an entity will be interrupted.")),
  entityTerminationTimeout: /* @__PURE__ */ duration3("entityTerminationTimeout").pipe(/* @__PURE__ */ withDefault2(defaults.entityTerminationTimeout), /* @__PURE__ */ withDescription2("The maximum duration of time to wait for an entity to terminate.")),
  entityMessagePollInterval: /* @__PURE__ */ duration3("entityMessagePollInterval").pipe(/* @__PURE__ */ withDefault2(defaults.entityMessagePollInterval), /* @__PURE__ */ withDescription2("The interval at which to poll for unprocessed messages from storage.")),
  entityReplyPollInterval: /* @__PURE__ */ duration3("entityReplyPollInterval").pipe(/* @__PURE__ */ withDefault2(defaults.entityReplyPollInterval), /* @__PURE__ */ withDescription2("The interval at which to poll for client replies from storage.")),
  sendRetryInterval: /* @__PURE__ */ duration3("sendRetryInterval").pipe(/* @__PURE__ */ withDefault2(defaults.sendRetryInterval), /* @__PURE__ */ withDescription2("The interval to retry a send if EntityNotManagedByRunner is returned.")),
  refreshAssignmentsInterval: /* @__PURE__ */ duration3("refreshAssignmentsInterval").pipe(/* @__PURE__ */ withDefault2(defaults.refreshAssignmentsInterval), /* @__PURE__ */ withDescription2("The interval at which to refresh shard assignments.")),
  simulateRemoteSerialization: /* @__PURE__ */ boolean4("simulateRemoteSerialization").pipe(/* @__PURE__ */ withDefault2(defaults.simulateRemoteSerialization), /* @__PURE__ */ withDescription2("Simulate serialization and deserialization to remote runners for local entities."))
});

// node_modules/@effect/cluster/dist/esm/Runners.js
class Runners extends (/* @__PURE__ */ Tag2("@effect/cluster/Runners")()) {
}

// node_modules/effect/dist/esm/FiberHandle.js
var TypeId52 = /* @__PURE__ */ Symbol.for("effect/FiberHandle");
var isFiberHandle = (u) => hasProperty(u, TypeId52);
var Proto8 = {
  [TypeId52]: TypeId52,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake14 = (deferred) => {
  const self2 = Object.create(Proto8);
  self2.state = {
    _tag: "Open",
    fiber: undefined
  };
  self2.deferred = deferred;
  return self2;
};
var make96 = () => acquireRelease2(map17(make24(), (deferred) => unsafeMake14(deferred)), (handle) => withFiberRuntime2((parent) => {
  const state = handle.state;
  if (state._tag === "Closed")
    return _void;
  handle.state = {
    _tag: "Closed"
  };
  return state.fiber ? intoDeferred2(asVoid4(interruptAs(state.fiber, combine3(parent.id(), internalFiberId2))), handle.deferred) : done2(handle.deferred, void_3);
}));
var internalFiberIdId2 = -1;
var internalFiberId2 = /* @__PURE__ */ make15(internalFiberIdId2, 0);
var isInternalInterruption2 = /* @__PURE__ */ reduceWithContext3(undefined, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId3) => has4(ids2(fiberId3), internalFiberIdId2),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeSet4 = /* @__PURE__ */ dual((args2) => isFiberHandle(args2[0]), (self2, fiber, options6) => {
  if (self2.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options6?.interruptAs ?? none4, internalFiberId2));
    return;
  } else if (self2.state.fiber !== undefined) {
    if (options6?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine3(options6?.interruptAs ?? none4, internalFiberId2));
      return;
    } else if (self2.state.fiber === fiber) {
      return;
    }
    self2.state.fiber.unsafeInterruptAsFork(combine3(options6?.interruptAs ?? none4, internalFiberId2));
    self2.state.fiber = undefined;
  }
  self2.state.fiber = fiber;
  fiber.addObserver((exit3) => {
    if (self2.state._tag === "Open" && fiber === self2.state.fiber) {
      self2.state.fiber = undefined;
    }
    if (isFailure2(exit3) && (options6?.propagateInterruption === true ? !isInternalInterruption2(exit3.cause) : !isInterruptedOnly2(exit3.cause))) {
      unsafeDone(self2.deferred, exit3);
    }
  });
});
var clear4 = (self2) => uninterruptibleMask3((restore) => withFiberRuntime2((fiber) => {
  if (self2.state._tag === "Closed" || self2.state.fiber === undefined) {
    return _void;
  }
  return zipRight3(restore(interruptAs(self2.state.fiber, combine3(fiber.id(), internalFiberId2))), sync3(() => {
    if (self2.state._tag === "Open") {
      self2.state.fiber = undefined;
    }
  }));
}));
var constInterruptedFiber2 = /* @__PURE__ */ function() {
  let fiber = undefined;
  return () => {
    if (fiber === undefined) {
      fiber = runFork2(interrupt7);
    }
    return fiber;
  };
}();
var run10 = function() {
  const self2 = arguments[0];
  if (isEffect2(arguments[1])) {
    return runImpl(self2, arguments[1], arguments[2]);
  }
  const options6 = arguments[1];
  return (effect4) => runImpl(self2, effect4, options6);
};
var runImpl = (self2, effect4, options6) => fiberIdWith2((fiberId3) => {
  if (self2.state._tag === "Closed") {
    return interrupt7;
  } else if (self2.state.fiber !== undefined && options6?.onlyIfMissing === true) {
    return sync3(constInterruptedFiber2);
  }
  return tap2(forkDaemon2(effect4), (fiber) => unsafeSet4(self2, fiber, {
    ...options6,
    interruptAs: fiberId3
  }));
});

// node_modules/effect/dist/esm/FiberMap.js
var TypeId53 = /* @__PURE__ */ Symbol.for("effect/FiberMap");
var isFiberMap = (u) => hasProperty(u, TypeId53);
var Proto9 = {
  [TypeId53]: TypeId53,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty2();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake15 = (backing, deferred) => {
  const self2 = Object.create(Proto9);
  self2.state = {
    _tag: "Open",
    backing
  };
  self2.deferred = deferred;
  return self2;
};
var make97 = () => acquireRelease2(map17(make24(), (deferred) => unsafeMake15(empty26(), deferred)), (map39) => withFiberRuntime2((parent) => {
  const state = map39.state;
  if (state._tag === "Closed")
    return _void;
  map39.state = {
    _tag: "Closed"
  };
  return interruptAllAs2(map3(state.backing, ([, fiber]) => fiber), combine3(parent.id(), internalFiberId3)).pipe(intoDeferred2(map39.deferred));
}));
var internalFiberIdId3 = -1;
var internalFiberId3 = /* @__PURE__ */ make15(internalFiberIdId3, 0);
var isInternalInterruption3 = /* @__PURE__ */ reduceWithContext3(undefined, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId3) => has4(ids2(fiberId3), internalFiberIdId3),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeSet5 = /* @__PURE__ */ dual((args2) => isFiberMap(args2[0]), (self2, key, fiber, options6) => {
  if (self2.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options6?.interruptAs ?? none4, internalFiberId3));
    return;
  }
  const previous2 = get12(self2.state.backing, key);
  if (previous2._tag === "Some") {
    if (options6?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine3(options6?.interruptAs ?? none4, internalFiberId3));
      return;
    } else if (previous2.value === fiber) {
      return;
    }
    previous2.value.unsafeInterruptAsFork(combine3(options6?.interruptAs ?? none4, internalFiberId3));
  }
  set7(self2.state.backing, key, fiber);
  fiber.addObserver((exit3) => {
    if (self2.state._tag === "Closed") {
      return;
    }
    const current2 = get12(self2.state.backing, key);
    if (isSome2(current2) && fiber === current2.value) {
      remove6(self2.state.backing, key);
    }
    if (isFailure2(exit3) && (options6?.propagateInterruption === true ? !isInternalInterruption3(exit3.cause) : !isInterruptedOnly2(exit3.cause))) {
      unsafeDone(self2.deferred, exit3);
    }
  });
});
var unsafeHas = /* @__PURE__ */ dual(2, (self2, key) => self2.state._tag === "Closed" ? false : has6(self2.state.backing, key));
var remove12 = /* @__PURE__ */ dual(2, (self2, key) => withFiberRuntime2((removeFiber) => {
  if (self2.state._tag === "Closed") {
    return _void;
  }
  const fiber = get12(self2.state.backing, key);
  if (fiber._tag === "None") {
    return _void;
  }
  return interruptAs(fiber.value, combine3(removeFiber.id(), internalFiberId3));
}));
var constInterruptedFiber3 = /* @__PURE__ */ function() {
  let fiber = undefined;
  return () => {
    if (fiber === undefined) {
      fiber = runFork2(interrupt7);
    }
    return fiber;
  };
}();
var run11 = function() {
  const self2 = arguments[0];
  if (isEffect2(arguments[2])) {
    return runImpl2(self2, arguments[1], arguments[2], arguments[3]);
  }
  const key = arguments[1];
  const options6 = arguments[2];
  return (effect4) => runImpl2(self2, key, effect4, options6);
};
var runImpl2 = (self2, key, effect4, options6) => fiberIdWith2((fiberId3) => {
  if (self2.state._tag === "Closed") {
    return interrupt7;
  } else if (options6?.onlyIfMissing === true && unsafeHas(self2, key)) {
    return sync3(constInterruptedFiber3);
  }
  return tap2(forkDaemon2(effect4), (fiber) => unsafeSet5(self2, key, fiber, {
    ...options6,
    interruptAs: fiberId3
  }));
});

// node_modules/effect/dist/esm/Metric.js
var gauge6 = gauge5;
var tagged4 = tagged;

// node_modules/@effect/cluster/dist/esm/ClusterMetrics.js
var entities = /* @__PURE__ */ gauge6("effect_cluster_entities", {
  bigint: true
});
var mailboxSize = /* @__PURE__ */ gauge6("effect_cluster_mailbox_size", {
  bigint: true
});

// node_modules/@effect/cluster/dist/esm/internal/hash.js
var hashOptimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var hashString = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return hashOptimize(h);
};

// node_modules/@effect/cluster/dist/esm/internal/resourceMap.js
class ResourceMap {
  lookup;
  entries;
  isClosed;
  constructor(lookup, entries2, isClosed) {
    this.lookup = lookup;
    this.entries = entries2;
    this.isClosed = isClosed;
  }
  static make = /* @__PURE__ */ fnUntraced2(function* (lookup) {
    const scope5 = yield* scope2;
    const context9 = yield* context3();
    const isClosed = make13(false);
    const entries2 = empty26();
    yield* addFinalizerExit(scope5, (exit3) => {
      set3(isClosed, true);
      return forEach9(entries2, ([key, {
        scope: scope6
      }]) => {
        remove6(entries2, key);
        return exit2(close(scope6, exit3));
      }, {
        concurrency: "unbounded",
        discard: true
      });
    });
    return new ResourceMap((key, scope6) => provide2(lookup(key), add2(context9, Scope, scope6)), entries2, isClosed);
  });
  get(key) {
    return withFiberRuntime2((fiber) => {
      if (get6(this.isClosed)) {
        return interrupt7;
      }
      const existing = get12(this.entries, key);
      if (isSome2(existing)) {
        return _await(existing.value.deferred);
      }
      const scope5 = runSync(make39());
      const deferred = unsafeMake3(fiber.id());
      set7(this.entries, key, {
        scope: scope5,
        deferred
      });
      return onExit3(this.lookup(key, scope5), (exit3) => {
        if (exit3._tag === "Success") {
          return done2(deferred, exit3);
        }
        remove6(this.entries, key);
        return done2(deferred, exit3);
      });
    });
  }
  remove(key) {
    return suspend3(() => {
      const entry = get12(this.entries, key);
      if (isNone2(entry)) {
        return _void;
      }
      remove6(this.entries, key);
      return close(entry.value.scope, void_3);
    });
  }
  removeIgnore(key) {
    return catchAllCause2(this.remove(key), (cause3) => annotateLogs2(logDebug2(cause3), {
      module: "ResourceMap",
      method: "removeIgnore",
      key
    }));
  }
}

// node_modules/@effect/cluster/dist/esm/Entity.js
var TypeId54 = /* @__PURE__ */ Symbol.for("@effect/cluster/Entity");
var isEntity = (u) => hasProperty(u, TypeId54);
var Proto10 = {
  [TypeId54]: TypeId54,
  [symbol]() {
    return structure({
      type: this.type
    });
  },
  [symbol2](that) {
    return isEntity(that) && this.type === that.type;
  },
  annotate(tag7, value8) {
    return fromRpcGroup(this.type, this.protocol.annotate(tag7, value8));
  },
  annotateRpcs(tag7, value8) {
    return fromRpcGroup(this.type, this.protocol.annotateRpcs(tag7, value8));
  },
  annotateContext(context9) {
    return fromRpcGroup(this.type, this.protocol.annotateContext(context9));
  },
  annotateRpcsContext(context9) {
    return fromRpcGroup(this.type, this.protocol.annotateRpcsContext(context9));
  },
  get client() {
    return shardingTag.pipe(flatMap10((sharding) => sharding.makeClient(this)));
  },
  toLayer(build3, options6) {
    return shardingTag.pipe(flatMap10((sharding) => sharding.registerEntity(this, isEffect2(build3) ? build3 : succeed8(build3), options6)), effectDiscard);
  },
  toLayerMailbox(build3, options6) {
    const buildHandlers = gen2(this, function* () {
      const behaviour = isEffect2(build3) ? yield* build3 : build3;
      const mailbox = yield* make81();
      const handler = (envelope) => {
        return async((resume2) => {
          mailbox.unsafeOffer(envelope);
          resumes.set(envelope, resume2);
        });
      };
      const handlers = {};
      for (const rpc of this.protocol.requests.keys()) {
        handlers[rpc] = handler;
      }
      const resumes = new Map;
      const complete4 = (request2, exit3) => sync3(() => {
        const resume2 = resumes.get(request2);
        if (resume2) {
          resumes.delete(request2);
          resume2(exit3);
        }
      });
      const replier = {
        succeed: (request2, value8) => complete4(request2, succeed4(value8)),
        fail: (request2, error5) => complete4(request2, fail4(error5)),
        failCause: (request2, cause3) => complete4(request2, failCause4(cause3)),
        complete: complete4
      };
      yield* behaviour(mailbox, replier).pipe(catchAllCause2((cause3) => {
        const exit3 = failCause4(cause3);
        for (const resume2 of resumes.values()) {
          resume2(exit3);
        }
        return _void;
      }), interruptible4, forkScoped2);
      return handlers;
    });
    return this.toLayer(buildHandlers, {
      ...options6,
      concurrency: "unbounded"
    });
  }
};
var fromRpcGroup = (type2, protocol) => {
  const self2 = Object.create(Proto10);
  self2.type = EntityType.make(type2);
  self2.protocol = protocol;
  return self2;
};
class CurrentAddress extends (/* @__PURE__ */ Tag2("@effect/cluster/Entity/EntityAddress")()) {
}

class CurrentRunnerAddress extends (/* @__PURE__ */ Tag2("@effect/cluster/Entity/RunnerAddress")()) {
}

class Request extends Class2 {
  get lastSentChunkValue() {
    return this.lastSentChunk.pipe(map2((chunk4) => lastNonEmpty(chunk4.values)));
  }
  get nextSequence() {
    if (isNone2(this.lastSentChunk)) {
      return 0;
    }
    return this.lastSentChunk.value.sequence + 1;
  }
}
var shardingTag = /* @__PURE__ */ GenericTag("@effect/cluster/Sharding");

// node_modules/@effect/cluster/dist/esm/internal/entityReaper.js
class EntityReaper extends (/* @__PURE__ */ Service()("@effect/cluster/EntityReaper", {
  scoped: /* @__PURE__ */ gen2(function* () {
    let currentResolution = 30000;
    const registered = [];
    const latch = yield* makeLatch2();
    const register = (options6) => suspend3(() => {
      currentResolution = Math.max(Math.min(currentResolution, options6.maxIdleTime), 5000);
      registered.push(options6);
      return latch.open;
    });
    const clock3 = yield* clock2;
    yield* gen2(function* () {
      while (true) {
        yield* sleep4(currentResolution);
        const now2 = clock3.unsafeCurrentTimeMillis();
        for (const {
          entities: entities2,
          maxIdleTime,
          servers
        } of registered) {
          for (const state of servers.values()) {
            const duration4 = now2 - state.lastActiveCheck;
            if (state.activeRequests.size > 0 || duration4 < maxIdleTime) {
              continue;
            }
            yield* fork3(entities2.removeIgnore(state.address));
          }
        }
      }
    }).pipe(latch.whenOpen, interruptible4, forkScoped2);
    return {
      register
    };
  })
})) {
}

// node_modules/@effect/cluster/dist/esm/internal/interruptors.js
var internalInterruptors = /* @__PURE__ */ new WeakSet;

// node_modules/@effect/cluster/dist/esm/internal/resourceRef.js
class ResourceRef {
  state;
  acquire;
  static from = /* @__PURE__ */ fnUntraced2(function* (parentScope, acquire) {
    const state = make13({
      _tag: "Closed"
    });
    yield* addFinalizerExit(parentScope, (exit3) => {
      const s = get6(state);
      if (s._tag === "Closed") {
        return _void;
      }
      const scope6 = s.scope;
      set3(state, {
        _tag: "Closed"
      });
      return close(scope6, exit3);
    });
    const scope5 = yield* make39();
    set3(state, {
      _tag: "Acquiring",
      scope: scope5
    });
    const value8 = yield* acquire(scope5);
    set3(state, {
      _tag: "Acquired",
      scope: scope5,
      value: value8
    });
    return new ResourceRef(state, acquire);
  });
  constructor(state, acquire) {
    this.state = state;
    this.acquire = acquire;
  }
  latch = /* @__PURE__ */ unsafeMakeLatch2(true);
  unsafeGet() {
    if (this.state.current._tag === "Acquired") {
      return some2(this.state.current.value);
    }
    return none2();
  }
  unsafeRebuild() {
    const s = this.state.current;
    if (s._tag === "Closed") {
      return interrupt7;
    }
    const prevScope = s.scope;
    const scope5 = runSync(make39());
    this.latch.unsafeClose();
    set3(this.state, {
      _tag: "Acquiring",
      scope: scope5
    });
    return fiberIdWith2((fiberId3) => {
      internalInterruptors.add(fiberId3);
      return close(prevScope, void_3);
    }).pipe(andThen4(this.acquire(scope5)), flatMap10((value8) => {
      set3(this.state, {
        _tag: "Acquired",
        scope: scope5,
        value: value8
      });
      return this.latch.open;
    }));
  }
  await = /* @__PURE__ */ suspend3(() => {
    const s = this.state.current;
    if (s._tag === "Closed") {
      return interrupt7;
    } else if (s._tag === "Acquired") {
      return succeed8(s.value);
    }
    return zipRight3(this.latch.await, this.await);
  });
}

// node_modules/@effect/cluster/dist/esm/internal/entityManager.js
var make99 = /* @__PURE__ */ fnUntraced2(function* (entity, buildHandlers, options6) {
  const config3 = yield* ShardingConfig;
  const snowflakeGen = yield* Generator2;
  const managerScope = yield* scope2;
  const storageEnabled = options6.storage !== noop;
  const mailboxCapacity = options6.mailboxCapacity ?? config3.entityMailboxCapacity;
  const clock3 = yield* clock2;
  const context9 = yield* context3();
  const activeServers = new Map;
  const entities2 = yield* ResourceMap.make(fnUntraced2(function* (address) {
    if (yield* options6.sharding.isShutdown) {
      return yield* new EntityNotAssignedToRunner({
        address
      });
    }
    const scope5 = yield* scope2;
    const endLatch = yield* makeLatch2();
    yield* addFinalizer2(scope5, ignore2(options6.storage.resetAddress(address)));
    const activeRequests = new Map;
    let defectRequestIds = [];
    const writeRef = yield* ResourceRef.from(scope5, fnUntraced2(function* (scope6) {
      let isShuttingDown = false;
      const handlers = yield* entity.protocol.toHandlersContext(buildHandlers).pipe(provide2(context9.pipe(add2(CurrentAddress, address), add2(CurrentRunnerAddress, options6.runnerAddress), add2(Scope, scope6))), locally(currentLogAnnotations2, empty10()));
      const server = yield* makeNoSerialization(entity.protocol, {
        spanPrefix: `${entity.type}(${address.entityId})`,
        concurrency: options6.concurrency ?? 1,
        onFromServer(response) {
          switch (response._tag) {
            case "Exit": {
              const request2 = activeRequests.get(response.requestId);
              if (!request2)
                return _void;
              request2.sentReply = true;
              if (storageEnabled && isShuttingDown && get3(request2.rpc.annotations, Persisted) && isInterrupted2(response.exit)) {
                return _void;
              }
              return retryRespond(4, suspend3(() => request2.message.respond(new WithExit({
                requestId: Snowflake(response.requestId),
                id: snowflakeGen.unsafeNext(),
                exit: response.exit
              })))).pipe(flatMap10(() => {
                activeRequests.delete(response.requestId);
                if (activeRequests.size === 0) {
                  state.lastActiveCheck = clock3.unsafeCurrentTimeMillis();
                }
                return _void;
              }), orDie2);
            }
            case "Chunk": {
              const request2 = activeRequests.get(response.requestId);
              if (!request2)
                return _void;
              const sequence2 = request2.sequence;
              request2.sequence++;
              if (!request2.sentReply) {
                request2.sentReply = true;
              }
              return orDie2(retryRespond(4, suspend3(() => {
                const reply = new Chunk({
                  requestId: Snowflake(response.requestId),
                  id: snowflakeGen.unsafeNext(),
                  sequence: sequence2,
                  values: response.values
                });
                request2.lastSentChunk = some2(reply);
                return request2.message.respond(reply);
              })));
            }
            case "Defect": {
              const effect4 = writeRef.unsafeRebuild();
              defectRequestIds = Array.from(activeRequests.keys());
              return logError2("Defect in entity, restarting", die4(response.defect)).pipe(andThen4(effect4.pipe(tapErrorCause2(logError2), retry(spaced2(500)))), annotateLogs2({
                module: "EntityManager",
                address,
                runner: options6.runnerAddress
              }));
            }
            case "ClientEnd": {
              return endLatch.open;
            }
          }
        }
      }).pipe(extend3(scope6), provide2(handlers));
      yield* addFinalizer2(scope6, sync3(() => {
        isShuttingDown = true;
      }));
      for (const id2 of defectRequestIds) {
        const {
          lastSentChunk,
          message
        } = activeRequests.get(id2);
        yield* server.write(0, {
          ...message.envelope,
          id: RequestId(message.envelope.requestId),
          tag: message.envelope.tag,
          payload: new Request({
            ...message.envelope,
            lastSentChunk
          })
        });
      }
      defectRequestIds = [];
      return server.write;
    }));
    const state = {
      address,
      mailboxGauge: mailboxSize.pipe(tagged4("type", entity.type), tagged4("entityId", address.entityId)),
      write(clientId, message) {
        if (writeRef.state.current._tag !== "Acquired") {
          return flatMap10(writeRef.await, (write3) => write3(clientId, message));
        }
        return writeRef.state.current.value(clientId, message);
      },
      activeRequests,
      lastActiveCheck: clock3.unsafeCurrentTimeMillis()
    };
    yield* addFinalizer2(scope5, withFiberRuntime2((fiber) => {
      activeServers.delete(address.entityId);
      internalInterruptors.add(fiber.id());
      return state.write(0, {
        _tag: "Eof"
      }).pipe(andThen4(interruptible4(endLatch.await)), timeoutOption2(config3.entityTerminationTimeout));
    }));
    activeServers.set(address.entityId, state);
    return state;
  }, locally(currentLogAnnotations2, empty10())));
  const reaper = yield* EntityReaper;
  const maxIdleTime = toMillis(options6.maxIdleTime ?? config3.entityMaxIdleTime);
  if (Number.isFinite(maxIdleTime)) {
    yield* reaper.register({
      maxIdleTime,
      servers: activeServers,
      entities: entities2
    });
  }
  const gauge7 = entities.pipe(tagged4("type", entity.type));
  yield* sync3(() => {
    gauge7.unsafeUpdate(BigInt(activeServers.size), []);
    for (const state of activeServers.values()) {
      state.mailboxGauge.unsafeUpdate(BigInt(state.activeRequests.size), []);
    }
  }).pipe(andThen4(sleep4(1000)), forever3, forkIn2(managerScope));
  function sendLocal(message) {
    return locally(flatMap10(entities2.get(message.envelope.address), (server) => {
      switch (message._tag) {
        case "IncomingRequestLocal": {
          let entry = server.activeRequests.get(message.envelope.requestId);
          if (entry) {
            return fail8(new AlreadyProcessingMessage({
              envelopeId: message.envelope.requestId,
              address: message.envelope.address
            }));
          }
          const rpc = entity.protocol.requests.get(message.envelope.tag);
          if (!storageEnabled && get3(rpc.annotations, Persisted)) {
            return dieMessage2("EntityManager.sendLocal: Cannot process a persisted message without MessageStorage");
          }
          if (mailboxCapacity !== "unbounded" && server.activeRequests.size >= mailboxCapacity) {
            return fail8(new MailboxFull({
              address: message.envelope.address
            }));
          }
          entry = {
            rpc,
            message,
            sentReply: false,
            lastSentChunk: message.lastSentReply,
            sequence: match2(message.lastSentReply, {
              onNone: () => 0,
              onSome: (reply) => reply._tag === "Chunk" ? reply.sequence + 1 : 0
            })
          };
          server.activeRequests.set(message.envelope.requestId, entry);
          return server.write(0, {
            ...message.envelope,
            id: RequestId(message.envelope.requestId),
            payload: new Request({
              ...message.envelope,
              lastSentChunk: message.lastSentReply
            })
          });
        }
        case "IncomingEnvelope": {
          const entry = server.activeRequests.get(message.envelope.requestId);
          if (!entry) {
            return fail8(new EntityNotAssignedToRunner({
              address: message.envelope.address
            }));
          } else if (message.envelope._tag === "AckChunk" && isSome2(entry.lastSentChunk) && message.envelope.replyId !== entry.lastSentChunk.value.id) {
            return _void;
          }
          return server.write(0, message.envelope._tag === "AckChunk" ? {
            _tag: "Ack",
            requestId: RequestId(message.envelope.requestId)
          } : {
            _tag: "Interrupt",
            requestId: RequestId(message.envelope.requestId),
            interruptors: []
          });
        }
      }
    }), currentLogAnnotations2, empty10());
  }
  const interruptShard = (shardId) => suspend3(function loop() {
    const toInterrupt = new Set;
    for (const state of activeServers.values()) {
      if (shardId === state.address.shardId) {
        toInterrupt.add(state);
      }
    }
    if (toInterrupt.size === 0) {
      return _void;
    }
    return flatMap10(forEach9(toInterrupt, (state) => entities2.removeIgnore(state.address), {
      concurrency: "unbounded",
      discard: true
    }), loop);
  });
  const decodeMessage = decode6(makeMessageSchema(entity));
  return identity({
    interruptShard,
    isProcessingFor(message, options7) {
      const state = activeServers.get(message.envelope.address.entityId);
      if (!state)
        return false;
      const request2 = state.activeRequests.get(message.envelope.requestId);
      if (request2 === undefined) {
        return false;
      } else if (options7?.excludeReplies && request2.sentReply) {
        return false;
      }
      return true;
    },
    sendLocal,
    send: (message) => decodeMessage(message).pipe(matchEffect2({
      onFailure: (cause3) => {
        if (message._tag === "IncomingEnvelope") {
          return die5(new MalformedMessage({
            cause: cause3
          }));
        }
        return orDie2(message.respond(new ReplyWithContext({
          reply: new WithExit({
            id: snowflakeGen.unsafeNext(),
            requestId: message.envelope.requestId,
            exit: die3(new MalformedMessage({
              cause: cause3
            }))
          }),
          rpc: entity.protocol.requests.get(message.envelope.tag),
          context: context9
        })));
      },
      onSuccess: (decoded) => {
        if (decoded._tag === "IncomingEnvelope") {
          return sendLocal(new IncomingEnvelope(decoded));
        }
        const request2 = message;
        const rpc = entity.protocol.requests.get(decoded.envelope.tag);
        return sendLocal(new IncomingRequestLocal({
          envelope: decoded.envelope,
          lastSentReply: decoded.lastSentReply,
          respond: (reply) => request2.respond(new ReplyWithContext({
            reply,
            rpc,
            context: context9
          }))
        }));
      }
    }), provide2(context9)),
    activeEntityCount: sync3(() => activeServers.size)
  });
});
var makeMessageSchema = (entity) => {
  const requests = empty3();
  for (const rpc of entity.protocol.requests.values()) {
    requests.push(TaggedStruct("IncomingRequest", {
      envelope: transform2(Struct({
        ...PartialEncodedRequestFromSelf.fields,
        tag: Literal2(rpc._tag),
        payload: rpc.payloadSchema
      }), RequestFromSelf, {
        decode: (encoded) => makeRequest(encoded),
        encode: identity
      }),
      lastSentReply: OptionFromSelf(Reply(rpc))
    }));
  }
  return Union2(...requests, TaggedStruct("IncomingEnvelope", {
    envelope: Union2(typeSchema(AckChunk), typeSchema(Interrupt2))
  }));
};
var retryRespond = (times2, effect4) => times2 === 0 ? effect4 : catchAll2(effect4, () => delay2(retryRespond(times2 - 1, effect4), 200));

// node_modules/@effect/cluster/dist/esm/ShardingRegistrationEvent.js
var {
  $match: match21,
  EntityRegistered,
  SingletonRegistered
} = /* @__PURE__ */ taggedEnum();

// node_modules/effect/dist/esm/MutableHashSet.js
var TypeId55 = /* @__PURE__ */ Symbol.for("effect/MutableHashSet");
var MutableHashSetProto = {
  [TypeId55]: TypeId55,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// node_modules/@effect/cluster/dist/esm/ShardStorage.js
class ShardStorage extends (/* @__PURE__ */ Tag2("@effect/cluster/ShardStorage")()) {
}

// node_modules/@effect/cluster/dist/esm/ShardManager.js
class Config extends (/* @__PURE__ */ Tag2("@effect/cluster/ShardManager/Config")()) {
  static defaults = {
    rebalanceDebounce: /* @__PURE__ */ millis(500),
    rebalanceInterval: /* @__PURE__ */ seconds(20),
    rebalanceRetryInterval: /* @__PURE__ */ seconds(10),
    rebalanceRate: 2 / 100,
    persistRetryCount: 100,
    persistRetryInterval: /* @__PURE__ */ seconds(3),
    runnerHealthCheckInterval: /* @__PURE__ */ minutes(1),
    runnerPingTimeout: /* @__PURE__ */ seconds(3)
  };
}
var configConfig = /* @__PURE__ */ all8({
  rebalanceDebounce: /* @__PURE__ */ duration3("rebalanceDebounce").pipe(/* @__PURE__ */ withDefault2(Config.defaults.rebalanceDebounce), /* @__PURE__ */ withDescription2("The duration to wait before rebalancing shards after a change.")),
  rebalanceInterval: /* @__PURE__ */ duration3("rebalanceInterval").pipe(/* @__PURE__ */ withDefault2(Config.defaults.rebalanceInterval), /* @__PURE__ */ withDescription2("The interval on which regular rebalancing of shards will occur.")),
  rebalanceRetryInterval: /* @__PURE__ */ duration3("rebalanceRetryInterval").pipe(/* @__PURE__ */ withDefault2(Config.defaults.rebalanceRetryInterval), /* @__PURE__ */ withDescription2("The interval on which rebalancing of shards which failed to be rebalanced will be retried.")),
  rebalanceRate: /* @__PURE__ */ number5("rebalanceRate").pipe(/* @__PURE__ */ withDefault2(Config.defaults.rebalanceRate), /* @__PURE__ */ withDescription2("The maximum ratio of shards to rebalance at once.")),
  persistRetryCount: /* @__PURE__ */ integer2("persistRetryCount").pipe(/* @__PURE__ */ withDefault2(Config.defaults.persistRetryCount), /* @__PURE__ */ withDescription2("The number of times persistence of runners will be retried if it fails.")),
  persistRetryInterval: /* @__PURE__ */ duration3("persistRetryInterval").pipe(/* @__PURE__ */ withDefault2(Config.defaults.persistRetryInterval), /* @__PURE__ */ withDescription2("The interval on which persistence of runners will be retried if it fails.")),
  runnerHealthCheckInterval: /* @__PURE__ */ duration3("runnerHealthCheckInterval").pipe(/* @__PURE__ */ withDefault2(Config.defaults.runnerHealthCheckInterval), /* @__PURE__ */ withDescription2("The interval on which runner health will be checked.")),
  runnerPingTimeout: /* @__PURE__ */ duration3("runnerPingTimeout").pipe(/* @__PURE__ */ withDefault2(Config.defaults.runnerPingTimeout), /* @__PURE__ */ withDescription2("The length of time to wait for a runner to respond to a ping."))
});
class ShardManagerClient extends (/* @__PURE__ */ Tag2("@effect/cluster/ShardManager/ShardManagerClient")()) {
}

// node_modules/@effect/cluster/dist/esm/SingletonAddress.js
var TypeId56 = /* @__PURE__ */ Symbol.for("@effect/cluster/SingletonAddress");

class SingletonAddress extends (/* @__PURE__ */ Class5("@effect/cluster/SingletonAddress")({
  shardId: ShardId,
  name: NonEmptyTrimmedString
})) {
  [TypeId56] = TypeId56;
  [symbol]() {
    return cached(this)(string2(`${this.shardId}:${this.name}`));
  }
  [symbol2](that) {
    return this.shardId === that.shardId && this.name === that.name;
  }
}

// node_modules/@effect/cluster/dist/esm/Sharding.js
class Sharding extends (/* @__PURE__ */ Tag2("@effect/cluster/Sharding")()) {
}
var make102 = /* @__PURE__ */ gen2(function* () {
  const config3 = yield* ShardingConfig;
  const runners2 = yield* Runners;
  const shardManager = yield* ShardManagerClient;
  const snowflakeGen = yield* Generator2;
  const shardingScope = yield* scope2;
  const isShutdown7 = make13(false);
  const storage = yield* MessageStorage;
  const storageEnabled = storage !== noop;
  const shardStorage = yield* ShardStorage;
  const entityManagers = new Map;
  const shardAssignments = empty26();
  const selfShards = new Set;
  const acquiredShards = new Set;
  const activeShardsLatch = yield* makeLatch2(false);
  const events = yield* unbounded4();
  const getRegistrationEvents = fromPubSub4(events);
  const isLocalRunner = (address) => isSome2(config3.runnerAddress) && equals(address, config3.runnerAddress.value);
  function getShardId(entityId) {
    return ShardId.make(Math.abs(hashString(entityId) % config3.numberOfShards) + 1);
  }
  function isEntityOnLocalShards(address) {
    return acquiredShards.has(address.shardId);
  }
  if (isSome2(config3.runnerAddress)) {
    const selfAddress = config3.runnerAddress.value;
    yield* addFinalizerExit(shardingScope, () => {
      return ignore2(shardStorage.releaseAll(selfAddress));
    });
    const releasingShards = new Set;
    yield* gen2(function* () {
      while (true) {
        yield* activeShardsLatch.await;
        for (const shardId of acquiredShards) {
          if (selfShards.has(shardId))
            continue;
          acquiredShards.delete(shardId);
          releasingShards.add(shardId);
        }
        const unacquiredShards = new Set;
        for (const shardId of selfShards) {
          if (acquiredShards.has(shardId) || releasingShards.has(shardId))
            continue;
          unacquiredShards.add(shardId);
        }
        if (releasingShards.size > 0) {
          yield* forkIn2(syncSingletons, shardingScope);
          yield* releaseShards;
        }
        if (unacquiredShards.size === 0) {
          yield* activeShardsLatch.close;
          continue;
        }
        const acquired = yield* shardStorage.acquire(selfAddress, unacquiredShards);
        yield* ignore2(storage.resetShards(acquired));
        for (const shardId of acquired) {
          acquiredShards.add(shardId);
        }
        if (acquired.length > 0) {
          yield* storageReadLatch.open;
          yield* forkIn2(syncSingletons, shardingScope);
        }
        yield* sleep4(1000);
      }
    }).pipe(catchAllCause2((cause3) => logWarning2("Could not acquire/release shards", cause3)), repeat(spaced2(config3.entityMessagePollInterval)), annotateLogs2({
      package: "@effect/cluster",
      module: "Sharding",
      fiber: "Shard acquisition loop",
      runner: selfAddress
    }), interruptible4, forkIn2(shardingScope));
    yield* suspend3(() => shardStorage.refresh(selfAddress, [...acquiredShards, ...releasingShards])).pipe(flatMap10((acquired) => {
      for (const shardId of acquiredShards) {
        if (!acquired.includes(shardId)) {
          acquiredShards.delete(shardId);
          releasingShards.add(shardId);
        }
      }
      return releasingShards.size > 0 ? andThen4(forkIn2(syncSingletons, shardingScope), releaseShards) : _void;
    }), retry({
      times: 5,
      schedule: spaced2(250)
    }), catchAllCause2((cause3) => logError2("Could not refresh shard locks", cause3).pipe(andThen4(clearSelfShards))), delay2("10 seconds"), forever3, interruptible4, forkIn2(shardingScope));
    const releaseShardsLock = unsafeMakeSemaphore2(1).withPermits(1);
    const releaseShards = releaseShardsLock(suspend3(() => forEach9(releasingShards, (shardId) => forEach9(entityManagers.values(), (state) => state.manager.interruptShard(shardId), {
      concurrency: "unbounded",
      discard: true
    }).pipe(andThen4(shardStorage.release(selfAddress, shardId)), annotateLogs2({
      runner: selfAddress
    }), andThen4(() => {
      releasingShards.delete(shardId);
    })), {
      concurrency: "unbounded",
      discard: true
    })));
  }
  const clearSelfShards = suspend3(() => {
    selfShards.clear();
    return activeShardsLatch.open;
  });
  const singletons = new Map;
  const singletonFibers = yield* make97();
  const withSingletonLock = unsafeMakeSemaphore2(1).withPermits(1);
  const registerSingleton = fnUntraced2(function* (name, run12) {
    const address = new SingletonAddress({
      shardId: getShardId(EntityId.make(name)),
      name
    });
    let map40 = singletons.get(address.shardId);
    if (!map40) {
      map40 = empty26();
      singletons.set(address.shardId, map40);
    }
    if (has6(map40, address)) {
      return yield* dieMessage2(`Singleton '${name}' is already registered`);
    }
    const context10 = yield* context3();
    const wrappedRun = run12.pipe(locally(currentLogAnnotations2, empty10()), andThen4(never3), scoped2, provide2(context10), orDie2, interruptible4);
    set7(map40, address, wrappedRun);
    yield* publish2(events, SingletonRegistered({
      address
    }));
    if (acquiredShards.has(address.shardId)) {
      yield* logDebug2("Starting singleton", address);
      yield* run11(singletonFibers, address, wrappedRun);
    }
  }, withSingletonLock);
  const syncSingletons = withSingletonLock(gen2(function* () {
    for (const [shardId, map40] of singletons) {
      for (const [address, run12] of map40) {
        const running4 = unsafeHas(singletonFibers, address);
        const shouldBeRunning = acquiredShards.has(shardId);
        if (running4 && !shouldBeRunning) {
          yield* logDebug2("Stopping singleton", address);
          internalInterruptors.add(yield* fiberId2);
          yield* remove12(singletonFibers, address);
        } else if (!running4 && shouldBeRunning) {
          yield* logDebug2("Starting singleton", address);
          yield* run11(singletonFibers, address, run12);
        }
      }
    }
  }));
  const storageReadLatch = yield* makeLatch2(true);
  const openStorageReadLatch = constant(storageReadLatch.open);
  const storageReadLock = unsafeMakeSemaphore2(1);
  const withStorageReadLock = storageReadLock.withPermits(1);
  let storageAlreadyProcessed = (_message) => true;
  if (storageEnabled && isSome2(config3.runnerAddress)) {
    const selfAddress = config3.runnerAddress.value;
    yield* gen2(function* () {
      yield* logDebug2("Starting");
      yield* addFinalizer3(() => logDebug2("Shutting down"));
      const sentRequestIds = new Set;
      const sentRequestIdSets = new Set;
      storageAlreadyProcessed = (message) => {
        if (!sentRequestIds.has(message.envelope.requestId)) {
          return false;
        }
        const state = entityManagers.get(message.envelope.address.entityType);
        if (!state)
          return true;
        return !state.manager.isProcessingFor(message, {
          excludeReplies: true
        });
      };
      while (true) {
        yield* storageReadLatch.await;
        storageReadLatch.unsafeClose();
        yield* storageReadLock.take(1);
        const messages = yield* storage.unprocessedMessages(acquiredShards);
        const currentSentRequestIds = new Set;
        sentRequestIdSets.add(currentSentRequestIds);
        const send = catchAllCause2(suspend3(() => {
          const message = messages[index];
          if (message._tag === "IncomingRequest") {
            if (sentRequestIds.has(message.envelope.requestId)) {
              return _void;
            }
            sentRequestIds.add(message.envelope.requestId);
            currentSentRequestIds.add(message.envelope.requestId);
          }
          const address = message.envelope.address;
          if (!acquiredShards.has(address.shardId)) {
            return _void;
          }
          const state = entityManagers.get(address.entityType);
          if (!state) {
            if (message._tag === "IncomingRequest") {
              return orDie2(message.respond(ReplyWithContext.fromDefect({
                id: snowflakeGen.unsafeNext(),
                requestId: message.envelope.requestId,
                defect: new EntityNotManagedByRunner({
                  address
                })
              })));
            }
            return _void;
          }
          const isProcessing = state.manager.isProcessingFor(message);
          if (message._tag === "IncomingEnvelope" && isProcessing) {
            return state.manager.send(message);
          } else if (isProcessing) {
            return _void;
          }
          const resumptionState = get12(entityResumptionState, address);
          if (isSome2(resumptionState)) {
            resumptionState.value.unprocessed.add(message.envelope.requestId);
            if (message.envelope._tag === "Interrupt") {
              resumptionState.value.interrupts.set(message.envelope.requestId, message);
            }
            return _void;
          }
          return state.manager.send(message);
        }), (cause3) => {
          const message = messages[index];
          const error5 = failureOption2(cause3);
          if (isNone2(error5)) {
            return storage.saveReply(ReplyWithContext.fromDefect({
              id: snowflakeGen.unsafeNext(),
              requestId: message.envelope.requestId,
              defect: squash(cause3)
            }));
          }
          if (error5.value._tag === "MailboxFull") {
            return resumeEntityFromStorage(message);
          }
          return _void;
        });
        let index = 0;
        yield* whileLoop2({
          while: () => index < messages.length,
          step: () => index++,
          body: constant(send)
        });
        yield* storageReadLock.release(1);
        while (sentRequestIdSets.size > 30) {
          const oldest = unsafeHead(sentRequestIdSets);
          sentRequestIdSets.delete(oldest);
          for (const id2 of oldest) {
            sentRequestIds.delete(id2);
          }
        }
      }
    }).pipe(scoped2, ensuring2(storageReadLock.releaseAll), catchAllCause2((cause3) => logWarning2("Could not read messages from storage", cause3)), repeat(spaced2(config3.entityMessagePollInterval)), annotateLogs2({
      package: "@effect/cluster",
      module: "Sharding",
      fiber: "Storage read loop",
      runner: selfAddress
    }), interruptible4, forkIn2(shardingScope));
    yield* storageReadLatch.open.pipe(delay2(config3.entityMessagePollInterval), forever3, interruptible4, forkIn2(shardingScope));
    const entityResumptionState = empty26();
    const resumeEntityFromStorage = (lastReceivedMessage) => {
      const address = lastReceivedMessage.envelope.address;
      const resumptionState = get12(entityResumptionState, address);
      if (isSome2(resumptionState)) {
        resumptionState.value.unprocessed.add(lastReceivedMessage.envelope.requestId);
        return _void;
      }
      set7(entityResumptionState, address, {
        unprocessed: new Set([lastReceivedMessage.envelope.requestId]),
        interrupts: new Map
      });
      return resumeEntityFromStorageImpl(address);
    };
    const resumeEntityFromStorageImpl = fnUntraced2(function* (address) {
      const state = entityManagers.get(address.entityType);
      if (!state) {
        remove6(entityResumptionState, address);
        return;
      }
      const resumptionState = getOrThrow2(get12(entityResumptionState, address));
      let done11 = false;
      while (!done11) {
        if (!acquiredShards.has(address.shardId)) {
          return;
        }
        const messageIds = empty3();
        for (const id2 of resumptionState.unprocessed) {
          if (messageIds.length === 1024)
            break;
          messageIds.push(id2);
        }
        const messages = yield* storage.unprocessedMessagesById(messageIds);
        if (messages.length === 0) {
          yield* sleep4(config3.entityMessagePollInterval);
          continue;
        }
        let index = 0;
        const sendWithRetry = catchTags2(suspend3(() => {
          if (!acquiredShards.has(address.shardId)) {
            return fail8(new EntityNotAssignedToRunner({
              address
            }));
          }
          const message = messages[index];
          const interrupt9 = message._tag === "IncomingRequest" && resumptionState.interrupts.get(message.envelope.requestId);
          return interrupt9 ? flatMap10(state.manager.send(message), () => {
            resumptionState.interrupts.delete(message.envelope.requestId);
            return state.manager.send(interrupt9);
          }) : state.manager.send(message);
        }), {
          MailboxFull: () => delay2(sendWithRetry, config3.sendRetryInterval),
          AlreadyProcessingMessage: () => _void
        });
        yield* whileLoop2({
          while: () => index < messages.length,
          body: constant(sendWithRetry),
          step: () => index++
        });
        for (const id2 of messageIds) {
          resumptionState.unprocessed.delete(id2);
        }
        if (resumptionState.unprocessed.size > 0)
          continue;
        yield* withStorageReadLock(sync3(() => {
          if (resumptionState.unprocessed.size === 0) {
            remove6(entityResumptionState, address);
            done11 = true;
          }
        }));
      }
    }, retry({
      while: (e) => e._tag === "PersistenceError",
      schedule: spaced2(config3.entityMessagePollInterval)
    }), catchAllCause2((cause3) => logError2("Could not resume unprocessed messages", cause3)), (effect4, address) => annotateLogs2(effect4, {
      package: "@effect/cluster",
      module: "Sharding",
      fiber: "Resuming unprocessed messages",
      runner: selfAddress,
      entity: address
    }), (effect4, address) => ensuring2(effect4, sync3(() => remove6(entityResumptionState, address))), interruptible4, forkIn2(shardingScope));
  }
  const sendLocal = (message) => suspend3(() => {
    const address = message.envelope.address;
    if (!isEntityOnLocalShards(address)) {
      return fail8(new EntityNotAssignedToRunner({
        address
      }));
    }
    const state = entityManagers.get(address.entityType);
    if (!state) {
      return fail8(new EntityNotManagedByRunner({
        address
      }));
    }
    return message._tag === "IncomingRequest" || message._tag === "IncomingEnvelope" ? state.manager.send(message) : runners2.sendLocal({
      message,
      send: state.manager.sendLocal,
      simulateRemoteSerialization: config3.simulateRemoteSerialization
    });
  });
  const notifyLocal = (message, discard2) => suspend3(() => {
    const address = message.envelope.address;
    if (!isEntityOnLocalShards(address)) {
      return fail8(new EntityNotAssignedToRunner({
        address
      }));
    } else if (!entityManagers.has(address.entityType)) {
      return fail8(new EntityNotManagedByRunner({
        address
      }));
    }
    const notify = storageEnabled ? openStorageReadLatch : () => dieMessage2("Sharding.notifyLocal: storage is disabled");
    if (message._tag === "IncomingRequest" || message._tag === "IncomingEnvelope") {
      if (message._tag === "IncomingRequest" && storageAlreadyProcessed(message)) {
        return fail8(new AlreadyProcessingMessage({
          address,
          envelopeId: message.envelope.requestId
        }));
      }
      return notify();
    }
    return runners2.notifyLocal({
      message,
      notify,
      discard: discard2
    });
  });
  const isTransientError = or(RunnerUnavailable.is, EntityNotAssignedToRunner.is);
  function sendOutgoing(message, discard2, retries) {
    return catchIf2(suspend3(() => {
      const address = message.envelope.address;
      const maybeRunner = get12(shardAssignments, address.shardId);
      const isPersisted = get3(message.rpc.annotations, Persisted);
      if (isPersisted && !storageEnabled) {
        return dieMessage2("Sharding.sendOutgoing: Persisted messages require MessageStorage");
      }
      const runnerIsLocal = isSome2(maybeRunner) && isLocalRunner(maybeRunner.value);
      if (isPersisted) {
        return runnerIsLocal ? notifyLocal(message, discard2) : runners2.notify({
          address: maybeRunner,
          message,
          discard: discard2
        });
      } else if (isNone2(maybeRunner)) {
        return fail8(new EntityNotAssignedToRunner({
          address
        }));
      }
      return runnerIsLocal ? sendLocal(message) : runners2.send({
        address: maybeRunner.value,
        message
      });
    }), isTransientError, (error5) => {
      if (retries === 0) {
        return die5(error5);
      }
      return delay2(sendOutgoing(message, discard2, retries && retries - 1), config3.sendRetryInterval);
    });
  }
  const shardManagerTimeoutFiber = yield* make96().pipe(extend3(shardingScope));
  const startShardManagerTimeout = run10(shardManagerTimeoutFiber, flatMap10(sleep4(config3.shardManagerUnavailableTimeout), () => {
    clear(shardAssignments);
    return clearSelfShards;
  }), {
    onlyIfMissing: true
  });
  const stopShardManagerTimeout = clear4(shardManagerTimeoutFiber);
  yield* gen2(function* () {
    yield* logDebug2("Registering with shard manager");
    if (isSome2(config3.runnerAddress)) {
      const machineId = yield* shardManager.register(config3.runnerAddress.value);
      yield* snowflakeGen.setMachineId(machineId);
    }
    yield* stopShardManagerTimeout;
    yield* logDebug2("Subscribing to sharding events");
    const mailbox = yield* shardManager.shardingEvents;
    const startedLatch = yield* make24();
    const eventsFiber = yield* gen2(function* () {
      while (true) {
        const [events2] = yield* mailbox.takeAll;
        for (const event of events2) {
          yield* logDebug2("Received sharding event", event);
          switch (event._tag) {
            case "StreamStarted": {
              yield* done2(startedLatch, void_3);
              break;
            }
            case "ShardsAssigned": {
              for (const shard of event.shards) {
                set7(shardAssignments, shard, event.address);
              }
              if (!get6(isShutdown7) && isLocalRunner(event.address)) {
                for (const shardId of event.shards) {
                  if (selfShards.has(shardId))
                    continue;
                  selfShards.add(shardId);
                }
                yield* activeShardsLatch.open;
              }
              break;
            }
            case "ShardsUnassigned": {
              for (const shard of event.shards) {
                remove6(shardAssignments, shard);
              }
              if (isLocalRunner(event.address)) {
                for (const shard of event.shards) {
                  selfShards.delete(shard);
                }
                yield* activeShardsLatch.open;
              }
              break;
            }
          }
        }
      }
    }).pipe(intoDeferred2(startedLatch), forkScoped2);
    yield* _await(startedLatch);
    const syncFiber = yield* syncAssignments.pipe(andThen4(sleep4(config3.refreshAssignmentsInterval)), forever3, forkScoped2);
    yield* joinAll([eventsFiber, syncFiber]);
  }).pipe(scoped2, catchAllCause2((cause3) => logDebug2(cause3)), zipRight3(startShardManagerTimeout), repeat(exponential3(1000).pipe(union10(spaced2(1e4)))), annotateLogs2({
    package: "@effect/cluster",
    module: "Sharding",
    fiber: "ShardManager sync",
    runner: config3.runnerAddress
  }), interruptible4, forkIn2(shardingScope));
  const syncAssignments = gen2(function* () {
    const assignments = yield* shardManager.getAssignments;
    yield* logDebug2("Received shard assignments", assignments);
    for (const [shardId, runner] of assignments) {
      if (isNone2(runner)) {
        remove6(shardAssignments, shardId);
        selfShards.delete(shardId);
        continue;
      }
      set7(shardAssignments, shardId, runner.value);
      if (!isLocalRunner(runner.value)) {
        selfShards.delete(shardId);
        continue;
      }
      if (get6(isShutdown7) || selfShards.has(shardId)) {
        continue;
      }
      selfShards.add(shardId);
    }
    yield* activeShardsLatch.open;
  });
  const clientRequests = new Map;
  const clients = yield* ResourceMap.make(fnUntraced2(function* (entity) {
    const client = yield* makeNoSerialization2(entity.protocol, {
      supportsAck: true,
      generateRequestId: () => RequestId(snowflakeGen.unsafeNext()),
      onFromClient(options6) {
        const address = unsafeGet3(options6.context, ClientAddressTag);
        switch (options6.message._tag) {
          case "Request": {
            const fiber = getOrThrow2(getCurrentFiber2());
            const id2 = Snowflake(options6.message.id);
            const rpc = entity.protocol.requests.get(options6.message.tag);
            let respond;
            if (!options6.discard) {
              const entry = {
                rpc,
                context: fiber.currentContext
              };
              clientRequests.set(id2, entry);
              respond = makeClientRespond(entry, client.write);
            } else {
              respond = clientRespondDiscard;
            }
            return sendOutgoing(new OutgoingRequest({
              envelope: makeRequest({
                requestId: id2,
                address,
                tag: options6.message.tag,
                payload: options6.message.payload,
                headers: options6.message.headers,
                traceId: options6.message.traceId,
                spanId: options6.message.spanId,
                sampled: options6.message.sampled
              }),
              lastReceivedReply: none2(),
              rpc,
              context: fiber.currentContext,
              respond
            }), options6.discard);
          }
          case "Ack": {
            const requestId = Snowflake(options6.message.requestId);
            const entry = clientRequests.get(requestId);
            if (!entry)
              return _void;
            return sendOutgoing(new OutgoingEnvelope({
              envelope: new AckChunk({
                id: snowflakeGen.unsafeNext(),
                address,
                requestId,
                replyId: entry.lastChunkId
              }),
              rpc: entry.rpc
            }), false);
          }
          case "Interrupt": {
            const requestId = Snowflake(options6.message.requestId);
            const entry = clientRequests.get(requestId);
            if (!entry)
              return _void;
            clientRequests.delete(requestId);
            const isTransientInterrupt = get6(isShutdown7) || options6.message.interruptors.some((id2) => internalInterruptors.has(id2));
            if (isTransientInterrupt && get3(entry.rpc.annotations, Persisted)) {
              return _void;
            }
            return ignore2(sendOutgoing(new OutgoingEnvelope({
              envelope: new Interrupt2({
                id: snowflakeGen.unsafeNext(),
                address,
                requestId
              }),
              rpc: entry.rpc
            }), false, 3));
          }
        }
        return _void;
      }
    });
    const wrappedClient = {};
    for (const method of Object.keys(client.client)) {
      wrappedClient[method] = function(payload, options6) {
        return client.client[method](payload, {
          ...options6,
          context: options6?.context ? merge3(options6.context, this[currentClientAddress]) : this[currentClientAddress]
        });
      };
    }
    yield* addFinalizer2(yield* scope2, withFiberRuntime2((fiber) => {
      internalInterruptors.add(fiber.id());
      return _void;
    }));
    return (entityId) => {
      const id2 = EntityId.make(entityId);
      return {
        ...wrappedClient,
        [currentClientAddress]: ClientAddressTag.context(EntityAddress.make({
          shardId: getShardId(id2),
          entityId: id2,
          entityType: entity.type
        }))
      };
    };
  }));
  const makeClient = (entity) => clients.get(entity);
  const clientRespondDiscard = (_reply) => _void;
  const makeClientRespond = (entry, write3) => (reply) => {
    switch (reply._tag) {
      case "Chunk": {
        entry.lastChunkId = reply.id;
        return write3({
          _tag: "Chunk",
          clientId: 0,
          requestId: RequestId(reply.requestId),
          values: reply.values
        });
      }
      case "WithExit": {
        clientRequests.delete(reply.requestId);
        return write3({
          _tag: "Exit",
          clientId: 0,
          requestId: RequestId(reply.requestId),
          exit: reply.exit
        });
      }
    }
  };
  const context9 = yield* context3();
  const reaper = yield* EntityReaper;
  const registerEntity = fnUntraced2(function* (entity, build3, options6) {
    if (entityManagers.has(entity.type))
      return;
    const scope5 = yield* make39();
    const manager = yield* make99(entity, build3, {
      ...options6,
      storage,
      runnerAddress: getOrThrow2(config3.runnerAddress),
      sharding
    }).pipe(provide2(context9.pipe(add2(EntityReaper, reaper), add2(Scope, scope5), add2(Generator2, snowflakeGen))));
    entityManagers.set(entity.type, {
      entity,
      scope: scope5,
      manager
    });
    yield* addFinalizer2(scope5, sync3(() => entityManagers.delete(entity.type)));
    yield* publish2(events, EntityRegistered({
      entity
    }));
  });
  yield* addFinalizerExit(shardingScope, (exit3) => forEach9(entityManagers.values(), (state) => catchAllCause2(close(state.scope, exit3), (cause3) => annotateLogs2(logError2("Error closing entity manager", cause3), {
    entity: state.entity.type
  })), {
    concurrency: "unbounded",
    discard: true
  }));
  if (isSome2(config3.runnerAddress)) {
    const selfAddress = config3.runnerAddress.value;
    yield* addFinalizer2(shardingScope, gen2(function* () {
      yield* logDebug2("Unregistering runner from shard manager", selfAddress);
      yield* shardManager.unregister(selfAddress).pipe(catchAllCause2((cause3) => logError2("Error calling unregister with shard manager", cause3)));
      yield* clearSelfShards;
    }));
  }
  yield* addFinalizer2(shardingScope, withFiberRuntime2((fiber) => {
    set3(isShutdown7, true);
    internalInterruptors.add(fiber.id());
    return _void;
  }));
  const activeEntityCount = gen2(function* () {
    let count5 = 0;
    for (const state of entityManagers.values()) {
      count5 += yield* state.manager.activeEntityCount;
    }
    return count5;
  });
  const sharding = Sharding.of({
    getRegistrationEvents,
    getShardId,
    isShutdown: sync3(() => get6(isShutdown7)),
    registerEntity,
    registerSingleton,
    makeClient,
    send: sendLocal,
    notify: (message) => notifyLocal(message, false),
    activeEntityCount
  });
  return sharding;
});
var layer9 = /* @__PURE__ */ scoped3(Sharding, make102).pipe(/* @__PURE__ */ provide3([layerGenerator, EntityReaper.Default]));
var ClientAddressTag = /* @__PURE__ */ GenericTag("@effect/cluster/Sharding/ClientAddress");
var currentClientAddress = /* @__PURE__ */ Symbol.for(ClientAddressTag.key);

// node_modules/@effect/platform-bun/dist/esm/BunContext.js
var exports_BunContext = {};
__export(exports_BunContext, {
  layer: () => layer25
});

// node_modules/@effect/platform/dist/esm/Command.js
var exports_Command2 = {};
__export(exports_Command2, {
  workingDirectory: () => workingDirectory2,
  string: () => string9,
  streamLines: () => streamLines2,
  stream: () => stream7,
  stdout: () => stdout2,
  stdin: () => stdin2,
  stderr: () => stderr2,
  start: () => start4,
  runInShell: () => runInShell2,
  pipeTo: () => pipeTo4,
  make: () => make107,
  lines: () => lines3,
  isCommand: () => isCommand3,
  flatten: () => flatten17,
  feed: () => feed2,
  exitCode: () => exitCode2,
  env: () => env2,
  CommandTypeId: () => CommandTypeId2
});

// node_modules/@effect/platform/dist/esm/internal/commandExecutor.js
var TypeId58 = /* @__PURE__ */ Symbol.for("@effect/platform/CommandExecutor");
var ProcessTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Process");
var ExitCode = /* @__PURE__ */ nominal();
var ProcessId = /* @__PURE__ */ nominal();
var CommandExecutor = /* @__PURE__ */ GenericTag("@effect/platform/CommandExecutor");
var makeExecutor = (start3) => {
  const stream6 = (command) => unwrapScoped6(map17(start3(command), (process2) => process2.stdout));
  const streamLines = (command, encoding) => {
    const decoder3 = new TextDecoder(encoding);
    return splitLines3(mapChunks2(stream6(command), map6((bytes) => decoder3.decode(bytes))));
  };
  return {
    [TypeId58]: TypeId58,
    start: start3,
    exitCode: (command) => scoped2(flatMap10(start3(command), (process2) => process2.exitCode)),
    stream: stream6,
    string: (command, encoding = "utf-8") => {
      const decoder3 = new TextDecoder(encoding);
      return pipe(start3(command), flatMap10((process2) => run4(process2.stdout, collectUint8Array)), map17((bytes) => decoder3.decode(bytes)), scoped2);
    },
    lines: (command, encoding = "utf-8") => {
      return pipe(streamLines(command, encoding), runCollect3, map17(toArray2));
    },
    streamLines
  };
};
var collectUint8Array = /* @__PURE__ */ foldLeftChunks2(/* @__PURE__ */ new Uint8Array, (bytes, chunk4) => reduce2(chunk4, bytes, (acc, curr) => {
  const newArray = new Uint8Array(acc.length + curr.length);
  newArray.set(acc);
  newArray.set(curr, acc.length);
  return newArray;
}));

// node_modules/@effect/platform/dist/esm/internal/command.js
var CommandTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Command");
var isCommand2 = (u) => typeof u === "object" && u != null && (CommandTypeId in u);
var env = /* @__PURE__ */ dual(2, (self2, environment2) => {
  switch (self2._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self2,
        env: union5(self2.env, fromIterable6(Object.entries(environment2).filter(([v]) => v !== undefined)))
      });
    }
    case "PipedCommand": {
      return pipeTo3(env(self2.left, environment2), env(self2.right, environment2));
    }
  }
});
var exitCode = (self2) => flatMap10(CommandExecutor, (executor) => executor.exitCode(self2));
var feed = /* @__PURE__ */ dual(2, (self2, input) => stdin(self2, fromChunk2(of2(new TextEncoder().encode(input)))));
var flatten16 = (self2) => Array.from(flattenLoop(self2));
var flattenLoop = (self2) => {
  switch (self2._tag) {
    case "StandardCommand": {
      return of2(self2);
    }
    case "PipedCommand": {
      return appendAll2(flattenLoop(self2.left), flattenLoop(self2.right));
    }
  }
};
var runInShell = /* @__PURE__ */ dual(2, (self2, shell) => {
  switch (self2._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self2,
        shell
      });
    }
    case "PipedCommand": {
      return pipeTo3(runInShell(self2.left, shell), runInShell(self2.right, shell));
    }
  }
});
var lines2 = (command, encoding = "utf-8") => flatMap10(CommandExecutor, (executor) => executor.lines(command, encoding));
var Proto11 = {
  [CommandTypeId]: CommandTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...BaseProto
};
var StandardProto = {
  ...Proto11,
  _tag: "StandardCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      command: this.command,
      args: this.args,
      env: Object.fromEntries(this.env),
      cwd: this.cwd.toJSON(),
      shell: this.shell,
      gid: this.gid.toJSON(),
      uid: this.uid.toJSON()
    };
  }
};
var makeStandard = (options6) => Object.assign(Object.create(StandardProto), options6);
var PipedProto = {
  ...Proto11,
  _tag: "PipedCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      left: this.left.toJSON(),
      right: this.right.toJSON()
    };
  }
};
var makePiped = (options6) => Object.assign(Object.create(PipedProto), options6);
var make106 = (command, ...args2) => makeStandard({
  command,
  args: args2,
  env: empty10(),
  cwd: none2(),
  shell: false,
  stdin: "pipe",
  stdout: "pipe",
  stderr: "pipe",
  gid: none2(),
  uid: none2()
});
var pipeTo3 = /* @__PURE__ */ dual(2, (self2, into3) => makePiped({
  left: self2,
  right: into3
}));
var stderr = /* @__PURE__ */ dual(2, (self2, output) => {
  switch (self2._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self2,
        stderr: output
      });
    }
    case "PipedCommand": {
      return makePiped({
        ...self2,
        right: stderr(self2.right, output)
      });
    }
  }
});
var stdin = /* @__PURE__ */ dual(2, (self2, input) => {
  switch (self2._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self2,
        stdin: input
      });
    }
    case "PipedCommand": {
      return makePiped({
        ...self2,
        left: stdin(self2.left, input)
      });
    }
  }
});
var stdout = /* @__PURE__ */ dual(2, (self2, output) => {
  switch (self2._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self2,
        stdout: output
      });
    }
    case "PipedCommand": {
      return makePiped({
        ...self2,
        right: stdout(self2.right, output)
      });
    }
  }
});
var start3 = (command) => flatMap10(CommandExecutor, (executor) => executor.start(command));
var stream6 = (command) => flatMap18(CommandExecutor, (executor) => executor.stream(command));
var streamLines = (command, encoding) => flatMap18(CommandExecutor, (executor) => executor.streamLines(command, encoding));
var string8 = /* @__PURE__ */ dual((args2) => isCommand2(args2[0]), (command, encoding) => flatMap10(CommandExecutor, (executor) => executor.string(command, encoding)));
var workingDirectory = /* @__PURE__ */ dual(2, (self2, cwd) => {
  switch (self2._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self2,
        cwd: some2(cwd)
      });
    }
    case "PipedCommand": {
      return pipeTo3(workingDirectory(self2.left, cwd), workingDirectory(self2.right, cwd));
    }
  }
});

// node_modules/@effect/platform/dist/esm/Command.js
var CommandTypeId2 = CommandTypeId;
var isCommand3 = isCommand2;
var env2 = env;
var exitCode2 = exitCode;
var feed2 = feed;
var flatten17 = flatten16;
var lines3 = lines2;
var make107 = make106;
var pipeTo4 = pipeTo3;
var runInShell2 = runInShell;
var start4 = start3;
var stream7 = stream6;
var streamLines2 = streamLines;
var string9 = string8;
var stderr2 = stderr;
var stdin2 = stdin;
var stdout2 = stdout;
var workingDirectory2 = workingDirectory;

// node_modules/@effect/platform/dist/esm/CommandExecutor.js
var CommandExecutor2 = CommandExecutor;
var ProcessTypeId2 = ProcessTypeId;
var ExitCode2 = ExitCode;
var ProcessId2 = ProcessId;
var makeExecutor2 = makeExecutor;

// node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
import * as ChildProcess from "node:child_process";

// node_modules/@effect/platform-node-shared/dist/esm/internal/error.js
var handleErrnoException = (module, method) => (err, [path4]) => {
  let reason = "Unknown";
  switch (err.code) {
    case "ENOENT":
      reason = "NotFound";
      break;
    case "EACCES":
      reason = "PermissionDenied";
      break;
    case "EEXIST":
      reason = "AlreadyExists";
      break;
    case "EISDIR":
      reason = "BadResource";
      break;
    case "ENOTDIR":
      reason = "BadResource";
      break;
    case "EBUSY":
      reason = "Busy";
      break;
    case "ELOOP":
      reason = "BadResource";
      break;
  }
  return SystemError({
    reason,
    module,
    method,
    pathOrDescriptor: path4,
    syscall: err.syscall,
    message: err.message
  });
};

// node_modules/@effect/platform-node-shared/dist/esm/internal/stream.js
var fromReadable = (evaluate3, onError5, {
  chunkSize
} = {}) => fromChannel4(fromReadableChannel(evaluate3, onError5, chunkSize ? Number(chunkSize) : undefined));
var fromReadableChannel = (evaluate3, onError5, chunkSize) => acquireUseRelease4(tap2(zip5(sync3(evaluate3), make81()), ([readable, mailbox]) => readableOffer(readable, mailbox, onError5)), ([readable, mailbox]) => readableTake(readable, mailbox, chunkSize), ([readable, mailbox]) => zipRight3(sync3(() => {
  if ("closed" in readable && !readable.closed) {
    readable.destroy();
  }
}), mailbox.shutdown));
var writeInput = (writable, onFailure, {
  encoding,
  endOnDone = true
} = {}, onDone3 = _void) => {
  const write3 = writeEffect(writable, encoding);
  const close2 = endOnDone ? async((resume2) => {
    if ("closed" in writable && writable.closed) {
      resume2(_void);
    } else {
      writable.once("finish", () => resume2(_void));
      writable.end();
    }
  }) : _void;
  return {
    awaitRead: () => _void,
    emit: write3,
    error: (cause3) => zipRight3(close2, onFailure(cause3)),
    done: (_) => zipRight3(close2, onDone3)
  };
};
var writeEffect = (writable, encoding) => (chunk4) => chunk4.length === 0 ? _void : async((resume2) => {
  const iterator = chunk4[Symbol.iterator]();
  let next4 = iterator.next();
  function loop3() {
    const item = next4;
    next4 = iterator.next();
    const success = writable.write(item.value, encoding);
    if (next4.done) {
      resume2(_void);
    } else if (success) {
      loop3();
    } else {
      writable.once("drain", loop3);
    }
  }
  loop3();
});
var readableOffer = (readable, mailbox, onError5) => sync3(() => {
  readable.on("readable", () => {
    mailbox.unsafeOffer(undefined);
  });
  readable.on("error", (err) => {
    mailbox.unsafeDone(fail4(onError5(err)));
  });
  readable.on("end", () => {
    mailbox.unsafeDone(void_3);
  });
  if (readable.readable) {
    mailbox.unsafeOffer(undefined);
  }
});
var readableTake = (readable, mailbox, chunkSize) => {
  const read4 = readChunkChannel(readable, chunkSize);
  const loop3 = flatMap17(mailbox.takeAll, ([, done11]) => done11 ? read4 : zipRight9(read4, loop3));
  return loop3;
};
var readChunkChannel = (readable, chunkSize) => suspend9(() => {
  const arr = [];
  let chunk4 = readable.read(chunkSize);
  if (chunk4 === null) {
    return void_8;
  }
  while (chunk4 !== null) {
    arr.push(chunk4);
    chunk4 = readable.read(chunkSize);
  }
  return write2(unsafeFromArray(arr));
});

// node_modules/@effect/platform-node-shared/dist/esm/internal/sink.js
var fromWritable = (evaluate3, onError5, options6) => fromChannel3(fromWritableChannel(evaluate3, onError5, options6));
var fromWritableChannel = (writable, onError5, options6) => flatMap17(zip5(sync3(() => writable()), make24()), ([writable2, deferred]) => embedInput2(writableOutput(writable2, deferred, onError5), writeInput(writable2, (cause3) => failCause2(deferred, cause3), options6, complete(deferred, _void))));
var writableOutput = (writable, deferred, onError5) => suspend3(() => {
  function handleError(err) {
    unsafeDone(deferred, fail8(onError5(err)));
  }
  writable.on("error", handleError);
  return ensuring2(_await(deferred), sync3(() => {
    writable.removeListener("error", handleError);
  }));
});

// node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
var inputToStdioOption = (stdin3) => typeof stdin3 === "string" ? stdin3 : "pipe";
var outputToStdioOption = (output) => typeof output === "string" ? output : "pipe";
var toError = (err) => err instanceof globalThis.Error ? err : new globalThis.Error(String(err));
var toPlatformError = (method, error5, command) => {
  const flattened2 = flatten17(command).reduce((acc, curr) => {
    const command2 = `${curr.command} ${curr.args.join(" ")}`;
    return acc.length === 0 ? command2 : `${acc} | ${command2}`;
  }, "");
  return handleErrnoException("Command", method)(error5, [flattened2]);
};
var ProcessProto = {
  [ProcessTypeId2]: ProcessTypeId2,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/CommandExecutor/Process",
      pid: this.pid
    };
  }
};
var runCommand = (fileSystem) => (command) => {
  switch (command._tag) {
    case "StandardCommand": {
      const spawn2 = flatMap10(make24(), (exitCode3) => async((resume2) => {
        const handle = ChildProcess.spawn(command.command, command.args, {
          stdio: [inputToStdioOption(command.stdin), outputToStdioOption(command.stdout), outputToStdioOption(command.stderr)],
          cwd: getOrElse(command.cwd, constUndefined),
          shell: command.shell,
          env: {
            ...process.env,
            ...Object.fromEntries(command.env)
          }
        });
        handle.on("error", (err) => {
          resume2(fail8(toPlatformError("spawn", err, command)));
        });
        handle.on("exit", (...args2) => {
          unsafeDone(exitCode3, succeed8(args2));
        });
        handle.on("spawn", () => {
          resume2(succeed8([handle, exitCode3]));
        });
        return sync3(() => {
          handle.kill("SIGTERM");
        });
      }));
      return pipe(match2(command.cwd, {
        onNone: () => _void,
        onSome: (dir3) => fileSystem.access(dir3)
      }), zipRight3(acquireRelease2(spawn2, ([handle, exitCode3]) => flatMap10(isDone(exitCode3), (done11) => done11 ? _void : suspend3(() => {
        if (handle.kill("SIGTERM")) {
          return _await(exitCode3);
        }
        return _void;
      })))), map17(([handle, exitCodeDeferred]) => {
        let stdin3 = drain4;
        if (handle.stdin !== null) {
          stdin3 = fromWritable(() => handle.stdin, (err) => toPlatformError("toWritable", toError(err), command));
        }
        const exitCode3 = flatMap10(_await(exitCodeDeferred), ([code3, signal]) => {
          if (code3 !== null) {
            return succeed8(ExitCode2(code3));
          }
          return fail8(toPlatformError("exitCode", new globalThis.Error(`Process interrupted due to receipt of signal: ${signal}`), command));
        });
        const isRunning4 = negate2(isDone(exitCodeDeferred));
        const kill = (signal = "SIGTERM") => suspend3(() => handle.kill(signal) ? asVoid4(_await(exitCodeDeferred)) : fail8(toPlatformError("kill", new globalThis.Error("Failed to kill process"), command)));
        const pid = ProcessId2(handle.pid);
        const stderr3 = fromReadable(() => handle.stderr, (err) => toPlatformError("fromReadable(stderr)", toError(err), command));
        let stdout3 = fromReadable(() => handle.stdout, (err) => toPlatformError("fromReadable(stdout)", toError(err), command));
        if (typeof command.stdout !== "string") {
          stdout3 = transduce2(stdout3, command.stdout);
        }
        return Object.assign(Object.create(ProcessProto), {
          pid,
          exitCode: exitCode3,
          isRunning: isRunning4,
          kill,
          stdin: stdin3,
          stderr: stderr3,
          stdout: stdout3
        });
      }), typeof command.stdin === "string" ? identity : tap2((process2) => forkDaemon2(run4(command.stdin, process2.stdin))));
    }
    case "PipedCommand": {
      const flattened2 = flatten17(command);
      if (flattened2.length === 1) {
        return pipe(flattened2[0], runCommand(fileSystem));
      }
      const head10 = flattened2[0];
      const tail2 = flattened2.slice(1);
      const initial = tail2.slice(0, tail2.length - 1);
      const last5 = tail2[tail2.length - 1];
      const stream8 = initial.reduce((stdin3, command2) => pipe(stdin2(command2, stdin3), runCommand(fileSystem), map17((process2) => process2.stdout), unwrapScoped6), pipe(runCommand(fileSystem)(head10), map17((process2) => process2.stdout), unwrapScoped6));
      return pipe(stdin2(last5, stream8), runCommand(fileSystem));
    }
  }
};
var layer12 = /* @__PURE__ */ effect(CommandExecutor2, /* @__PURE__ */ pipe(FileSystem, /* @__PURE__ */ map17((fileSystem) => makeExecutor2(runCommand(fileSystem)))));

// node_modules/@effect/platform-node-shared/dist/esm/NodeCommandExecutor.js
var layer13 = layer12;

// node_modules/@effect/platform-bun/dist/esm/BunCommandExecutor.js
var layer14 = layer13;

// node_modules/@effect/platform/dist/esm/internal/effectify.js
var effectify = (fn2, onError5, onSyncError) => (...args2) => async((resume2) => {
  try {
    fn2(...args2, (err, result) => {
      if (err) {
        resume2(fail8(onError5 ? onError5(err, args2) : err));
      } else {
        resume2(succeed8(result));
      }
    });
  } catch (err) {
    resume2(onSyncError ? fail8(onSyncError(err, args2)) : die5(err));
  }
});

// node_modules/@effect/platform/dist/esm/Effectify.js
var effectify2 = effectify;

// node_modules/@effect/platform-node-shared/dist/esm/internal/fileSystem.js
import * as Crypto from "node:crypto";
import * as NFS from "node:fs";
import * as OS from "node:os";
import * as Path3 from "node:path";
var handleBadArgument = (method) => (err) => BadArgument({
  module: "FileSystem",
  method,
  message: err.message ?? String(err)
});
var access2 = /* @__PURE__ */ (() => {
  const nodeAccess = /* @__PURE__ */ effectify2(NFS.access, /* @__PURE__ */ handleErrnoException("FileSystem", "access"), /* @__PURE__ */ handleBadArgument("access"));
  return (path4, options6) => {
    let mode = NFS.constants.F_OK;
    if (options6?.readable) {
      mode |= NFS.constants.R_OK;
    }
    if (options6?.writable) {
      mode |= NFS.constants.W_OK;
    }
    return nodeAccess(path4, mode);
  };
})();
var copy4 = /* @__PURE__ */ (() => {
  const nodeCp = /* @__PURE__ */ effectify2(NFS.cp, /* @__PURE__ */ handleErrnoException("FileSystem", "copy"), /* @__PURE__ */ handleBadArgument("copy"));
  return (fromPath, toPath, options6) => nodeCp(fromPath, toPath, {
    force: options6?.overwrite ?? false,
    preserveTimestamps: options6?.preserveTimestamps ?? false,
    recursive: true
  });
})();
var copyFile2 = /* @__PURE__ */ (() => {
  const nodeCopyFile = /* @__PURE__ */ effectify2(NFS.copyFile, /* @__PURE__ */ handleErrnoException("FileSystem", "copyFile"), /* @__PURE__ */ handleBadArgument("copyFile"));
  return (fromPath, toPath) => nodeCopyFile(fromPath, toPath);
})();
var chmod2 = /* @__PURE__ */ (() => {
  const nodeChmod = /* @__PURE__ */ effectify2(NFS.chmod, /* @__PURE__ */ handleErrnoException("FileSystem", "chmod"), /* @__PURE__ */ handleBadArgument("chmod"));
  return (path4, mode) => nodeChmod(path4, mode);
})();
var chown2 = /* @__PURE__ */ (() => {
  const nodeChown = /* @__PURE__ */ effectify2(NFS.chown, /* @__PURE__ */ handleErrnoException("FileSystem", "chown"), /* @__PURE__ */ handleBadArgument("chown"));
  return (path4, uid, gid) => nodeChown(path4, uid, gid);
})();
var link2 = /* @__PURE__ */ (() => {
  const nodeLink = /* @__PURE__ */ effectify2(NFS.link, /* @__PURE__ */ handleErrnoException("FileSystem", "link"), /* @__PURE__ */ handleBadArgument("link"));
  return (existingPath, newPath) => nodeLink(existingPath, newPath);
})();
var makeDirectory = /* @__PURE__ */ (() => {
  const nodeMkdir = /* @__PURE__ */ effectify2(NFS.mkdir, /* @__PURE__ */ handleErrnoException("FileSystem", "makeDirectory"), /* @__PURE__ */ handleBadArgument("makeDirectory"));
  return (path4, options6) => nodeMkdir(path4, {
    recursive: options6?.recursive ?? false,
    mode: options6?.mode
  });
})();
var makeTempDirectoryFactory = (method) => {
  const nodeMkdtemp = effectify2(NFS.mkdtemp, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (options6) => suspend3(() => {
    const prefix = options6?.prefix ?? "";
    const directory5 = typeof options6?.directory === "string" ? Path3.join(options6.directory, ".") : OS.tmpdir();
    return nodeMkdtemp(prefix ? Path3.join(directory5, prefix) : directory5 + "/");
  });
};
var makeTempDirectory = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectory");
var removeFactory = (method) => {
  const nodeRm = effectify2(NFS.rm, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (path4, options6) => nodeRm(path4, {
    recursive: options6?.recursive ?? false,
    force: options6?.force ?? false
  });
};
var remove13 = /* @__PURE__ */ removeFactory("remove");
var makeTempDirectoryScoped = /* @__PURE__ */ (() => {
  const makeDirectory2 = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectoryScoped");
  const removeDirectory = /* @__PURE__ */ removeFactory("makeTempDirectoryScoped");
  return (options6) => acquireRelease2(makeDirectory2(options6), (directory5) => orDie2(removeDirectory(directory5, {
    recursive: true
  })));
})();
var openFactory = (method) => {
  const nodeOpen = effectify2(NFS.open, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeClose = effectify2(NFS.close, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (path4, options6) => pipe(acquireRelease2(nodeOpen(path4, options6?.flag ?? "r", options6?.mode), (fd) => orDie2(nodeClose(fd))), map17((fd) => makeFile(FileDescriptor(fd), options6?.flag?.startsWith("a") ?? false)));
};
var open2 = /* @__PURE__ */ openFactory("open");
var makeFile = /* @__PURE__ */ (() => {
  const nodeReadFactory = (method) => effectify2(NFS.read, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeRead = /* @__PURE__ */ nodeReadFactory("read");
  const nodeReadAlloc = /* @__PURE__ */ nodeReadFactory("readAlloc");
  const nodeStat = /* @__PURE__ */ effectify2(NFS.fstat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
  const nodeTruncate = /* @__PURE__ */ effectify2(NFS.ftruncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
  const nodeSync = /* @__PURE__ */ effectify2(NFS.fsync, /* @__PURE__ */ handleErrnoException("FileSystem", "sync"), /* @__PURE__ */ handleBadArgument("sync"));
  const nodeWriteFactory = (method) => effectify2(NFS.write, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeWrite = /* @__PURE__ */ nodeWriteFactory("write");
  const nodeWriteAll = /* @__PURE__ */ nodeWriteFactory("writeAll");

  class FileImpl {
    fd;
    append;
    [FileTypeId];
    semaphore = /* @__PURE__ */ unsafeMakeSemaphore2(1);
    position = 0n;
    constructor(fd, append6) {
      this.fd = fd;
      this.append = append6;
      this[FileTypeId] = FileTypeId;
    }
    get stat() {
      return map17(nodeStat(this.fd), makeFileInfo);
    }
    get sync() {
      return nodeSync(this.fd);
    }
    seek(offset, from) {
      const offsetSize = Size2(offset);
      return this.semaphore.withPermits(1)(sync3(() => {
        if (from === "start") {
          this.position = offsetSize;
        } else if (from === "current") {
          this.position = this.position + offsetSize;
        }
        return this.position;
      }));
    }
    read(buffer4) {
      return this.semaphore.withPermits(1)(map17(suspend3(() => nodeRead(this.fd, {
        buffer: buffer4,
        position: this.position
      })), (bytesRead) => {
        const sizeRead = Size2(bytesRead);
        this.position = this.position + sizeRead;
        return sizeRead;
      }));
    }
    readAlloc(size18) {
      const sizeNumber = Number(size18);
      return this.semaphore.withPermits(1)(flatMap10(sync3(() => Buffer.allocUnsafeSlow(sizeNumber)), (buffer4) => map17(nodeReadAlloc(this.fd, {
        buffer: buffer4,
        position: this.position
      }), (bytesRead) => {
        if (bytesRead === 0) {
          return none2();
        }
        this.position = this.position + BigInt(bytesRead);
        if (bytesRead === sizeNumber) {
          return some2(buffer4);
        }
        const dst = Buffer.allocUnsafeSlow(bytesRead);
        buffer4.copy(dst, 0, 0, bytesRead);
        return some2(dst);
      })));
    }
    truncate(length4) {
      return this.semaphore.withPermits(1)(map17(nodeTruncate(this.fd, length4 ? Number(length4) : undefined), () => {
        if (!this.append) {
          const len = BigInt(length4 ?? 0);
          if (this.position > len) {
            this.position = len;
          }
        }
      }));
    }
    write(buffer4) {
      return this.semaphore.withPermits(1)(map17(suspend3(() => nodeWrite(this.fd, buffer4, undefined, undefined, this.append ? undefined : Number(this.position))), (bytesWritten) => {
        const sizeWritten = Size2(bytesWritten);
        if (!this.append) {
          this.position = this.position + sizeWritten;
        }
        return sizeWritten;
      }));
    }
    writeAllChunk(buffer4) {
      return flatMap10(suspend3(() => nodeWriteAll(this.fd, buffer4, undefined, undefined, this.append ? undefined : Number(this.position))), (bytesWritten) => {
        if (bytesWritten === 0) {
          return fail8(SystemError({
            module: "FileSystem",
            method: "writeAll",
            reason: "WriteZero",
            pathOrDescriptor: this.fd,
            message: "write returned 0 bytes written"
          }));
        }
        if (!this.append) {
          this.position = this.position + BigInt(bytesWritten);
        }
        return bytesWritten < buffer4.length ? this.writeAllChunk(buffer4.subarray(bytesWritten)) : _void;
      });
    }
    writeAll(buffer4) {
      return this.semaphore.withPermits(1)(this.writeAllChunk(buffer4));
    }
  }
  return (fd, append6) => new FileImpl(fd, append6);
})();
var makeTempFileFactory = (method) => {
  const makeDirectory2 = makeTempDirectoryFactory(method);
  const open3 = openFactory(method);
  const randomHexString2 = (bytes) => sync3(() => Crypto.randomBytes(bytes).toString("hex"));
  return (options6) => pipe(zip5(makeDirectory2(options6), randomHexString2(6)), map17(([directory5, random4]) => Path3.join(directory5, random4)), tap2((path4) => scoped2(open3(path4, {
    flag: "w+"
  }))));
};
var makeTempFile = /* @__PURE__ */ makeTempFileFactory("makeTempFile");
var makeTempFileScoped = /* @__PURE__ */ (() => {
  const makeFile2 = /* @__PURE__ */ makeTempFileFactory("makeTempFileScoped");
  const removeDirectory = /* @__PURE__ */ removeFactory("makeTempFileScoped");
  return (options6) => acquireRelease2(makeFile2(options6), (file8) => orDie2(removeDirectory(Path3.dirname(file8), {
    recursive: true
  })));
})();
var readDirectory = (path4, options6) => tryPromise2({
  try: () => NFS.promises.readdir(path4, options6),
  catch: (err) => handleErrnoException("FileSystem", "readDirectory")(err, [path4])
});
var readFile2 = (path4) => async((resume2, signal) => {
  try {
    NFS.readFile(path4, {
      signal
    }, (err, data) => {
      if (err) {
        resume2(fail8(handleErrnoException("FileSystem", "readFile")(err, [path4])));
      } else {
        resume2(succeed8(data));
      }
    });
  } catch (err) {
    resume2(fail8(handleBadArgument("readFile")(err)));
  }
});
var readLink = /* @__PURE__ */ (() => {
  const nodeReadLink = /* @__PURE__ */ effectify2(NFS.readlink, /* @__PURE__ */ handleErrnoException("FileSystem", "readLink"), /* @__PURE__ */ handleBadArgument("readLink"));
  return (path4) => nodeReadLink(path4);
})();
var realPath = /* @__PURE__ */ (() => {
  const nodeRealPath = /* @__PURE__ */ effectify2(NFS.realpath, /* @__PURE__ */ handleErrnoException("FileSystem", "realPath"), /* @__PURE__ */ handleBadArgument("realPath"));
  return (path4) => nodeRealPath(path4);
})();
var rename3 = /* @__PURE__ */ (() => {
  const nodeRename = /* @__PURE__ */ effectify2(NFS.rename, /* @__PURE__ */ handleErrnoException("FileSystem", "rename"), /* @__PURE__ */ handleBadArgument("rename"));
  return (oldPath, newPath) => nodeRename(oldPath, newPath);
})();
var makeFileInfo = (stat2) => ({
  type: stat2.isFile() ? "File" : stat2.isDirectory() ? "Directory" : stat2.isSymbolicLink() ? "SymbolicLink" : stat2.isBlockDevice() ? "BlockDevice" : stat2.isCharacterDevice() ? "CharacterDevice" : stat2.isFIFO() ? "FIFO" : stat2.isSocket() ? "Socket" : "Unknown",
  mtime: fromNullable(stat2.mtime),
  atime: fromNullable(stat2.atime),
  birthtime: fromNullable(stat2.birthtime),
  dev: stat2.dev,
  rdev: fromNullable(stat2.rdev),
  ino: fromNullable(stat2.ino),
  mode: stat2.mode,
  nlink: fromNullable(stat2.nlink),
  uid: fromNullable(stat2.uid),
  gid: fromNullable(stat2.gid),
  size: Size2(stat2.size),
  blksize: fromNullable(Size2(stat2.blksize)),
  blocks: fromNullable(stat2.blocks)
});
var stat2 = /* @__PURE__ */ (() => {
  const nodeStat = /* @__PURE__ */ effectify2(NFS.stat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
  return (path4) => map17(nodeStat(path4), makeFileInfo);
})();
var symlink2 = /* @__PURE__ */ (() => {
  const nodeSymlink = /* @__PURE__ */ effectify2(NFS.symlink, /* @__PURE__ */ handleErrnoException("FileSystem", "symlink"), /* @__PURE__ */ handleBadArgument("symlink"));
  return (target2, path4) => nodeSymlink(target2, path4);
})();
var truncate2 = /* @__PURE__ */ (() => {
  const nodeTruncate = /* @__PURE__ */ effectify2(NFS.truncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
  return (path4, length4) => nodeTruncate(path4, length4 !== undefined ? Number(length4) : undefined);
})();
var utimes2 = /* @__PURE__ */ (() => {
  const nodeUtimes = /* @__PURE__ */ effectify2(NFS.utimes, /* @__PURE__ */ handleErrnoException("FileSystem", "utime"), /* @__PURE__ */ handleBadArgument("utime"));
  return (path4, atime, mtime) => nodeUtimes(path4, atime, mtime);
})();
var watchNode = (path4) => asyncScoped2((emit2) => acquireRelease2(sync3(() => {
  const watcher = NFS.watch(path4, {}, (event, path5) => {
    if (!path5)
      return;
    switch (event) {
      case "rename": {
        emit2.fromEffect(match12(stat2(path5), {
          onSuccess: (_) => WatchEventCreate({
            path: path5
          }),
          onFailure: (_) => WatchEventRemove({
            path: path5
          })
        }));
        return;
      }
      case "change": {
        emit2.single(WatchEventUpdate({
          path: path5
        }));
        return;
      }
    }
  });
  watcher.on("error", (error5) => {
    emit2.fail(SystemError({
      module: "FileSystem",
      reason: "Unknown",
      method: "watch",
      pathOrDescriptor: path4,
      message: error5.message
    }));
  });
  watcher.on("close", () => {
    emit2.end();
  });
  return watcher;
}), (watcher) => sync3(() => watcher.close())));
var watch2 = (backend, path4) => stat2(path4).pipe(map17((stat3) => backend.pipe(flatMap((_) => _.register(path4, stat3)), getOrElse(() => watchNode(path4)))), unwrap4);
var writeFile2 = (path4, data, options6) => async((resume2, signal) => {
  try {
    NFS.writeFile(path4, data, {
      signal,
      flag: options6?.flag,
      mode: options6?.mode
    }, (err) => {
      if (err) {
        resume2(fail8(handleErrnoException("FileSystem", "writeFile")(err, [path4])));
      } else {
        resume2(_void);
      }
    });
  } catch (err) {
    resume2(fail8(handleBadArgument("writeFile")(err)));
  }
});
var makeFileSystem = /* @__PURE__ */ map17(/* @__PURE__ */ serviceOption2(WatchBackend), (backend) => make58({
  access: access2,
  chmod: chmod2,
  chown: chown2,
  copy: copy4,
  copyFile: copyFile2,
  link: link2,
  makeDirectory,
  makeTempDirectory,
  makeTempDirectoryScoped,
  makeTempFile,
  makeTempFileScoped,
  open: open2,
  readDirectory,
  readFile: readFile2,
  readLink,
  realPath,
  remove: remove13,
  rename: rename3,
  stat: stat2,
  symlink: symlink2,
  truncate: truncate2,
  utimes: utimes2,
  watch(path4) {
    return watch2(backend, path4);
  },
  writeFile: writeFile2
}));
var layer15 = /* @__PURE__ */ effect(FileSystem, makeFileSystem);

// node_modules/@effect/platform-node-shared/dist/esm/NodeFileSystem.js
var layer16 = layer15;

// node_modules/@effect/platform-bun/dist/esm/BunFileSystem.js
var layer17 = layer16;

// node_modules/@effect/platform-node-shared/dist/esm/internal/path.js
import * as NodePath from "node:path";
import * as NodeUrl from "node:url";
var fromFileUrl2 = (url2) => try_2({
  try: () => NodeUrl.fileURLToPath(url2),
  catch: (error5) => BadArgument({
    module: "Path",
    method: "fromFileUrl",
    message: `${error5}`
  })
});
var toFileUrl2 = (path4) => try_2({
  try: () => NodeUrl.pathToFileURL(path4),
  catch: (error5) => BadArgument({
    module: "Path",
    method: "toFileUrl",
    message: `${error5}`
  })
});
var layerPosix = /* @__PURE__ */ succeed10(Path2, /* @__PURE__ */ Path2.of({
  [TypeId25]: TypeId25,
  ...NodePath.posix,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));
var layerWin32 = /* @__PURE__ */ succeed10(Path2, /* @__PURE__ */ Path2.of({
  [TypeId25]: TypeId25,
  ...NodePath.win32,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));
var layer18 = /* @__PURE__ */ succeed10(Path2, /* @__PURE__ */ Path2.of({
  [TypeId25]: TypeId25,
  ...NodePath,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));

// node_modules/@effect/platform-node-shared/dist/esm/NodePath.js
var layer19 = layer18;

// node_modules/@effect/platform-bun/dist/esm/BunPath.js
var layer20 = layer19;

// node_modules/@effect/platform-node-shared/dist/esm/internal/terminal.js
import * as readline from "node:readline";
var defaultShouldQuit = (input) => input.key.ctrl && (input.key.name === "c" || input.key.name === "d");
var make108 = (shouldQuit = defaultShouldQuit) => gen2(function* () {
  const input = yield* sync3(() => globalThis.process.stdin);
  const output = yield* sync3(() => globalThis.process.stdout);
  const acquireReadlineInterface = sync3(() => readline.createInterface({
    input,
    escapeCodeTimeout: 50
  }));
  const emitKeypressEvents2 = (rl) => {
    readline.emitKeypressEvents(input, rl);
    if (input.isTTY) {
      input.setRawMode(true);
    }
    return rl;
  };
  const releaseReadlineInterface = (rl) => sync3(() => {
    if (input.isTTY) {
      input.setRawMode(false);
    }
    rl.close();
  });
  const handleKeypressEvent = (input2) => async((resume2) => {
    const handleKeypress = (input3, key) => {
      const userInput = {
        input: fromNullable(input3),
        key: {
          name: key.name || "",
          ctrl: key.ctrl || false,
          meta: key.meta || false,
          shift: key.shift || false
        }
      };
      if (shouldQuit(userInput)) {
        resume2(fail8(new QuitException));
      } else {
        resume2(succeed8(userInput));
      }
    };
    input2.once("keypress", handleKeypress);
    return sync3(() => {
      input2.removeListener("keypress", handleKeypress);
    });
  });
  const handleLineEvent = (rl) => async((resume2) => {
    const handleLine = (line4) => {
      resume2(succeed8(line4));
    };
    rl.on("line", handleLine);
    return sync3(() => {
      rl.removeListener("line", handleLine);
    });
  });
  const readInput = acquireUseRelease2(acquireReadlineInterface.pipe(map17(emitKeypressEvents2)), () => handleKeypressEvent(input), releaseReadlineInterface);
  const readLine = acquireUseRelease2(acquireReadlineInterface, (rl) => handleLineEvent(rl), releaseReadlineInterface);
  const display = (prompt4) => uninterruptible2(async((resume2) => {
    output.write(prompt4, (err) => {
      if (err) {
        resume2(fail8(BadArgument({
          module: "Terminal",
          method: "display",
          message: err.message ?? String(err)
        })));
      }
      resume2(_void);
    });
  }));
  return Terminal.of({
    columns: sync3(() => output.columns || 0),
    readInput,
    readLine,
    display
  });
});
var layer21 = /* @__PURE__ */ scoped3(Terminal, /* @__PURE__ */ make108(defaultShouldQuit));

// node_modules/@effect/platform-node-shared/dist/esm/NodeTerminal.js
var layer22 = layer21;

// node_modules/@effect/platform-bun/dist/esm/BunTerminal.js
var layer23 = layer22;

// node_modules/@effect/platform-bun/dist/esm/internal/worker.js
var platformWorkerImpl = /* @__PURE__ */ makePlatform2()({
  setup({
    scope: scope5,
    worker
  }) {
    return flatMap10(make24(), (closeDeferred) => {
      worker.addEventListener("close", () => {
        unsafeDone(closeDeferred, void_3);
      });
      return as3(addFinalizer2(scope5, suspend3(() => {
        worker.postMessage([1]);
        return _await(closeDeferred);
      }).pipe(interruptible4, timeout2(5000), catchAllCause2(() => sync3(() => worker.terminate())))), worker);
    });
  },
  listen({
    deferred,
    emit: emit2,
    port: port2,
    scope: scope5
  }) {
    function onMessage(event) {
      emit2(event.data);
    }
    function onError5(event) {
      unsafeDone(deferred, new WorkerError({
        reason: "unknown",
        cause: event.error ?? event.message
      }));
    }
    port2.addEventListener("message", onMessage);
    port2.addEventListener("error", onError5);
    return addFinalizer2(scope5, sync3(() => {
      port2.removeEventListener("message", onMessage);
      port2.removeEventListener("error", onError5);
    }));
  }
});
var layerWorker = /* @__PURE__ */ succeed10(PlatformWorker2, platformWorkerImpl);
var layerManager3 = /* @__PURE__ */ provide3(layerManager2, layerWorker);

// node_modules/@effect/platform-bun/dist/esm/BunWorker.js
var layerManager4 = layerManager3;

// node_modules/@effect/platform-bun/dist/esm/BunContext.js
var layer25 = /* @__PURE__ */ pipe(/* @__PURE__ */ mergeAll5(layer20, layer14, layer23, layerManager4), /* @__PURE__ */ provideMerge2(layer17));
// node_modules/ws/wrapper.mjs
var import_stream4 = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);
// node_modules/@effect/platform-bun/dist/esm/BunRuntime.js
var exports_BunRuntime = {};
__export(exports_BunRuntime, {
  runMain: () => runMain3
});

// node_modules/@effect/platform/dist/esm/Runtime.js
var defaultTeardown = (exit3, onExit4) => {
  onExit4(isFailure2(exit3) && !isInterruptedOnly2(exit3.cause) ? 1 : 0);
};
var addPrettyLogger = (refs, fiberId3) => {
  const loggers = getOrDefault2(refs, currentLoggers2);
  if (!has4(loggers, defaultLogger2)) {
    return refs;
  }
  return updateAs2(refs, {
    fiberId: fiberId3,
    fiberRef: currentLoggers2,
    value: loggers.pipe(remove4(defaultLogger2), add4(prettyLoggerDefault2))
  });
};
var makeRunMain = (f) => dual((args2) => isEffect2(args2[0]), (effect4, options6) => {
  const fiber = options6?.disableErrorReporting === true ? runFork2(effect4, {
    updateRefs: options6?.disablePrettyLogger === true ? undefined : addPrettyLogger
  }) : runFork2(tapErrorCause2(effect4, (cause3) => {
    if (isInterruptedOnly2(cause3)) {
      return _void;
    }
    return logError2(cause3);
  }), {
    updateRefs: options6?.disablePrettyLogger === true ? undefined : addPrettyLogger
  });
  const teardown = options6?.teardown ?? defaultTeardown;
  return f({
    fiber,
    teardown
  });
});

// node_modules/@effect/platform-node-shared/dist/esm/internal/runtime.js
var runMain = /* @__PURE__ */ makeRunMain(({
  fiber,
  teardown
}) => {
  const keepAlive = setInterval(constVoid, 2 ** 31 - 1);
  let receivedSignal = false;
  fiber.addObserver((exit3) => {
    if (!receivedSignal) {
      process.removeListener("SIGINT", onSigint);
      process.removeListener("SIGTERM", onSigint);
    }
    clearInterval(keepAlive);
    teardown(exit3, (code3) => {
      if (receivedSignal || code3 !== 0) {
        process.exit(code3);
      }
    });
  });
  function onSigint() {
    receivedSignal = true;
    process.removeListener("SIGINT", onSigint);
    process.removeListener("SIGTERM", onSigint);
    fiber.unsafeInterruptAsFork(fiber.id());
  }
  process.on("SIGINT", onSigint);
  process.on("SIGTERM", onSigint);
});

// node_modules/@effect/platform-node-shared/dist/esm/NodeRuntime.js
var runMain2 = runMain;

// node_modules/@effect/platform-bun/dist/esm/BunRuntime.js
var runMain3 = runMain2;
// node_modules/@effect/platform-bun/dist/esm/internal/workerRunner.js
var platformRunnerImpl = /* @__PURE__ */ PlatformRunner2.of({
  [PlatformRunnerTypeId2]: PlatformRunnerTypeId2,
  start: /* @__PURE__ */ fnUntraced2(function* (closeLatch) {
    if (!("postMessage" in self)) {
      return yield* new WorkerError({
        reason: "spawn",
        cause: new Error("not in a Worker context")
      });
    }
    const port2 = self;
    const run12 = fnUntraced2(function* (handler) {
      const scope5 = yield* scope2;
      const runtime6 = (yield* runtime4().pipe(interruptible4)).pipe(updateContext3(omit2(Scope)));
      const fiberSet = yield* make82();
      const runFork4 = runFork3(runtime6);
      const onExit4 = (exit3) => {
        if (exit3._tag === "Failure" && !isInterruptedOnly2(exit3.cause)) {
          unsafeDone(closeLatch, die3(squash(exit3.cause)));
        }
      };
      function onMessage(event) {
        const message = event.data;
        if (message[0] === 0) {
          const result = handler(0, message[1]);
          if (isEffect2(result)) {
            const fiber = runFork4(result);
            fiber.addObserver(onExit4);
            unsafeAdd(fiberSet, fiber);
          }
        } else {
          port2.close();
          unsafeDone(closeLatch, void_3);
        }
      }
      function onMessageError(error5) {
        unsafeDone(closeLatch, new WorkerError({
          reason: "decode",
          cause: error5.data
        }));
      }
      function onError5(error5) {
        unsafeDone(closeLatch, new WorkerError({
          reason: "unknown",
          cause: error5.data
        }));
      }
      yield* addFinalizer2(scope5, sync3(() => {
        port2.removeEventListener("message", onMessage);
        port2.removeEventListener("messageerror", onError5);
      }));
      port2.addEventListener("message", onMessage);
      port2.addEventListener("messageerror", onMessageError);
      port2.postMessage([0]);
    });
    const send = (_portId, message, transfer) => sync3(() => port2.postMessage([1, message], {
      transfer
    }));
    return {
      run: run12,
      send
    };
  })
});
// node_modules/effect/dist/esm/ExecutionPlan.js
var TypeId64 = TypeId17;
var Proto12 = {
  [TypeId64]: TypeId64,
  get withRequirements() {
    const self2 = this;
    return contextWith2((context9) => makeProto3(self2.steps.map((step4) => ({
      ...step4,
      provide: isLayer2(step4.provide) ? provide3(step4.provide, succeedContext2(context9)) : step4.provide
    }))));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeProto3 = (steps) => {
  const self2 = Object.create(Proto12);
  self2.steps = steps;
  return self2;
};
// node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef";
var ScopedRefTypeId = /* @__PURE__ */ Symbol.for(ScopedRefSymbolKey);
var scopedRefVariance = {
  _A: (_) => _
};
var proto25 = {
  ...CommitPrototype,
  commit() {
    return get26(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
};
var get26 = (self2) => map12(get10(self2.ref), (tuple6) => tuple6[1]);
// node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource";
var ResourceTypeId = /* @__PURE__ */ Symbol.for(ResourceSymbolKey);
var resourceVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var proto26 = {
  ...CommitPrototype,
  commit() {
    return get28(this);
  },
  [ResourceTypeId]: resourceVariance
};
var get28 = (self2) => flatMap8(get26(self2.scopedRef), identity);
// node_modules/effect/dist/esm/SortedMap.js
var TypeId65 = /* @__PURE__ */ Symbol.for("effect/SortedMap");
var SortedMapProto = {
  [TypeId65]: {
    _K: (_) => _,
    _V: (_) => _
  },
  [symbol]() {
    return pipe(hash(this.tree), combine(hash("effect/SortedMap")), cached(this));
  },
  [symbol2](that) {
    return isSortedMap(that) && equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSortedMap = (u) => hasProperty(u, TypeId65);
// node_modules/effect/dist/esm/Subscribable.js
var TypeId66 = /* @__PURE__ */ Symbol.for("effect/Subscribable");
var Proto13 = {
  [TypeId10]: TypeId10,
  [TypeId66]: TypeId66,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// node_modules/effect/dist/esm/TestClock.js
var warning = "Warning: A test is using time, but is not advancing " + "the test clock, which may result in the test hanging. Use TestClock.adjust to " + "manually advance the time.";
var suspendedWarning = "Warning: A test is advancing the test clock, " + "but a fiber is not suspending, which may result in the test hanging. Use " + "TestAspect.diagnose to identity the fiber that is not suspending.";
// node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie";
var TrieTypeId = /* @__PURE__ */ Symbol.for(TrieSymbolKey);
var trieVariance = {
  _Value: (_) => _
};
var TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k, v) => [k, v], () => true);
  },
  [symbol]() {
    let hash2 = hash(TrieSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isTrie(that)) {
      const entries2 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries2[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
class TrieIterator {
  trie;
  f;
  filter;
  stack = [];
  constructor(trie, f, filter16) {
    this.trie = trie;
    this.f = f;
    this.filter = filter16;
    const root = trie._root !== undefined ? trie._root : undefined;
    if (root !== undefined) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value8 = node.value;
        if (value8 !== undefined) {
          const key = keyString + node.key;
          if (this.filter(key, value8)) {
            return {
              done: false,
              value: this.f(key, value8)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: undefined
    };
  }
  addToStack(node, keyString) {
    if (node.right !== undefined) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== undefined) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== undefined) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new TrieIterator(this.trie, this.f, this.filter);
  }
}
var isTrie = (u) => hasProperty(u, TrieTypeId);
// src/Command.ts
import * as NPath2 from "node:path";
// package.json
var package_default = {
  version: "0.1.4",
  name: "weerun",
  bin: "./dst/main.js",
  type: "module",
  exports: {
    "./": "./src/index.ts"
  },
  scripts: {
    build: "bun scripts/build.ts"
  },
  devDependencies: {
    "@types/bun": "^1.2.16",
    "@effect/cli": "^0.63.11",
    effect: "^3.16.7",
    "@effect/platform": "^0.82.8",
    "@effect/platform-bun": "^0.65.5"
  },
  peerDependencies: {
    typescript: "^5.8.3"
  }
};
// node_modules/@effect/platform/dist/esm/HttpApiSchema.js
var AnnotationStatus = /* @__PURE__ */ Symbol.for("@effect/platform/HttpApiSchema/AnnotationStatus");
var annotations3 = (annotations4) => {
  const result = omit3(annotations4, "status");
  if (annotations4.status !== undefined) {
    result[AnnotationStatus] = annotations4.status;
  }
  return result;
};
var extractUnionTypes = (ast) => {
  function process2(ast2) {
    if (isUnion(ast2)) {
      for (const type2 of ast2.types) {
        process2(type2);
      }
    } else {
      out.push(ast2);
    }
  }
  const out = [];
  process2(ast);
  return out;
};
var UnionUnifyAST = (self2, that) => Union.make(Array.from(new Set([...extractUnionTypes(self2), ...extractUnionTypes(that)])));
var UnionUnify = (self2, that) => make66(UnionUnifyAST(self2.ast, that.ast));
var Empty2 = (status2) => Void.annotations(annotations3({
  status: status2
}));
var NoContent = /* @__PURE__ */ Empty2(204);

// node_modules/@effect/platform/dist/esm/HttpApi.js
var TypeId67 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpApi");
var Proto14 = {
  [TypeId67]: TypeId67,
  pipe() {
    return pipeArguments(this, arguments);
  },
  add(group6) {
    return makeProto4({
      identifier: this.identifier,
      groups: set(this.groups, group6.identifier, group6),
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  addHttpApi(api) {
    const newGroups = {
      ...this.groups
    };
    for (const key in api.groups) {
      const newGroup = api.groups[key].annotateContext(empty5());
      newGroup.annotations = merge3(api.annotations, newGroup.annotations);
      newGroup.middlewares = new Set([...api.middlewares, ...newGroup.middlewares]);
      newGroups[key] = newGroup;
    }
    return makeProto4({
      identifier: this.identifier,
      groups: newGroups,
      errorSchema: UnionUnify(this.errorSchema, api.errorSchema),
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  addError(schema2, annotations4) {
    return makeProto4({
      identifier: this.identifier,
      groups: this.groups,
      errorSchema: UnionUnify(this.errorSchema, annotations4?.status ? schema2.annotations(annotations3({
        status: annotations4.status
      })) : schema2),
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  prefix(prefix2) {
    return makeProto4({
      identifier: this.identifier,
      groups: map4(this.groups, (group6) => group6.prefix(prefix2)),
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  middleware(tag8) {
    return makeProto4({
      identifier: this.identifier,
      groups: this.groups,
      errorSchema: UnionUnify(this.errorSchema, tag8.failure),
      annotations: this.annotations,
      middlewares: new Set([...this.middlewares, tag8])
    });
  },
  annotate(tag8, value8) {
    return makeProto4({
      identifier: this.identifier,
      groups: this.groups,
      errorSchema: this.errorSchema,
      annotations: add2(this.annotations, tag8, value8),
      middlewares: this.middlewares
    });
  },
  annotateContext(context10) {
    return makeProto4({
      identifier: this.identifier,
      groups: this.groups,
      errorSchema: this.errorSchema,
      annotations: merge3(this.annotations, context10),
      middlewares: this.middlewares
    });
  }
};
var makeProto4 = (options6) => {
  function HttpApi() {}
  Object.setPrototypeOf(HttpApi, Proto14);
  HttpApi.groups = options6.groups;
  HttpApi.errorSchema = options6.errorSchema;
  HttpApi.annotations = options6.annotations;
  HttpApi.middlewares = options6.middlewares;
  return HttpApi;
};
// node_modules/@effect/platform/dist/esm/HttpApiBuilder.js
var HandlersTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/HttpApiBuilder/Handlers");
var HandlersProto = {
  [HandlersTypeId]: {
    _Endpoints: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  handle(name, handler, options6) {
    const endpoint = this.group.endpoints[name];
    return makeHandlers({
      group: this.group,
      handlers: append2(this.handlers, {
        endpoint,
        handler,
        withFullResponse: false,
        uninterruptible: options6?.uninterruptible ?? false
      })
    });
  },
  handleRaw(name, handler, options6) {
    const endpoint = this.group.endpoints[name];
    return makeHandlers({
      group: this.group,
      handlers: append2(this.handlers, {
        endpoint,
        handler,
        withFullResponse: true,
        uninterruptible: options6?.uninterruptible ?? false
      })
    });
  }
};
var makeHandlers = (options6) => {
  const self2 = Object.create(HandlersProto);
  self2.group = options6.group;
  self2.handlers = options6.handlers;
  return self2;
};
var bearerLen = `Bearer `.length;
var basicLen = `Basic `.length;
// node_modules/@effect/platform/dist/esm/HttpApiEndpoint.js
var TypeId68 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpApiEndpoint");
var Proto15 = {
  [TypeId68]: TypeId68,
  pipe() {
    return pipeArguments(this, arguments);
  },
  addSuccess(schema2, annotations4) {
    schema2 = annotations4?.status ? schema2.annotations(annotations3({
      status: annotations4.status
    })) : schema2;
    return makeProto5({
      ...this,
      successSchema: this.successSchema === NoContent ? schema2 : UnionUnify(this.successSchema, schema2)
    });
  },
  addError(schema2, annotations4) {
    return makeProto5({
      ...this,
      errorSchema: UnionUnify(this.errorSchema, annotations4?.status ? schema2.annotations(annotations3({
        status: annotations4.status
      })) : schema2)
    });
  },
  setPayload(schema2) {
    return makeProto5({
      ...this,
      payloadSchema: some2(schema2)
    });
  },
  setPath(schema2) {
    return makeProto5({
      ...this,
      pathSchema: some2(schema2)
    });
  },
  setUrlParams(schema2) {
    return makeProto5({
      ...this,
      urlParamsSchema: some2(schema2)
    });
  },
  setHeaders(schema2) {
    return makeProto5({
      ...this,
      headersSchema: some2(schema2)
    });
  },
  prefix(prefix2) {
    return makeProto5({
      ...this,
      path: prefixPath2(this.path, prefix2)
    });
  },
  middleware(middleware) {
    return makeProto5({
      ...this,
      errorSchema: UnionUnify(this.errorSchema, middleware.failure),
      middlewares: new Set([...this.middlewares, middleware])
    });
  },
  annotate(tag8, value8) {
    return makeProto5({
      ...this,
      annotations: add2(this.annotations, tag8, value8)
    });
  },
  annotateContext(context10) {
    return makeProto5({
      ...this,
      annotations: merge3(this.annotations, context10)
    });
  }
};
var makeProto5 = (options6) => Object.assign(Object.create(Proto15), options6);
// node_modules/@effect/platform/dist/esm/HttpApiGroup.js
var TypeId69 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpApiGroup");
var Proto16 = {
  [TypeId69]: TypeId69,
  add(endpoint) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: {
        ...this.endpoints,
        [endpoint.name]: endpoint
      },
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  addError(schema2, annotations4) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: this.endpoints,
      errorSchema: UnionUnify(this.errorSchema, annotations4?.status ? schema2.annotations(annotations3({
        status: annotations4.status
      })) : schema2),
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  prefix(prefix2) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: map4(this.endpoints, (endpoint) => endpoint.prefix(prefix2)),
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  middleware(middleware) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: this.endpoints,
      errorSchema: UnionUnify(this.errorSchema, middleware.failure),
      annotations: this.annotations,
      middlewares: new Set([...this.middlewares, middleware])
    });
  },
  middlewareEndpoints(middleware) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: map4(this.endpoints, (endpoint) => endpoint.middleware(middleware)),
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  annotateContext(context10) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: this.endpoints,
      errorSchema: this.errorSchema,
      annotations: merge3(this.annotations, context10),
      middlewares: this.middlewares
    });
  },
  annotate(tag8, value8) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: this.endpoints,
      errorSchema: this.errorSchema,
      annotations: add2(this.annotations, tag8, value8),
      middlewares: this.middlewares
    });
  },
  annotateEndpointsContext(context10) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: map4(this.endpoints, (endpoint) => endpoint.annotateContext(context10)),
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  annotateEndpoints(tag8, value8) {
    return makeProto6({
      identifier: this.identifier,
      topLevel: this.topLevel,
      endpoints: map4(this.endpoints, (endpoint) => endpoint.annotate(tag8, value8)),
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeProto6 = (options6) => {
  function HttpApiGroup() {}
  Object.setPrototypeOf(HttpApiGroup, Proto16);
  return Object.assign(HttpApiGroup, options6);
};
// node_modules/@effect/platform/dist/esm/HttpApiSecurity.js
var TypeId70 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpApiSecurity");
var Proto17 = {
  [TypeId70]: TypeId70,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// src/FileSystemExtra.ts
import * as NFSP from "node:fs/promises";
import * as NPath from "node:path";
var watchFileChanges = (path4, opts) => {
  const baseDir = path4 ?? process.cwd();
  let stream10;
  try {
    stream10 = exports_Stream.fromAsyncIterable(NFSP.watch(baseDir, {
      persistent: false,
      recursive: true,
      ...opts || {}
    }), (error5) => handleWatchError(error5, baseDir));
  } catch (e) {
    const err = handleWatchError(e, baseDir);
    stream10 = exports_Stream.fail(err);
  }
  return pipe(stream10, exports_Stream.map((event) => ({
    ...event,
    filename: event.filename ? NPath.resolve(baseDir, event.filename) : null
  })));
};
var handleWatchError = (error5, path4) => exports_Error.SystemError({
  message: error5.message,
  module: "FileSystem",
  reason: "Unknown",
  method: "watch",
  pathOrDescriptor: path4
});

// src/Runner.ts
var start7 = (opts) => {
  const processRef = exports_MutableRef.make(null);
  const paths = exports_Array.ensure(opts.path);
  const mergedStream = exports_Stream.mergeAll(paths.map((dir3) => watchFileChanges(dir3)), {
    concurrency: "unbounded"
  });
  return exports_Effect.gen(function* () {
    yield* pipe(mergedStream, exports_Stream.debounce(opts.delay), exports_Stream.tap((event) => exports_Console.log(`${event.eventType.toUpperCase()}	${event.filename}
`)), exports_Stream.runForEach(() => exports_Effect.gen(function* () {
      const [cmd, ...args2] = opts.command;
      const process2 = yield* exports_Command2.make(cmd, ...args2).pipe(exports_Command2.stdout("inherit"), exports_Command2.start);
      exports_MutableRef.set(processRef, process2);
    })), exports_Stream.runDrain);
  });
};

// src/Command.ts
var pathOpt = exports_Options.text("path").pipe(exports_Options.repeated, exports_Options.withDefault(["./"]), exports_Options.withAlias("p"), exports_Options.withDescription("Paths to watch. Defaults to current directory."));
var delayOpt = exports_Options.float("delay").pipe(exports_Options.withAlias("d"), exports_Options.withDefault(0.1), exports_Options.withDescription("Delay in seconds before rerunning the command."));
var verboseOpt = exports_Options.boolean("verbose").pipe(exports_Options.withAlias("v"), exports_Options.withDescription("Print resolved paths that are being watched."));
var commandArg = exports_Args.text({ name: "command" }).pipe(exports_Args.withDescription("Command to execute when files change"));
var commandArgsArg = exports_Args.text({ name: "arg" }).pipe(exports_Args.repeated);
var mainCommand = exports_Command.make("rerun", {
  paths: pathOpt,
  delay: delayOpt,
  verbose: verboseOpt,
  command: commandArg,
  args: commandArgsArg
}, (args2) => exports_Effect.gen(function* () {
  const watchDirs = args2.paths.map((v) => NPath2.resolve(v));
  if (watchDirs.length === 0) {
    watchDirs.push(process.cwd());
  }
  if (args2.verbose) {
    yield* exports_Console.log(`Watching:
${watchDirs.join(`
`)}
`);
  }
  yield* start7({
    command: [args2.command, ...args2.args],
    path: watchDirs,
    delay: exports_Duration.seconds(args2.delay)
  });
}));
var run12 = exports_Command.run(mainCommand, {
  name: "rerun",
  version: package_default.version,
  summary: exports_Span.text("Run command on files change")
});

// src/index.ts
if (__require.main == __require.module) {
  pipe(run12(process.argv), exports_Effect.provide(exports_CliConfig.layer({
    showTypes: false,
    showBuiltIns: false
  })), exports_Effect.provide(exports_BunContext.layer), exports_Effect.scoped, exports_BunRuntime.runMain);
}
